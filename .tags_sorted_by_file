!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
AR	Makefile	/^AR=xcrun ar$/;"	m
BENCHMARKS	Makefile	/^BENCHMARKS = \\$/;"	m
DEVICESDK	Makefile	/^DEVICESDK=$(shell xcrun -sdk iphoneos --show-sdk-path)$/;"	m
DEVICE_ALLOBJS	Makefile	/^DEVICE_ALLOBJS := $(DEVICE_LIBOBJECTS) $(DEVICE_MEMENVOBJECTS)$/;"	m
DEVICE_CFLAGS	Makefile	/^DEVICE_CFLAGS = -isysroot "$(DEVICESDK)" -arch armv6 -arch armv7 -arch armv7s -arch arm64$/;"	m
DEVICE_LIBOBJECTS	Makefile	/^DEVICE_LIBOBJECTS := $(addprefix $(DEVICE_OUTDIR)\/, $(SOURCES:.cc=.o))$/;"	m
DEVICE_MEMENVOBJECTS	Makefile	/^DEVICE_MEMENVOBJECTS := $(addprefix $(DEVICE_OUTDIR)\/, $(MEMENV_SOURCES:.cc=.o))$/;"	m
DEVICE_OUTDIR	Makefile	/^DEVICE_OUTDIR=out-ios-arm$/;"	m
OPT	Makefile	/^OPT ?= -g2 -DMULTI_THREAD_MODE$/;"	m
PROGNAMES	Makefile	/^PROGNAMES := $(notdir $(TESTS) $(UTILS))$/;"	m
SHARED_ALLOBJS	Makefile	/^SHARED_ALLOBJS := $(SHARED_LIBOBJECTS) $(SHARED_MEMENVOBJECTS) $(TESTHARNESS)$/;"	m
SHARED_LIB1	Makefile	/^SHARED_LIB1 = libleveldb.$(PLATFORM_SHARED_EXT)$/;"	m
SHARED_LIB2	Makefile	/^SHARED_LIB2 = $(SHARED_LIB1)$/;"	m
SHARED_LIB2	Makefile	/^SHARED_LIB2 = $(SHARED_LIB1).$(SHARED_VERSION_MAJOR)$/;"	m
SHARED_LIB3	Makefile	/^SHARED_LIB3 = $(SHARED_LIB1)$/;"	m
SHARED_LIB3	Makefile	/^SHARED_LIB3 = $(SHARED_LIB1).$(SHARED_VERSION_MAJOR).$(SHARED_VERSION_MINOR)$/;"	m
SHARED_LIBOBJECTS	Makefile	/^SHARED_LIBOBJECTS := $(addprefix $(SHARED_OUTDIR)\/, $(SOURCES:.cc=.o))$/;"	m
SHARED_LIBS	Makefile	/^SHARED_LIBS = $(SHARED_LIB1)$/;"	m
SHARED_LIBS	Makefile	/^SHARED_LIBS = $(SHARED_OUTDIR)\/$(SHARED_LIB1) $(SHARED_OUTDIR)\/$(SHARED_LIB2) $(SHARED_OUTDIR)\/$(SHARED_LIB3)$/;"	m
SHARED_MEMENVLIB	Makefile	/^SHARED_MEMENVLIB = $(SHARED_OUTDIR)\/libmemenv.a$/;"	m
SHARED_MEMENVOBJECTS	Makefile	/^SHARED_MEMENVOBJECTS := $(addprefix $(SHARED_OUTDIR)\/, $(MEMENV_SOURCES:.cc=.o))$/;"	m
SHARED_OUTDIR	Makefile	/^SHARED_OUTDIR=out-shared$/;"	m
SHARED_PROGRAMS	Makefile	/^SHARED_PROGRAMS := $(addprefix $(SHARED_OUTDIR)\/, db_bench)$/;"	m
SHARED_VERSION_MAJOR	Makefile	/^SHARED_VERSION_MAJOR = 1$/;"	m
SHARED_VERSION_MINOR	Makefile	/^SHARED_VERSION_MINOR = 20$/;"	m
SIMULATORSDK	Makefile	/^SIMULATORSDK=$(shell xcrun -sdk iphonesimulator --show-sdk-path)$/;"	m
SIMULATOR_ALLOBJS	Makefile	/^SIMULATOR_ALLOBJS := $(SIMULATOR_LIBOBJECTS) $(SIMULATOR_MEMENVOBJECTS)$/;"	m
SIMULATOR_CFLAGS	Makefile	/^SIMULATOR_CFLAGS = -isysroot "$(SIMULATORSDK)" -arch i686 -arch x86_64$/;"	m
SIMULATOR_LIBOBJECTS	Makefile	/^SIMULATOR_LIBOBJECTS := $(addprefix $(SIMULATOR_OUTDIR)\/, $(SOURCES:.cc=.o))$/;"	m
SIMULATOR_MEMENVOBJECTS	Makefile	/^SIMULATOR_MEMENVOBJECTS := $(addprefix $(SIMULATOR_OUTDIR)\/, $(MEMENV_SOURCES:.cc=.o))$/;"	m
SIMULATOR_OUTDIR	Makefile	/^SIMULATOR_OUTDIR=out-ios-x86$/;"	m
STATIC_ALLOBJS	Makefile	/^STATIC_ALLOBJS := $(STATIC_LIBOBJECTS) $(STATIC_MEMENVOBJECTS) $(STATIC_TESTOBJS) $(STATIC_UTILOBJS) $(TESTHARNESS)$/;"	m
STATIC_LIBOBJECTS	Makefile	/^STATIC_LIBOBJECTS := $(addprefix $(STATIC_OUTDIR)\/, $(SOURCES:.cc=.o))$/;"	m
STATIC_MEMENVOBJECTS	Makefile	/^STATIC_MEMENVOBJECTS := $(addprefix $(STATIC_OUTDIR)\/, $(MEMENV_SOURCES:.cc=.o))$/;"	m
STATIC_OUTDIR	Makefile	/^STATIC_OUTDIR=out-ios-universal$/;"	m
STATIC_OUTDIR	Makefile	/^STATIC_OUTDIR=out-static$/;"	m
STATIC_PROGRAMS	Makefile	/^STATIC_PROGRAMS := $(addprefix $(STATIC_OUTDIR)\/, $(PROGNAMES))$/;"	m
STATIC_TESTOBJS	Makefile	/^STATIC_TESTOBJS := $(addprefix $(STATIC_OUTDIR)\/, $(addsuffix .o, $(TESTS)))$/;"	m
STATIC_UTILOBJS	Makefile	/^STATIC_UTILOBJS := $(addprefix $(STATIC_OUTDIR)\/, $(addsuffix .o, $(UTILS)))$/;"	m
TESTHARNESS	Makefile	/^TESTHARNESS := $(STATIC_OUTDIR)\/util\/testharness.o $(TESTUTIL)$/;"	m
TESTS	Makefile	/^TESTS = \\$/;"	m
TESTUTIL	Makefile	/^TESTUTIL := $(STATIC_OUTDIR)\/util\/testutil.o$/;"	m
UTILS	Makefile	/^UTILS = \\$/;"	m
CC	build_config.mk	/^CC=cc$/;"	m
CXX	build_config.mk	/^CXX=g++$/;"	m
MEMENV_SOURCES	build_config.mk	/^MEMENV_SOURCES=helpers\/memenv\/memenv.cc$/;"	m
PLATFORM	build_config.mk	/^PLATFORM=OS_LINUX$/;"	m
PLATFORM_CCFLAGS	build_config.mk	/^PLATFORM_CCFLAGS= -fno-builtin-memcmp -pthread -DOS_LINUX -DLEVELDB_PLATFORM_POSIX -DLEVELDB_ATOMIC_PRESENT -DSNAPPY$/;"	m
PLATFORM_CXXFLAGS	build_config.mk	/^PLATFORM_CXXFLAGS=-std=c++11 -fno-builtin-memcmp -pthread -DOS_LINUX -DLEVELDB_PLATFORM_POSIX -DLEVELDB_ATOMIC_PRESENT -DSNAPPY$/;"	m
PLATFORM_LDFLAGS	build_config.mk	/^PLATFORM_LDFLAGS=-pthread$/;"	m
PLATFORM_LIBS	build_config.mk	/^PLATFORM_LIBS= -lsnappy$/;"	m
PLATFORM_SHARED_CFLAGS	build_config.mk	/^PLATFORM_SHARED_CFLAGS=-fPIC$/;"	m
PLATFORM_SHARED_EXT	build_config.mk	/^PLATFORM_SHARED_EXT=so$/;"	m
PLATFORM_SHARED_LDFLAGS	build_config.mk	/^PLATFORM_SHARED_LDFLAGS=-shared -Wl,-soname -Wl,$/;"	m
PLATFORM_SHARED_VERSIONED	build_config.mk	/^PLATFORM_SHARED_VERSIONED=true$/;"	m
PLATFORM_SSEFLAGS	build_config.mk	/^PLATFORM_SSEFLAGS=-msse4.2 -DLEVELDB_PLATFORM_POSIX_SSE$/;"	m
SOURCES	build_config.mk	/^SOURCES=db\/builder.cc db\/c.cc db\/dbformat.cc db\/db_impl.cc db\/db_iter.cc db\/dumpfile.cc db\/filename.cc db\/log_reader.cc db\/log_writer.cc db\/memtable.cc db\/repair.cc db\/table_cache.cc db\/version_edit.cc db\/version_set.cc db\/write_batch.cc table\/block_builder.cc table\/block.cc table\/filter_block.cc table\/format.cc table\/iterator.cc table\/merger.cc table\/table_builder.cc table\/table.cc table\/two_level_iterator.cc util\/arena.cc util\/bloom.cc util\/cache.cc util\/coding.cc util\/comparator.cc util\/crc32c.cc util\/env.cc util\/env_posix.cc util\/filter_policy.cc util\/hash.cc util\/histogram.cc util\/logging.cc util\/multi_bloom.cc util\/multi_queue.cc util\/options.cc util\/statistics.cc util\/status.cc util\/threadpool_imp.cc  port\/port_posix.cc port\/port_posix_sse.cc$/;"	m
AutoCompactTest	db/autocompact_test.cc	/^  AutoCompactTest() {$/;"	f	class:leveldb::AutoCompactTest
AutoCompactTest	db/autocompact_test.cc	/^class AutoCompactTest {$/;"	c	namespace:leveldb	file:
DoReads	db/autocompact_test.cc	/^void AutoCompactTest::DoReads(int n) {$/;"	f	class:leveldb::AutoCompactTest
Key	db/autocompact_test.cc	/^  std::string Key(int i) {$/;"	f	class:leveldb::AutoCompactTest
Size	db/autocompact_test.cc	/^  uint64_t Size(const Slice& start, const Slice& limit) {$/;"	f	class:leveldb::AutoCompactTest
TEST	db/autocompact_test.cc	/^TEST(AutoCompactTest, ReadAll) {$/;"	f	namespace:leveldb
TEST	db/autocompact_test.cc	/^TEST(AutoCompactTest, ReadHalf) {$/;"	f	namespace:leveldb
db_	db/autocompact_test.cc	/^  DB* db_;$/;"	m	class:leveldb::AutoCompactTest	file:
dbname_	db/autocompact_test.cc	/^  std::string dbname_;$/;"	m	class:leveldb::AutoCompactTest	file:
kCount	db/autocompact_test.cc	/^static const int kCount = kTotalSize \/ kValueSize;$/;"	m	namespace:leveldb	file:
kTotalSize	db/autocompact_test.cc	/^static const int kTotalSize = 100 * 1024 * 1024;$/;"	m	namespace:leveldb	file:
kValueSize	db/autocompact_test.cc	/^static const int kValueSize = 200 * 1024;$/;"	m	namespace:leveldb	file:
leveldb	db/autocompact_test.cc	/^namespace leveldb {$/;"	n	file:
main	db/autocompact_test.cc	/^int main(int argc, char** argv) {$/;"	f
options_	db/autocompact_test.cc	/^  Options options_;$/;"	m	class:leveldb::AutoCompactTest	file:
tiny_cache_	db/autocompact_test.cc	/^  Cache* tiny_cache_;$/;"	m	class:leveldb::AutoCompactTest	file:
~AutoCompactTest	db/autocompact_test.cc	/^  ~AutoCompactTest() {$/;"	f	class:leveldb::AutoCompactTest
BuildTable	db/builder.cc	/^Status BuildTable(const std::string& dbname,$/;"	f	namespace:leveldb
leveldb	db/builder.cc	/^namespace leveldb {$/;"	n	file:
STORAGE_LEVELDB_DB_BUILDER_H_	db/builder.h	6;"	d
leveldb	db/builder.h	/^namespace leveldb {$/;"	n
Compare	db/c.cc	/^  virtual int Compare(const Slice& a, const Slice& b) const {$/;"	f	struct:leveldb_comparator_t
CopyString	db/c.cc	/^static char* CopyString(const std::string& str) {$/;"	f	file:
CreateFilter	db/c.cc	/^   virtual void CreateFilter(const Slice *keys,int n,std::list<std::string> &dsts) const{$/;"	f	struct:leveldb_filterpolicy_t
CreateFilter	db/c.cc	/^  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {$/;"	f	struct:leveldb_filterpolicy_t
FindShortSuccessor	db/c.cc	/^  virtual void FindShortSuccessor(std::string* key) const { }$/;"	f	struct:leveldb_comparator_t
FindShortestSeparator	db/c.cc	/^  virtual void FindShortestSeparator(std::string*, const Slice&) const { }$/;"	f	struct:leveldb_comparator_t
KeyMayMatch	db/c.cc	/^  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const {$/;"	f	struct:leveldb_filterpolicy_t
KeyMayMatchFilters	db/c.cc	/^   virtual bool KeyMayMatchFilters(const Slice& key, const std::list<leveldb::Slice>& filters) const {$/;"	f	struct:leveldb_filterpolicy_t
Name	db/c.cc	/^  virtual const char* Name() const {$/;"	f	struct:leveldb_comparator_t
Name	db/c.cc	/^  virtual const char* Name() const {$/;"	f	struct:leveldb_filterpolicy_t
SaveError	db/c.cc	/^static bool SaveError(char** errptr, const Status& s) {$/;"	f	file:
compare_	db/c.cc	/^  int (*compare_)($/;"	m	struct:leveldb_comparator_t	file:
create_	db/c.cc	/^  char* (*create_)($/;"	m	struct:leveldb_filterpolicy_t	file:
destructor_	db/c.cc	/^  void (*destructor_)(void*);$/;"	m	struct:leveldb_comparator_t	file:
destructor_	db/c.cc	/^  void (*destructor_)(void*);$/;"	m	struct:leveldb_filterpolicy_t	file:
filterNums	db/c.cc	/^   virtual int filterNums() const { return 1;}$/;"	f	struct:leveldb_filterpolicy_t
is_default	db/c.cc	/^  bool is_default;$/;"	m	struct:leveldb_env_t	file:
key_match_	db/c.cc	/^  unsigned char (*key_match_)($/;"	m	struct:leveldb_filterpolicy_t	file:
leveldb_approximate_sizes	db/c.cc	/^void leveldb_approximate_sizes($/;"	f
leveldb_cache_create_lru	db/c.cc	/^leveldb_cache_t* leveldb_cache_create_lru(size_t capacity) {$/;"	f
leveldb_cache_destroy	db/c.cc	/^void leveldb_cache_destroy(leveldb_cache_t* cache) {$/;"	f
leveldb_cache_t	db/c.cc	/^struct leveldb_cache_t        { Cache*            rep; };$/;"	s	file:
leveldb_close	db/c.cc	/^void leveldb_close(leveldb_t* db) {$/;"	f
leveldb_compact_range	db/c.cc	/^void leveldb_compact_range($/;"	f
leveldb_comparator_create	db/c.cc	/^leveldb_comparator_t* leveldb_comparator_create($/;"	f
leveldb_comparator_destroy	db/c.cc	/^void leveldb_comparator_destroy(leveldb_comparator_t* cmp) {$/;"	f
leveldb_comparator_t	db/c.cc	/^struct leveldb_comparator_t : public Comparator {$/;"	s	file:
leveldb_create_default_env	db/c.cc	/^leveldb_env_t* leveldb_create_default_env() {$/;"	f
leveldb_create_iterator	db/c.cc	/^leveldb_iterator_t* leveldb_create_iterator($/;"	f
leveldb_create_snapshot	db/c.cc	/^const leveldb_snapshot_t* leveldb_create_snapshot($/;"	f
leveldb_delete	db/c.cc	/^void leveldb_delete($/;"	f
leveldb_destroy_db	db/c.cc	/^void leveldb_destroy_db($/;"	f
leveldb_env_destroy	db/c.cc	/^void leveldb_env_destroy(leveldb_env_t* env) {$/;"	f
leveldb_env_t	db/c.cc	/^struct leveldb_env_t {$/;"	s	file:
leveldb_filelock_t	db/c.cc	/^struct leveldb_filelock_t     { FileLock*         rep; };$/;"	s	file:
leveldb_filterpolicy_create	db/c.cc	/^leveldb_filterpolicy_t* leveldb_filterpolicy_create($/;"	f
leveldb_filterpolicy_create_bloom	db/c.cc	/^leveldb_filterpolicy_t* leveldb_filterpolicy_create_bloom(int bits_per_key) {$/;"	f
leveldb_filterpolicy_destroy	db/c.cc	/^void leveldb_filterpolicy_destroy(leveldb_filterpolicy_t* filter) {$/;"	f
leveldb_filterpolicy_t	db/c.cc	/^struct leveldb_filterpolicy_t : public FilterPolicy {$/;"	s	file:
leveldb_free	db/c.cc	/^void leveldb_free(void* ptr) {$/;"	f
leveldb_get	db/c.cc	/^char* leveldb_get($/;"	f
leveldb_iter_destroy	db/c.cc	/^void leveldb_iter_destroy(leveldb_iterator_t* iter) {$/;"	f
leveldb_iter_get_error	db/c.cc	/^void leveldb_iter_get_error(const leveldb_iterator_t* iter, char** errptr) {$/;"	f
leveldb_iter_key	db/c.cc	/^const char* leveldb_iter_key(const leveldb_iterator_t* iter, size_t* klen) {$/;"	f
leveldb_iter_next	db/c.cc	/^void leveldb_iter_next(leveldb_iterator_t* iter) {$/;"	f
leveldb_iter_prev	db/c.cc	/^void leveldb_iter_prev(leveldb_iterator_t* iter) {$/;"	f
leveldb_iter_seek	db/c.cc	/^void leveldb_iter_seek(leveldb_iterator_t* iter, const char* k, size_t klen) {$/;"	f
leveldb_iter_seek_to_first	db/c.cc	/^void leveldb_iter_seek_to_first(leveldb_iterator_t* iter) {$/;"	f
leveldb_iter_seek_to_last	db/c.cc	/^void leveldb_iter_seek_to_last(leveldb_iterator_t* iter) {$/;"	f
leveldb_iter_valid	db/c.cc	/^unsigned char leveldb_iter_valid(const leveldb_iterator_t* iter) {$/;"	f
leveldb_iter_value	db/c.cc	/^const char* leveldb_iter_value(const leveldb_iterator_t* iter, size_t* vlen) {$/;"	f
leveldb_iterator_t	db/c.cc	/^struct leveldb_iterator_t     { Iterator*         rep; };$/;"	s	file:
leveldb_logger_t	db/c.cc	/^struct leveldb_logger_t       { Logger*           rep; };$/;"	s	file:
leveldb_major_version	db/c.cc	/^int leveldb_major_version() {$/;"	f
leveldb_minor_version	db/c.cc	/^int leveldb_minor_version() {$/;"	f
leveldb_open	db/c.cc	/^leveldb_t* leveldb_open($/;"	f
leveldb_options_create	db/c.cc	/^leveldb_options_t* leveldb_options_create() {$/;"	f
leveldb_options_destroy	db/c.cc	/^void leveldb_options_destroy(leveldb_options_t* options) {$/;"	f
leveldb_options_set_block_restart_interval	db/c.cc	/^void leveldb_options_set_block_restart_interval(leveldb_options_t* opt, int n) {$/;"	f
leveldb_options_set_block_size	db/c.cc	/^void leveldb_options_set_block_size(leveldb_options_t* opt, size_t s) {$/;"	f
leveldb_options_set_cache	db/c.cc	/^void leveldb_options_set_cache(leveldb_options_t* opt, leveldb_cache_t* c) {$/;"	f
leveldb_options_set_comparator	db/c.cc	/^void leveldb_options_set_comparator($/;"	f
leveldb_options_set_compression	db/c.cc	/^void leveldb_options_set_compression(leveldb_options_t* opt, int t) {$/;"	f
leveldb_options_set_create_if_missing	db/c.cc	/^void leveldb_options_set_create_if_missing($/;"	f
leveldb_options_set_env	db/c.cc	/^void leveldb_options_set_env(leveldb_options_t* opt, leveldb_env_t* env) {$/;"	f
leveldb_options_set_error_if_exists	db/c.cc	/^void leveldb_options_set_error_if_exists($/;"	f
leveldb_options_set_filter_policy	db/c.cc	/^void leveldb_options_set_filter_policy($/;"	f
leveldb_options_set_info_log	db/c.cc	/^void leveldb_options_set_info_log(leveldb_options_t* opt, leveldb_logger_t* l) {$/;"	f
leveldb_options_set_max_open_files	db/c.cc	/^void leveldb_options_set_max_open_files(leveldb_options_t* opt, int n) {$/;"	f
leveldb_options_set_paranoid_checks	db/c.cc	/^void leveldb_options_set_paranoid_checks($/;"	f
leveldb_options_set_write_buffer_size	db/c.cc	/^void leveldb_options_set_write_buffer_size(leveldb_options_t* opt, size_t s) {$/;"	f
leveldb_options_t	db/c.cc	/^struct leveldb_options_t      { Options           rep; };$/;"	s	file:
leveldb_property_value	db/c.cc	/^char* leveldb_property_value($/;"	f
leveldb_put	db/c.cc	/^void leveldb_put($/;"	f
leveldb_randomfile_t	db/c.cc	/^struct leveldb_randomfile_t   { RandomAccessFile* rep; };$/;"	s	file:
leveldb_readoptions_create	db/c.cc	/^leveldb_readoptions_t* leveldb_readoptions_create() {$/;"	f
leveldb_readoptions_destroy	db/c.cc	/^void leveldb_readoptions_destroy(leveldb_readoptions_t* opt) {$/;"	f
leveldb_readoptions_set_fill_cache	db/c.cc	/^void leveldb_readoptions_set_fill_cache($/;"	f
leveldb_readoptions_set_snapshot	db/c.cc	/^void leveldb_readoptions_set_snapshot($/;"	f
leveldb_readoptions_set_verify_checksums	db/c.cc	/^void leveldb_readoptions_set_verify_checksums($/;"	f
leveldb_readoptions_t	db/c.cc	/^struct leveldb_readoptions_t  { ReadOptions       rep; };$/;"	s	file:
leveldb_release_snapshot	db/c.cc	/^void leveldb_release_snapshot($/;"	f
leveldb_repair_db	db/c.cc	/^void leveldb_repair_db($/;"	f
leveldb_seqfile_t	db/c.cc	/^struct leveldb_seqfile_t      { SequentialFile*   rep; };$/;"	s	file:
leveldb_snapshot_t	db/c.cc	/^struct leveldb_snapshot_t     { const Snapshot*   rep; };$/;"	s	file:
leveldb_t	db/c.cc	/^struct leveldb_t              { DB*               rep; };$/;"	s	file:
leveldb_writablefile_t	db/c.cc	/^struct leveldb_writablefile_t { WritableFile*     rep; };$/;"	s	file:
leveldb_write	db/c.cc	/^void leveldb_write($/;"	f
leveldb_writebatch_clear	db/c.cc	/^void leveldb_writebatch_clear(leveldb_writebatch_t* b) {$/;"	f
leveldb_writebatch_create	db/c.cc	/^leveldb_writebatch_t* leveldb_writebatch_create() {$/;"	f
leveldb_writebatch_delete	db/c.cc	/^void leveldb_writebatch_delete($/;"	f
leveldb_writebatch_destroy	db/c.cc	/^void leveldb_writebatch_destroy(leveldb_writebatch_t* b) {$/;"	f
leveldb_writebatch_iterate	db/c.cc	/^void leveldb_writebatch_iterate($/;"	f
leveldb_writebatch_put	db/c.cc	/^void leveldb_writebatch_put($/;"	f
leveldb_writebatch_t	db/c.cc	/^struct leveldb_writebatch_t   { WriteBatch        rep; };$/;"	s	file:
leveldb_writeoptions_create	db/c.cc	/^leveldb_writeoptions_t* leveldb_writeoptions_create() {$/;"	f
leveldb_writeoptions_destroy	db/c.cc	/^void leveldb_writeoptions_destroy(leveldb_writeoptions_t* opt) {$/;"	f
leveldb_writeoptions_set_sync	db/c.cc	/^void leveldb_writeoptions_set_sync($/;"	f
leveldb_writeoptions_t	db/c.cc	/^struct leveldb_writeoptions_t { WriteOptions      rep; };$/;"	s	file:
name_	db/c.cc	/^  const char* (*name_)(void*);$/;"	m	struct:leveldb_comparator_t	file:
name_	db/c.cc	/^  const char* (*name_)(void*);$/;"	m	struct:leveldb_filterpolicy_t	file:
rep	db/c.cc	/^  Env* rep;$/;"	m	struct:leveldb_env_t	file:
rep	db/c.cc	/^struct leveldb_cache_t        { Cache*            rep; };$/;"	m	struct:leveldb_cache_t	file:
rep	db/c.cc	/^struct leveldb_filelock_t     { FileLock*         rep; };$/;"	m	struct:leveldb_filelock_t	file:
rep	db/c.cc	/^struct leveldb_iterator_t     { Iterator*         rep; };$/;"	m	struct:leveldb_iterator_t	file:
rep	db/c.cc	/^struct leveldb_logger_t       { Logger*           rep; };$/;"	m	struct:leveldb_logger_t	file:
rep	db/c.cc	/^struct leveldb_options_t      { Options           rep; };$/;"	m	struct:leveldb_options_t	file:
rep	db/c.cc	/^struct leveldb_randomfile_t   { RandomAccessFile* rep; };$/;"	m	struct:leveldb_randomfile_t	file:
rep	db/c.cc	/^struct leveldb_readoptions_t  { ReadOptions       rep; };$/;"	m	struct:leveldb_readoptions_t	file:
rep	db/c.cc	/^struct leveldb_seqfile_t      { SequentialFile*   rep; };$/;"	m	struct:leveldb_seqfile_t	file:
rep	db/c.cc	/^struct leveldb_snapshot_t     { const Snapshot*   rep; };$/;"	m	struct:leveldb_snapshot_t	file:
rep	db/c.cc	/^struct leveldb_t              { DB*               rep; };$/;"	m	struct:leveldb_t	file:
rep	db/c.cc	/^struct leveldb_writablefile_t { WritableFile*     rep; };$/;"	m	struct:leveldb_writablefile_t	file:
rep	db/c.cc	/^struct leveldb_writebatch_t   { WriteBatch        rep; };$/;"	m	struct:leveldb_writebatch_t	file:
rep	db/c.cc	/^struct leveldb_writeoptions_t { WriteOptions      rep; };$/;"	m	struct:leveldb_writeoptions_t	file:
state_	db/c.cc	/^  void* state_;$/;"	m	struct:leveldb_comparator_t	file:
state_	db/c.cc	/^  void* state_;$/;"	m	struct:leveldb_filterpolicy_t	file:
~leveldb_comparator_t	db/c.cc	/^  virtual ~leveldb_comparator_t() {$/;"	f	struct:leveldb_comparator_t
~leveldb_filterpolicy_t	db/c.cc	/^  virtual ~leveldb_filterpolicy_t() {$/;"	f	struct:leveldb_filterpolicy_t
CheckCondition	db/c_test.c	35;"	d	file:
CheckDel	db/c_test.c	/^static void CheckDel(void* ptr, const char* k, size_t klen) {$/;"	f	file:
CheckEqual	db/c_test.c	/^static void CheckEqual(const char* expected, const char* v, size_t n) {$/;"	f	file:
CheckGet	db/c_test.c	/^static void CheckGet($/;"	f	file:
CheckIter	db/c_test.c	/^static void CheckIter(leveldb_iterator_t* iter,$/;"	f	file:
CheckNoError	db/c_test.c	29;"	d	file:
CheckPut	db/c_test.c	/^static void CheckPut(void* ptr,$/;"	f	file:
CmpCompare	db/c_test.c	/^static int CmpCompare(void* arg, const char* a, size_t alen,$/;"	f	file:
CmpDestroy	db/c_test.c	/^static void CmpDestroy(void* arg) { }$/;"	f	file:
CmpName	db/c_test.c	/^static const char* CmpName(void* arg) {$/;"	f	file:
FilterCreate	db/c_test.c	/^static char* FilterCreate($/;"	f	file:
FilterDestroy	db/c_test.c	/^static void FilterDestroy(void* arg) { }$/;"	f	file:
FilterKeyMatch	db/c_test.c	/^unsigned char FilterKeyMatch($/;"	f
FilterName	db/c_test.c	/^static const char* FilterName(void* arg) {$/;"	f	file:
Free	db/c_test.c	/^static void Free(char** ptr) {$/;"	f	file:
GetTempDir	db/c_test.c	/^static const char* GetTempDir(void) {$/;"	f	file:
StartPhase	db/c_test.c	/^static void StartPhase(const char* name) {$/;"	f	file:
dbname	db/c_test.c	/^static char dbname[200];$/;"	v	file:
fake_filter_result	db/c_test.c	/^static unsigned char fake_filter_result = 1;$/;"	v	file:
main	db/c_test.c	/^int main(int argc, char** argv) {$/;"	f
phase	db/c_test.c	/^const char* phase = "";$/;"	v
Build	db/corruption_test.cc	/^  void Build(int n) {$/;"	f	class:leveldb::CorruptionTest
Check	db/corruption_test.cc	/^  void Check(int min_expected, int max_expected) {$/;"	f	class:leveldb::CorruptionTest
Corrupt	db/corruption_test.cc	/^  void Corrupt(FileType filetype, int offset, int bytes_to_corrupt) {$/;"	f	class:leveldb::CorruptionTest
CorruptionTest	db/corruption_test.cc	/^  CorruptionTest() {$/;"	f	class:leveldb::CorruptionTest
CorruptionTest	db/corruption_test.cc	/^class CorruptionTest {$/;"	c	namespace:leveldb	file:
Key	db/corruption_test.cc	/^  Slice Key(int i, std::string* storage) {$/;"	f	class:leveldb::CorruptionTest
Property	db/corruption_test.cc	/^  int Property(const std::string& name) {$/;"	f	class:leveldb::CorruptionTest
Reopen	db/corruption_test.cc	/^  void Reopen() {$/;"	f	class:leveldb::CorruptionTest
RepairDB	db/corruption_test.cc	/^  void RepairDB() {$/;"	f	class:leveldb::CorruptionTest
TEST	db/corruption_test.cc	/^TEST(CorruptionTest, CompactionInputError) {$/;"	f	namespace:leveldb
TEST	db/corruption_test.cc	/^TEST(CorruptionTest, CompactionInputErrorParanoid) {$/;"	f	namespace:leveldb
TEST	db/corruption_test.cc	/^TEST(CorruptionTest, CorruptedDescriptor) {$/;"	f	namespace:leveldb
TEST	db/corruption_test.cc	/^TEST(CorruptionTest, MissingDescriptor) {$/;"	f	namespace:leveldb
TEST	db/corruption_test.cc	/^TEST(CorruptionTest, NewFileErrorDuringWrite) {$/;"	f	namespace:leveldb
TEST	db/corruption_test.cc	/^TEST(CorruptionTest, RecoverWriteError) {$/;"	f	namespace:leveldb
TEST	db/corruption_test.cc	/^TEST(CorruptionTest, Recovery) {$/;"	f	namespace:leveldb
TEST	db/corruption_test.cc	/^TEST(CorruptionTest, SequenceNumberRecovery) {$/;"	f	namespace:leveldb
TEST	db/corruption_test.cc	/^TEST(CorruptionTest, TableFile) {$/;"	f	namespace:leveldb
TEST	db/corruption_test.cc	/^TEST(CorruptionTest, TableFileIndexData) {$/;"	f	namespace:leveldb
TEST	db/corruption_test.cc	/^TEST(CorruptionTest, TableFileRepair) {$/;"	f	namespace:leveldb
TEST	db/corruption_test.cc	/^TEST(CorruptionTest, UnrelatedKeys) {$/;"	f	namespace:leveldb
TryReopen	db/corruption_test.cc	/^  Status TryReopen() {$/;"	f	class:leveldb::CorruptionTest
Value	db/corruption_test.cc	/^  Slice Value(int k, std::string* storage) {$/;"	f	class:leveldb::CorruptionTest
db_	db/corruption_test.cc	/^  DB* db_;$/;"	m	class:leveldb::CorruptionTest	file:
dbname_	db/corruption_test.cc	/^  std::string dbname_;$/;"	m	class:leveldb::CorruptionTest	file:
env_	db/corruption_test.cc	/^  test::ErrorEnv env_;$/;"	m	class:leveldb::CorruptionTest	file:
kValueSize	db/corruption_test.cc	/^static const int kValueSize = 1000;$/;"	m	namespace:leveldb	file:
leveldb	db/corruption_test.cc	/^namespace leveldb {$/;"	n	file:
main	db/corruption_test.cc	/^int main(int argc, char** argv) {$/;"	f
options_	db/corruption_test.cc	/^  Options options_;$/;"	m	class:leveldb::CorruptionTest	file:
tiny_cache_	db/corruption_test.cc	/^  Cache* tiny_cache_;$/;"	m	class:leveldb::CorruptionTest	file:
~CorruptionTest	db/corruption_test.cc	/^  ~CorruptionTest() {$/;"	f	class:leveldb::CorruptionTest
AcquireLoad	db/db_bench.cc	/^  void AcquireLoad(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
AddBytes	db/db_bench.cc	/^  void AddBytes(int64_t n) {$/;"	f	class:leveldb::__anon9::Stats
AddMessage	db/db_bench.cc	/^  void AddMessage(Slice msg) {$/;"	f	class:leveldb::__anon9::Stats
AppendWithSpace	db/db_bench.cc	/^static void AppendWithSpace(std::string* str, Slice msg) {$/;"	f	namespace:leveldb::__anon9
Benchmark	db/db_bench.cc	/^  Benchmark()$/;"	f	class:leveldb::Benchmark
Benchmark	db/db_bench.cc	/^class Benchmark {$/;"	c	namespace:leveldb	file:
Compact	db/db_bench.cc	/^  void Compact(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
Crc32c	db/db_bench.cc	/^  void Crc32c(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
DeleteRandom	db/db_bench.cc	/^  void DeleteRandom(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
DeleteSeq	db/db_bench.cc	/^  void DeleteSeq(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
DoDelete	db/db_bench.cc	/^  void DoDelete(ThreadState* thread, bool seq) {$/;"	f	class:leveldb::Benchmark	file:
DoWrite	db/db_bench.cc	/^  void DoWrite(ThreadState* thread, bool seq) {$/;"	f	class:leveldb::Benchmark	file:
FLAGS_benchmarks	db/db_bench.cc	/^static const char* FLAGS_benchmarks =$/;"	v	file:
FLAGS_block_size	db/db_bench.cc	/^static int FLAGS_block_size = 0;$/;"	v	file:
FLAGS_bloom_bits	db/db_bench.cc	/^static int FLAGS_bloom_bits = -1;$/;"	v	file:
FLAGS_cache_size	db/db_bench.cc	/^static int FLAGS_cache_size = -1;$/;"	v	file:
FLAGS_compression_ratio	db/db_bench.cc	/^static double FLAGS_compression_ratio = 0.5;$/;"	v	file:
FLAGS_db	db/db_bench.cc	/^static const char* FLAGS_db = NULL;$/;"	v	file:
FLAGS_histogram	db/db_bench.cc	/^static bool FLAGS_histogram = false;$/;"	v	file:
FLAGS_max_file_size	db/db_bench.cc	/^static int FLAGS_max_file_size = 0;$/;"	v	file:
FLAGS_num	db/db_bench.cc	/^static int FLAGS_num = 1000000;$/;"	v	file:
FLAGS_open_files	db/db_bench.cc	/^static int FLAGS_open_files = 0;$/;"	v	file:
FLAGS_reads	db/db_bench.cc	/^static int FLAGS_reads = -1;$/;"	v	file:
FLAGS_reuse_logs	db/db_bench.cc	/^static bool FLAGS_reuse_logs = false;$/;"	v	file:
FLAGS_threads	db/db_bench.cc	/^static int FLAGS_threads = 1;$/;"	v	file:
FLAGS_use_existing_db	db/db_bench.cc	/^static bool FLAGS_use_existing_db = false;$/;"	v	file:
FLAGS_value_size	db/db_bench.cc	/^static int FLAGS_value_size = 100;$/;"	v	file:
FLAGS_write_buffer_size	db/db_bench.cc	/^static int FLAGS_write_buffer_size = 0;$/;"	v	file:
FinishedSingleOp	db/db_bench.cc	/^  void FinishedSingleOp() {$/;"	f	class:leveldb::__anon9::Stats
Generate	db/db_bench.cc	/^  Slice Generate(size_t len) {$/;"	f	class:leveldb::__anon9::RandomGenerator
HeapProfile	db/db_bench.cc	/^  void HeapProfile() {$/;"	f	class:leveldb::Benchmark	file:
Merge	db/db_bench.cc	/^  void Merge(const Stats& other) {$/;"	f	class:leveldb::__anon9::Stats
Open	db/db_bench.cc	/^  void Open() {$/;"	f	class:leveldb::Benchmark	file:
OpenBench	db/db_bench.cc	/^  void OpenBench(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
PrintEnvironment	db/db_bench.cc	/^  void PrintEnvironment() {$/;"	f	class:leveldb::Benchmark	file:
PrintHeader	db/db_bench.cc	/^  void PrintHeader() {$/;"	f	class:leveldb::Benchmark	file:
PrintStats	db/db_bench.cc	/^  void PrintStats(const char* key) {$/;"	f	class:leveldb::Benchmark	file:
PrintWarnings	db/db_bench.cc	/^  void PrintWarnings() {$/;"	f	class:leveldb::Benchmark	file:
RandomGenerator	db/db_bench.cc	/^  RandomGenerator() {$/;"	f	class:leveldb::__anon9::RandomGenerator
RandomGenerator	db/db_bench.cc	/^class RandomGenerator {$/;"	c	namespace:leveldb::__anon9	file:
ReadHot	db/db_bench.cc	/^  void ReadHot(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
ReadMissing	db/db_bench.cc	/^  void ReadMissing(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
ReadRandom	db/db_bench.cc	/^  void ReadRandom(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
ReadReverse	db/db_bench.cc	/^  void ReadReverse(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
ReadSequential	db/db_bench.cc	/^  void ReadSequential(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
ReadWhileWriting	db/db_bench.cc	/^  void ReadWhileWriting(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
Report	db/db_bench.cc	/^  void Report(const Slice& name) {$/;"	f	class:leveldb::__anon9::Stats
Run	db/db_bench.cc	/^  void Run() {$/;"	f	class:leveldb::Benchmark
RunBenchmark	db/db_bench.cc	/^  void RunBenchmark(int n, Slice name,$/;"	f	class:leveldb::Benchmark	file:
SeekRandom	db/db_bench.cc	/^  void SeekRandom(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
SharedState	db/db_bench.cc	/^  SharedState() : cv(&mu) { }$/;"	f	struct:leveldb::__anon9::SharedState
SharedState	db/db_bench.cc	/^struct SharedState {$/;"	s	namespace:leveldb::__anon9	file:
SnappyCompress	db/db_bench.cc	/^  void SnappyCompress(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
SnappyUncompress	db/db_bench.cc	/^  void SnappyUncompress(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
Start	db/db_bench.cc	/^  void Start() {$/;"	f	class:leveldb::__anon9::Stats
Stats	db/db_bench.cc	/^  Stats() { Start(); }$/;"	f	class:leveldb::__anon9::Stats
Stats	db/db_bench.cc	/^class Stats {$/;"	c	namespace:leveldb::__anon9	file:
Stop	db/db_bench.cc	/^  void Stop() {$/;"	f	class:leveldb::__anon9::Stats
ThreadArg	db/db_bench.cc	/^  struct ThreadArg {$/;"	s	class:leveldb::Benchmark	file:
ThreadBody	db/db_bench.cc	/^  static void ThreadBody(void* v) {$/;"	f	class:leveldb::Benchmark	file:
ThreadState	db/db_bench.cc	/^  ThreadState(int index)$/;"	f	struct:leveldb::__anon9::ThreadState
ThreadState	db/db_bench.cc	/^struct ThreadState {$/;"	s	namespace:leveldb::__anon9	file:
TrimSpace	db/db_bench.cc	/^static Slice TrimSpace(Slice s) {$/;"	f	namespace:leveldb::__anon9
WriteRandom	db/db_bench.cc	/^  void WriteRandom(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
WriteSeq	db/db_bench.cc	/^  void WriteSeq(ThreadState* thread) {$/;"	f	class:leveldb::Benchmark	file:
WriteToFile	db/db_bench.cc	/^  static void WriteToFile(void* arg, const char* buf, int n) {$/;"	f	class:leveldb::Benchmark	file:
bits_per_key_per_filters	db/db_bench.cc	/^int bits_per_key_per_filters[]={4,4,4,0};$/;"	m	namespace:leveldb	file:
bm	db/db_bench.cc	/^    Benchmark* bm;$/;"	m	struct:leveldb::Benchmark::ThreadArg	file:
bytes_	db/db_bench.cc	/^  int64_t bytes_;$/;"	m	class:leveldb::__anon9::Stats	file:
cache_	db/db_bench.cc	/^  Cache* cache_;$/;"	m	class:leveldb::Benchmark	file:
cv	db/db_bench.cc	/^  port::CondVar cv;$/;"	m	struct:leveldb::__anon9::SharedState	file:
data_	db/db_bench.cc	/^  std::string data_;$/;"	m	class:leveldb::__anon9::RandomGenerator	file:
db_	db/db_bench.cc	/^  DB* db_;$/;"	m	class:leveldb::Benchmark	file:
done_	db/db_bench.cc	/^  int done_;$/;"	m	class:leveldb::__anon9::Stats	file:
entries_per_batch_	db/db_bench.cc	/^  int entries_per_batch_;$/;"	m	class:leveldb::Benchmark	file:
filter_policy_	db/db_bench.cc	/^  const FilterPolicy* filter_policy_;$/;"	m	class:leveldb::Benchmark	file:
finish_	db/db_bench.cc	/^  double finish_;$/;"	m	class:leveldb::__anon9::Stats	file:
g_env	db/db_bench.cc	/^leveldb::Env* g_env = NULL;$/;"	m	namespace:leveldb::__anon9	file:
heap_counter_	db/db_bench.cc	/^  int heap_counter_;$/;"	m	class:leveldb::Benchmark	file:
hist_	db/db_bench.cc	/^  Histogram hist_;$/;"	m	class:leveldb::__anon9::Stats	file:
last_op_finish_	db/db_bench.cc	/^  double last_op_finish_;$/;"	m	class:leveldb::__anon9::Stats	file:
leveldb	db/db_bench.cc	/^namespace leveldb {$/;"	n	file:
main	db/db_bench.cc	/^int main(int argc, char** argv) {$/;"	f
message_	db/db_bench.cc	/^  std::string message_;$/;"	m	class:leveldb::__anon9::Stats	file:
method	db/db_bench.cc	/^    void (Benchmark::*method)(ThreadState*);$/;"	m	struct:leveldb::Benchmark::ThreadArg	file:
mu	db/db_bench.cc	/^  port::Mutex mu;$/;"	m	struct:leveldb::__anon9::SharedState	file:
next_report_	db/db_bench.cc	/^  int next_report_;$/;"	m	class:leveldb::__anon9::Stats	file:
num_	db/db_bench.cc	/^  int num_;$/;"	m	class:leveldb::Benchmark	file:
num_done	db/db_bench.cc	/^  int num_done;$/;"	m	struct:leveldb::__anon9::SharedState	file:
num_initialized	db/db_bench.cc	/^  int num_initialized;$/;"	m	struct:leveldb::__anon9::SharedState	file:
pos_	db/db_bench.cc	/^  int pos_;$/;"	m	class:leveldb::__anon9::RandomGenerator	file:
rand	db/db_bench.cc	/^  Random rand;         \/\/ Has different seeds for different threads$/;"	m	struct:leveldb::__anon9::ThreadState	file:
reads_	db/db_bench.cc	/^  int reads_;$/;"	m	class:leveldb::Benchmark	file:
seconds_	db/db_bench.cc	/^  double seconds_;$/;"	m	class:leveldb::__anon9::Stats	file:
shared	db/db_bench.cc	/^    SharedState* shared;$/;"	m	struct:leveldb::Benchmark::ThreadArg	file:
shared	db/db_bench.cc	/^  SharedState* shared;$/;"	m	struct:leveldb::__anon9::ThreadState	file:
start	db/db_bench.cc	/^  bool start;$/;"	m	struct:leveldb::__anon9::SharedState	file:
start_	db/db_bench.cc	/^  double start_;$/;"	m	class:leveldb::__anon9::Stats	file:
stats	db/db_bench.cc	/^  Stats stats;$/;"	m	struct:leveldb::__anon9::ThreadState	file:
thread	db/db_bench.cc	/^    ThreadState* thread;$/;"	m	struct:leveldb::Benchmark::ThreadArg	file:
tid	db/db_bench.cc	/^  int tid;             \/\/ 0..n-1 when running in n threads$/;"	m	struct:leveldb::__anon9::ThreadState	file:
total	db/db_bench.cc	/^  int total;$/;"	m	struct:leveldb::__anon9::SharedState	file:
value_size_	db/db_bench.cc	/^  int value_size_;$/;"	m	class:leveldb::Benchmark	file:
write_options_	db/db_bench.cc	/^  WriteOptions write_options_;$/;"	m	class:leveldb::Benchmark	file:
~Benchmark	db/db_bench.cc	/^  ~Benchmark() {$/;"	f	class:leveldb::Benchmark
BGWork	db/db_impl.cc	/^void DBImpl::BGWork(void* db) {$/;"	f	class:leveldb::DBImpl
BackgroundCall	db/db_impl.cc	/^void DBImpl::BackgroundCall() {$/;"	f	class:leveldb::DBImpl
BackgroundCompaction	db/db_impl.cc	/^void DBImpl::BackgroundCompaction() {$/;"	f	class:leveldb::DBImpl
BuildBatchGroup	db/db_impl.cc	/^WriteBatch* DBImpl::BuildBatchGroup(Writer** last_writer) {$/;"	f	class:leveldb::DBImpl
CleanupCompaction	db/db_impl.cc	/^void DBImpl::CleanupCompaction(CompactionState* compact) {$/;"	f	class:leveldb::DBImpl
CleanupIteratorState	db/db_impl.cc	/^static void CleanupIteratorState(void* arg1, void* arg2) {$/;"	f	namespace:leveldb::__anon10
ClipToRange	db/db_impl.cc	/^static void ClipToRange(T* ptr, V minvalue, V maxvalue) {$/;"	f	namespace:leveldb
CompactMemTable	db/db_impl.cc	/^void DBImpl::CompactMemTable() {$/;"	f	class:leveldb::DBImpl
CompactRange	db/db_impl.cc	/^void DBImpl::CompactRange(const Slice* begin, const Slice* end) {$/;"	f	class:leveldb::DBImpl
CompactionState	db/db_impl.cc	/^  explicit CompactionState(Compaction* c)$/;"	f	struct:leveldb::DBImpl::CompactionState
CompactionState	db/db_impl.cc	/^struct DBImpl::CompactionState {$/;"	s	class:leveldb::DBImpl	file:
DBImpl	db/db_impl.cc	/^DBImpl::DBImpl(const Options& raw_options, const std::string& dbname)$/;"	f	class:leveldb::DBImpl
Delete	db/db_impl.cc	/^Status DB::Delete(const WriteOptions& opt, const Slice& key) {$/;"	f	class:leveldb::DB
Delete	db/db_impl.cc	/^Status DBImpl::Delete(const WriteOptions& options, const Slice& key) {$/;"	f	class:leveldb::DBImpl
DeleteObsoleteFiles	db/db_impl.cc	/^void DBImpl::DeleteObsoleteFiles() {$/;"	f	class:leveldb::DBImpl
DestroyDB	db/db_impl.cc	/^Status DestroyDB(const std::string& dbname, const Options& options) {$/;"	f	namespace:leveldb
DoCompactionWork	db/db_impl.cc	/^Status DBImpl::DoCompactionWork(CompactionState* compact) {$/;"	f	class:leveldb::DBImpl
DoSomeThing	db/db_impl.cc	/^void DBImpl::DoSomeThing(void* arg)$/;"	f	class:leveldb::DBImpl
FinishCompactionOutputFile	db/db_impl.cc	/^Status DBImpl::FinishCompactionOutputFile(CompactionState* compact,$/;"	f	class:leveldb::DBImpl
Get	db/db_impl.cc	/^Status DBImpl::Get(const ReadOptions& options,$/;"	f	class:leveldb::DBImpl
GetApproximateSizes	db/db_impl.cc	/^void DBImpl::GetApproximateSizes($/;"	f	class:leveldb::DBImpl
GetProperty	db/db_impl.cc	/^bool DBImpl::GetProperty(const Slice& property, std::string* value) {$/;"	f	class:leveldb::DBImpl
GetSnapshot	db/db_impl.cc	/^const Snapshot* DBImpl::GetSnapshot() {$/;"	f	class:leveldb::DBImpl
InstallCompactionResults	db/db_impl.cc	/^Status DBImpl::InstallCompactionResults(CompactionState* compact) {$/;"	f	class:leveldb::DBImpl
IterState	db/db_impl.cc	/^struct IterState {$/;"	s	namespace:leveldb::__anon10	file:
KeepFreCount	db/db_impl.cc	/^void DBImpl::KeepFreCount(CompactionState *compact){$/;"	f	class:leveldb::DBImpl
MakeRoomForWrite	db/db_impl.cc	/^Status DBImpl::MakeRoomForWrite(bool force) {$/;"	f	class:leveldb::DBImpl
MaybeIgnoreError	db/db_impl.cc	/^void DBImpl::MaybeIgnoreError(Status* s) const {$/;"	f	class:leveldb::DBImpl
MaybeScheduleCompaction	db/db_impl.cc	/^void DBImpl::MaybeScheduleCompaction() {$/;"	f	class:leveldb::DBImpl
NewDB	db/db_impl.cc	/^Status DBImpl::NewDB() {$/;"	f	class:leveldb::DBImpl
NewInternalIterator	db/db_impl.cc	/^Iterator* DBImpl::NewInternalIterator(const ReadOptions& options,$/;"	f	class:leveldb::DBImpl
NewIterator	db/db_impl.cc	/^Iterator* DBImpl::NewIterator(const ReadOptions& options) {$/;"	f	class:leveldb::DBImpl
Open	db/db_impl.cc	/^Status DB::Open(const Options& options, const std::string& dbname,$/;"	f	class:leveldb::DB
OpenCompactionOutputFile	db/db_impl.cc	/^Status DBImpl::OpenCompactionOutputFile(CompactionState* compact) {$/;"	f	class:leveldb::DBImpl
Output	db/db_impl.cc	/^  struct Output {$/;"	s	struct:leveldb::DBImpl::CompactionState	file:
Put	db/db_impl.cc	/^Status DB::Put(const WriteOptions& opt, const Slice& key, const Slice& value) {$/;"	f	class:leveldb::DB
Put	db/db_impl.cc	/^Status DBImpl::Put(const WriteOptions& o, const Slice& key, const Slice& val) {$/;"	f	class:leveldb::DBImpl
RecordBackgroundError	db/db_impl.cc	/^void DBImpl::RecordBackgroundError(const Status& s) {$/;"	f	class:leveldb::DBImpl
RecordReadSample	db/db_impl.cc	/^void DBImpl::RecordReadSample(Slice key) {$/;"	f	class:leveldb::DBImpl
Recover	db/db_impl.cc	/^Status DBImpl::Recover(VersionEdit* edit, bool *save_manifest) {$/;"	f	class:leveldb::DBImpl
RecoverLogFile	db/db_impl.cc	/^Status DBImpl::RecoverLogFile(uint64_t log_number, bool last_log,$/;"	f	class:leveldb::DBImpl
ReleaseSnapshot	db/db_impl.cc	/^void DBImpl::ReleaseSnapshot(const Snapshot* s) {$/;"	f	class:leveldb::DBImpl
SanitizeOptions	db/db_impl.cc	/^Options SanitizeOptions(const std::string& dbname,$/;"	f	namespace:leveldb
TEST_CompactMemTable	db/db_impl.cc	/^Status DBImpl::TEST_CompactMemTable() {$/;"	f	class:leveldb::DBImpl
TEST_CompactRange	db/db_impl.cc	/^void DBImpl::TEST_CompactRange(int level, const Slice* begin,const Slice* end) {$/;"	f	class:leveldb::DBImpl
TEST_MaxNextLevelOverlappingBytes	db/db_impl.cc	/^int64_t DBImpl::TEST_MaxNextLevelOverlappingBytes() {$/;"	f	class:leveldb::DBImpl
TEST_NewInternalIterator	db/db_impl.cc	/^Iterator* DBImpl::TEST_NewInternalIterator() {$/;"	f	class:leveldb::DBImpl
Write	db/db_impl.cc	/^Status DBImpl::Write(const WriteOptions& options, WriteBatch* my_batch) {$/;"	f	class:leveldb::DBImpl
WriteLevel0Table	db/db_impl.cc	/^Status DBImpl::WriteLevel0Table(MemTable* mem, VersionEdit* edit,$/;"	f	class:leveldb::DBImpl
Writer	db/db_impl.cc	/^  explicit Writer(port::Mutex* mu) : cv(mu) { }$/;"	f	struct:leveldb::DBImpl::Writer
Writer	db/db_impl.cc	/^struct DBImpl::Writer {$/;"	s	class:leveldb::DBImpl	file:
adjustFilter	db/db_impl.cc	/^void DBImpl::adjustFilter()$/;"	f	class:leveldb::DBImpl
batch	db/db_impl.cc	/^  WriteBatch* batch;$/;"	m	struct:leveldb::DBImpl::Writer	file:
builder	db/db_impl.cc	/^  TableBuilder* builder;$/;"	m	struct:leveldb::DBImpl::CompactionState	file:
compaction	db/db_impl.cc	/^  Compaction* const compaction;$/;"	m	struct:leveldb::DBImpl::CompactionState	file:
current_output	db/db_impl.cc	/^  Output* current_output() { return &outputs[outputs.size()-1]; }$/;"	f	struct:leveldb::DBImpl::CompactionState
cv	db/db_impl.cc	/^  port::CondVar cv;$/;"	m	struct:leveldb::DBImpl::Writer	file:
done	db/db_impl.cc	/^  bool done;$/;"	m	struct:leveldb::DBImpl::Writer	file:
file_size	db/db_impl.cc	/^    uint64_t file_size;$/;"	m	struct:leveldb::DBImpl::CompactionState::Output	file:
filter_mem_space	db/db_impl.cc	/^unsigned long long filter_mem_space = 0;$/;"	v
filter_num	db/db_impl.cc	/^unsigned long long filter_num = 0;$/;"	v
imm	db/db_impl.cc	/^  MemTable* imm;$/;"	m	struct:leveldb::__anon10::IterState	file:
kNumNonTableCacheFiles	db/db_impl.cc	/^const int kNumNonTableCacheFiles = 10;$/;"	m	namespace:leveldb	file:
largest	db/db_impl.cc	/^    InternalKey smallest, largest;$/;"	m	struct:leveldb::DBImpl::CompactionState::Output	file:
leveldb	db/db_impl.cc	/^namespace leveldb {$/;"	n	file:
mem	db/db_impl.cc	/^  MemTable* mem;$/;"	m	struct:leveldb::__anon10::IterState	file:
mu	db/db_impl.cc	/^  port::Mutex* mu;$/;"	m	struct:leveldb::__anon10::IterState	file:
number	db/db_impl.cc	/^    uint64_t number;$/;"	m	struct:leveldb::DBImpl::CompactionState::Output	file:
outfile	db/db_impl.cc	/^  WritableFile* outfile;$/;"	m	struct:leveldb::DBImpl::CompactionState	file:
outputs	db/db_impl.cc	/^  std::vector<Output> outputs;$/;"	m	struct:leveldb::DBImpl::CompactionState	file:
printStatistics	db/db_impl.cc	/^std::string DBImpl::printStatistics()$/;"	f	class:leveldb::DBImpl
smallest	db/db_impl.cc	/^    InternalKey smallest, largest;$/;"	m	struct:leveldb::DBImpl::CompactionState::Output	file:
smallest_snapshot	db/db_impl.cc	/^  SequenceNumber smallest_snapshot;$/;"	m	struct:leveldb::DBImpl::CompactionState	file:
status	db/db_impl.cc	/^  Status status;$/;"	m	struct:leveldb::DBImpl::Writer	file:
sync	db/db_impl.cc	/^  bool sync;$/;"	m	struct:leveldb::DBImpl::Writer	file:
total_bytes	db/db_impl.cc	/^  uint64_t total_bytes;$/;"	m	struct:leveldb::DBImpl::CompactionState	file:
untilCompactionEnds	db/db_impl.cc	/^void DBImpl::untilCompactionEnds()$/;"	f	class:leveldb::DBImpl
version	db/db_impl.cc	/^  Version* version;$/;"	m	struct:leveldb::__anon10::IterState	file:
~DB	db/db_impl.cc	/^DB::~DB() { }$/;"	f	class:leveldb::DB
~DBImpl	db/db_impl.cc	/^DBImpl::~DBImpl() {$/;"	f	class:leveldb::DBImpl
~Snapshot	db/db_impl.cc	/^Snapshot::~Snapshot() {$/;"	f	class:leveldb::Snapshot
Add	db/db_impl.h	/^    void Add(const CompactionStats& c) {$/;"	f	struct:leveldb::DBImpl::CompactionStats
CompactionStats	db/db_impl.h	/^    CompactionStats() : micros(0), bytes_read(0), bytes_written(0) { }$/;"	f	struct:leveldb::DBImpl::CompactionStats
CompactionStats	db/db_impl.h	/^  struct CompactionStats {$/;"	s	class:leveldb::DBImpl
DBImpl	db/db_impl.h	/^class DBImpl : public DB {$/;"	c	namespace:leveldb
ManualCompaction	db/db_impl.h	/^  struct ManualCompaction {$/;"	s	class:leveldb::DBImpl
STORAGE_LEVELDB_DB_DB_IMPL_H_	db/db_impl.h	6;"	d
begin	db/db_impl.h	/^    const InternalKey* begin;   \/\/ NULL means beginning of key range$/;"	m	struct:leveldb::DBImpl::ManualCompaction
bg_compaction_scheduled_	db/db_impl.h	/^  bool bg_compaction_scheduled_;$/;"	m	class:leveldb::DBImpl
bg_cv_	db/db_impl.h	/^  port::CondVar bg_cv_;          \/\/ Signalled when background work finishes$/;"	m	class:leveldb::DBImpl
bg_error_	db/db_impl.h	/^  Status bg_error_;$/;"	m	class:leveldb::DBImpl
bytes_read	db/db_impl.h	/^    int64_t bytes_read;$/;"	m	struct:leveldb::DBImpl::CompactionStats
bytes_written	db/db_impl.h	/^    int64_t bytes_written;$/;"	m	struct:leveldb::DBImpl::CompactionStats
db_lock_	db/db_impl.h	/^  FileLock* db_lock_;$/;"	m	class:leveldb::DBImpl
dbname_	db/db_impl.h	/^  const std::string dbname_;$/;"	m	class:leveldb::DBImpl
done	db/db_impl.h	/^    bool done;$/;"	m	struct:leveldb::DBImpl::ManualCompaction
end	db/db_impl.h	/^    const InternalKey* end;     \/\/ NULL means end of key range$/;"	m	struct:leveldb::DBImpl::ManualCompaction
env_	db/db_impl.h	/^  Env* const env_;$/;"	m	class:leveldb::DBImpl
fp_access_file_str	db/db_impl.h	/^  std::string fp_access_file_str;$/;"	m	class:leveldb::DBImpl
fp_calc_fpr_str	db/db_impl.h	/^  std::string fp_calc_fpr_str;$/;"	m	class:leveldb::DBImpl
fp_io	db/db_impl.h	/^  int64_t fp_reqs, fp_io, fp_nums, read_nums;$/;"	m	class:leveldb::DBImpl
fp_nums	db/db_impl.h	/^  int64_t fp_reqs, fp_io, fp_nums, read_nums;$/;"	m	class:leveldb::DBImpl
fp_real_fpr_str	db/db_impl.h	/^  std::string fp_real_fpr_str;$/;"	m	class:leveldb::DBImpl
fp_real_io_str	db/db_impl.h	/^  std::string fp_real_io_str;$/;"	m	class:leveldb::DBImpl
fp_reqs	db/db_impl.h	/^  int64_t fp_reqs, fp_io, fp_nums, read_nums;$/;"	m	class:leveldb::DBImpl
fp_sum	db/db_impl.h	/^  double fp_sum, last_fp;$/;"	m	class:leveldb::DBImpl
get_latency_str	db/db_impl.h	/^  std::string get_latency_str[config::kNumLevels];$/;"	m	class:leveldb::DBImpl
has_imm_	db/db_impl.h	/^  port::AtomicPointer has_imm_;  \/\/ So bg thread can detect non-NULL imm_$/;"	m	class:leveldb::DBImpl
imm_	db/db_impl.h	/^  MemTable* imm_;                \/\/ Memtable being compacted$/;"	m	class:leveldb::DBImpl
internal_comparator_	db/db_impl.h	/^  const InternalKeyComparator internal_comparator_;$/;"	m	class:leveldb::DBImpl
internal_filter_policy_	db/db_impl.h	/^  const InternalFilterPolicy internal_filter_policy_;$/;"	m	class:leveldb::DBImpl
last_fp	db/db_impl.h	/^  double fp_sum, last_fp;$/;"	m	class:leveldb::DBImpl
level	db/db_impl.h	/^    int level;$/;"	m	struct:leveldb::DBImpl::ManualCompaction
leveldb	db/db_impl.h	/^namespace leveldb {$/;"	n
log_	db/db_impl.h	/^  log::Writer* log_;$/;"	m	class:leveldb::DBImpl
logfile_	db/db_impl.h	/^  WritableFile* logfile_;$/;"	m	class:leveldb::DBImpl
logfile_number_	db/db_impl.h	/^  uint64_t logfile_number_;$/;"	m	class:leveldb::DBImpl
manual_compaction_	db/db_impl.h	/^  ManualCompaction* manual_compaction_;$/;"	m	class:leveldb::DBImpl
mem_	db/db_impl.h	/^  MemTable* mem_;$/;"	m	class:leveldb::DBImpl
micros	db/db_impl.h	/^    int64_t micros;$/;"	m	struct:leveldb::DBImpl::CompactionStats
mutex_	db/db_impl.h	/^  port::Mutex mutex_;$/;"	m	class:leveldb::DBImpl
options_	db/db_impl.h	/^  const Options options_;  \/\/ options_.comparator == &internal_comparator_$/;"	m	class:leveldb::DBImpl
owns_cache_	db/db_impl.h	/^  bool owns_cache_;$/;"	m	class:leveldb::DBImpl
owns_info_log_	db/db_impl.h	/^  bool owns_info_log_;$/;"	m	class:leveldb::DBImpl
pending_outputs_	db/db_impl.h	/^  std::set<uint64_t> pending_outputs_;$/;"	m	class:leveldb::DBImpl
read_nums	db/db_impl.h	/^  int64_t fp_reqs, fp_io, fp_nums, read_nums;$/;"	m	class:leveldb::DBImpl
seed_	db/db_impl.h	/^  uint32_t seed_;                \/\/ For sampling.$/;"	m	class:leveldb::DBImpl
shutting_down_	db/db_impl.h	/^  port::AtomicPointer shutting_down_;$/;"	m	class:leveldb::DBImpl
snapshots_	db/db_impl.h	/^  SnapshotList snapshots_;$/;"	m	class:leveldb::DBImpl
statis_	db/db_impl.h	/^  Statistics *statis_;$/;"	m	class:leveldb::DBImpl
stats_	db/db_impl.h	/^  CompactionStats stats_[config::kNumLevels];$/;"	m	class:leveldb::DBImpl
table_cache_	db/db_impl.h	/^  TableCache* table_cache_;$/;"	m	class:leveldb::DBImpl
tmp_batch_	db/db_impl.h	/^  WriteBatch* tmp_batch_;$/;"	m	class:leveldb::DBImpl
tmp_storage	db/db_impl.h	/^    InternalKey tmp_storage;    \/\/ Used to keep track of compaction progress$/;"	m	struct:leveldb::DBImpl::ManualCompaction
user_comparator	db/db_impl.h	/^  const Comparator* user_comparator() const {$/;"	f	class:leveldb::DBImpl
versions_	db/db_impl.h	/^  VersionSet* versions_;$/;"	m	class:leveldb::DBImpl
writers_	db/db_impl.h	/^  std::deque<Writer*> writers_;$/;"	m	class:leveldb::DBImpl
ClearSavedValue	db/db_iter.cc	/^  inline void ClearSavedValue() {$/;"	f	class:leveldb::__anon1::DBIter	file:
DBIter	db/db_iter.cc	/^  DBIter(DBImpl* db, const Comparator* cmp, Iterator* iter, SequenceNumber s,$/;"	f	class:leveldb::__anon1::DBIter
DBIter	db/db_iter.cc	/^class DBIter: public Iterator {$/;"	c	namespace:leveldb::__anon1	file:
Direction	db/db_iter.cc	/^  enum Direction {$/;"	g	class:leveldb::__anon1::DBIter	file:
FindNextUserEntry	db/db_iter.cc	/^void DBIter::FindNextUserEntry(bool skipping, std::string* skip) {$/;"	f	class:leveldb::__anon1::DBIter
FindPrevUserEntry	db/db_iter.cc	/^void DBIter::FindPrevUserEntry() {$/;"	f	class:leveldb::__anon1::DBIter
NewDBIterator	db/db_iter.cc	/^Iterator* NewDBIterator($/;"	f	namespace:leveldb
Next	db/db_iter.cc	/^void DBIter::Next() {$/;"	f	class:leveldb::__anon1::DBIter
ParseKey	db/db_iter.cc	/^inline bool DBIter::ParseKey(ParsedInternalKey* ikey) {$/;"	f	class:leveldb::__anon1::DBIter
Prev	db/db_iter.cc	/^void DBIter::Prev() {$/;"	f	class:leveldb::__anon1::DBIter
RandomPeriod	db/db_iter.cc	/^  ssize_t RandomPeriod() {$/;"	f	class:leveldb::__anon1::DBIter	file:
SaveKey	db/db_iter.cc	/^  inline void SaveKey(const Slice& k, std::string* dst) {$/;"	f	class:leveldb::__anon1::DBIter	file:
Seek	db/db_iter.cc	/^void DBIter::Seek(const Slice& target) {$/;"	f	class:leveldb::__anon1::DBIter
SeekToFirst	db/db_iter.cc	/^void DBIter::SeekToFirst() {$/;"	f	class:leveldb::__anon1::DBIter
SeekToLast	db/db_iter.cc	/^void DBIter::SeekToLast() {$/;"	f	class:leveldb::__anon1::DBIter
Valid	db/db_iter.cc	/^  virtual bool Valid() const { return valid_; }$/;"	f	class:leveldb::__anon1::DBIter
bytes_counter_	db/db_iter.cc	/^  ssize_t bytes_counter_;$/;"	m	class:leveldb::__anon1::DBIter	file:
db_	db/db_iter.cc	/^  DBImpl* db_;$/;"	m	class:leveldb::__anon1::DBIter	file:
direction_	db/db_iter.cc	/^  Direction direction_;$/;"	m	class:leveldb::__anon1::DBIter	file:
iter_	db/db_iter.cc	/^  Iterator* const iter_;$/;"	m	class:leveldb::__anon1::DBIter	file:
kForward	db/db_iter.cc	/^    kForward,$/;"	e	enum:leveldb::__anon1::DBIter::Direction	file:
kReverse	db/db_iter.cc	/^    kReverse$/;"	e	enum:leveldb::__anon1::DBIter::Direction	file:
key	db/db_iter.cc	/^  virtual Slice key() const {$/;"	f	class:leveldb::__anon1::DBIter
leveldb	db/db_iter.cc	/^namespace leveldb {$/;"	n	file:
rnd_	db/db_iter.cc	/^  Random rnd_;$/;"	m	class:leveldb::__anon1::DBIter	file:
saved_key_	db/db_iter.cc	/^  std::string saved_key_;     \/\/ == current key when direction_==kReverse$/;"	m	class:leveldb::__anon1::DBIter	file:
saved_value_	db/db_iter.cc	/^  std::string saved_value_;   \/\/ == current raw value when direction_==kReverse$/;"	m	class:leveldb::__anon1::DBIter	file:
sequence_	db/db_iter.cc	/^  SequenceNumber const sequence_;$/;"	m	class:leveldb::__anon1::DBIter	file:
status	db/db_iter.cc	/^  virtual Status status() const {$/;"	f	class:leveldb::__anon1::DBIter
status_	db/db_iter.cc	/^  Status status_;$/;"	m	class:leveldb::__anon1::DBIter	file:
user_comparator_	db/db_iter.cc	/^  const Comparator* const user_comparator_;$/;"	m	class:leveldb::__anon1::DBIter	file:
valid_	db/db_iter.cc	/^  bool valid_;$/;"	m	class:leveldb::__anon1::DBIter	file:
value	db/db_iter.cc	/^  virtual Slice value() const {$/;"	f	class:leveldb::__anon1::DBIter
~DBIter	db/db_iter.cc	/^  virtual ~DBIter() {$/;"	f	class:leveldb::__anon1::DBIter
STORAGE_LEVELDB_DB_DB_ITER_H_	db/db_iter.h	6;"	d
leveldb	db/db_iter.h	/^namespace leveldb {$/;"	n
AllEntriesFor	db/db_test.cc	/^  std::string AllEntriesFor(const Slice& user_key) {$/;"	f	class:leveldb::DBTest
AtomicCounter	db/db_test.cc	/^  AtomicCounter() : count_(0) { }$/;"	f	class:leveldb::__anon11::AtomicCounter
AtomicCounter	db/db_test.cc	/^class AtomicCounter {$/;"	c	namespace:leveldb::__anon11	file:
BM_LogAndApply	db/db_test.cc	/^void BM_LogAndApply(int iters, int num_base_files) {$/;"	f	namespace:leveldb
Between	db/db_test.cc	/^static bool Between(uint64_t val, uint64_t low, uint64_t high) {$/;"	f	namespace:leveldb
ChangeOptions	db/db_test.cc	/^  bool ChangeOptions() {$/;"	f	class:leveldb::DBTest
Close	db/db_test.cc	/^  void Close() {$/;"	f	class:leveldb::DBTest
Compact	db/db_test.cc	/^  void Compact(const Slice& start, const Slice& limit) {$/;"	f	class:leveldb::DBTest
CompactRange	db/db_test.cc	/^  virtual void CompactRange(const Slice* start, const Slice* end) {$/;"	f	class:leveldb::ModelDB
CompareIterators	db/db_test.cc	/^static bool CompareIterators(int step,$/;"	f	namespace:leveldb
Contents	db/db_test.cc	/^  std::string Contents() {$/;"	f	class:leveldb::DBTest
CountFiles	db/db_test.cc	/^  int CountFiles() {$/;"	f	class:leveldb::DBTest
CurrentOptions	db/db_test.cc	/^  Options CurrentOptions() {$/;"	f	class:leveldb::DBTest
DBTest	db/db_test.cc	/^  DBTest() : option_config_(kDefault),$/;"	f	class:leveldb::DBTest
DBTest	db/db_test.cc	/^class DBTest {$/;"	c	namespace:leveldb	file:
DelayMilliseconds	db/db_test.cc	/^void DelayMilliseconds(int millis) {$/;"	f	namespace:leveldb::__anon11
Delete	db/db_test.cc	/^  Status Delete(const std::string& k) {$/;"	f	class:leveldb::DBTest
Delete	db/db_test.cc	/^  virtual Status Delete(const WriteOptions& o, const Slice& key) {$/;"	f	class:leveldb::ModelDB
DeleteAnSSTFile	db/db_test.cc	/^  bool DeleteAnSSTFile() {$/;"	f	class:leveldb::DBTest
DestroyAndReopen	db/db_test.cc	/^  void DestroyAndReopen(Options* options = NULL) {$/;"	f	class:leveldb::DBTest
DumpFileCounts	db/db_test.cc	/^  void DumpFileCounts(const char* label) {$/;"	f	class:leveldb::DBTest
DumpSSTableList	db/db_test.cc	/^  std::string DumpSSTableList() {$/;"	f	class:leveldb::DBTest
FilesPerLevel	db/db_test.cc	/^  std::string FilesPerLevel() {$/;"	f	class:leveldb::DBTest
FillLevels	db/db_test.cc	/^  void FillLevels(const std::string& smallest, const std::string& largest) {$/;"	f	class:leveldb::DBTest
Get	db/db_test.cc	/^  std::string Get(const std::string& k, const Snapshot* snapshot = NULL) {$/;"	f	class:leveldb::DBTest
Get	db/db_test.cc	/^  virtual Status Get(const ReadOptions& options,$/;"	f	class:leveldb::ModelDB
GetApproximateSizes	db/db_test.cc	/^  virtual void GetApproximateSizes(const Range* r, int n, uint64_t* sizes) {$/;"	f	class:leveldb::ModelDB
GetProperty	db/db_test.cc	/^  virtual bool GetProperty(const Slice& property, std::string* value) {$/;"	f	class:leveldb::ModelDB
GetSnapshot	db/db_test.cc	/^  virtual const Snapshot* GetSnapshot() {$/;"	f	class:leveldb::ModelDB
Increment	db/db_test.cc	/^  void Increment() {$/;"	f	class:leveldb::__anon11::AtomicCounter
IncrementBy	db/db_test.cc	/^  void IncrementBy(int count) {$/;"	f	class:leveldb::__anon11::AtomicCounter
IterStatus	db/db_test.cc	/^  std::string IterStatus(Iterator* iter) {$/;"	f	class:leveldb::DBTest
KVMap	db/db_test.cc	/^typedef std::map<std::string, std::string> KVMap;$/;"	t	namespace:leveldb::__anon13	file:
Key	db/db_test.cc	/^static std::string Key(int i) {$/;"	f	namespace:leveldb
MTState	db/db_test.cc	/^struct MTState {$/;"	s	namespace:leveldb::__anon12	file:
MTThread	db/db_test.cc	/^struct MTThread {$/;"	s	namespace:leveldb::__anon12	file:
MTThreadBody	db/db_test.cc	/^static void MTThreadBody(void* arg) {$/;"	f	namespace:leveldb::__anon12
MakeKey	db/db_test.cc	/^std::string MakeKey(unsigned int num) {$/;"	f	namespace:leveldb
MakeTables	db/db_test.cc	/^  void MakeTables(int n, const std::string& small, const std::string& large) {$/;"	f	class:leveldb::DBTest
ModelDB	db/db_test.cc	/^  explicit ModelDB(const Options& options): options_(options) { }$/;"	f	class:leveldb::ModelDB
ModelDB	db/db_test.cc	/^class ModelDB: public DB {$/;"	c	namespace:leveldb	file:
ModelIter	db/db_test.cc	/^    ModelIter(const KVMap* map, bool owned)$/;"	f	class:leveldb::ModelDB::ModelIter
ModelIter	db/db_test.cc	/^  class ModelIter: public Iterator {$/;"	c	class:leveldb::ModelDB	file:
ModelSnapshot	db/db_test.cc	/^  class ModelSnapshot : public Snapshot {$/;"	c	class:leveldb::ModelDB	file:
NewIterator	db/db_test.cc	/^  virtual Iterator* NewIterator(const ReadOptions& options) {$/;"	f	class:leveldb::ModelDB
NewRandomAccessFile	db/db_test.cc	/^  Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r) {$/;"	f	class:leveldb::SpecialEnv
NewWritableFile	db/db_test.cc	/^  Status NewWritableFile(const std::string& f, WritableFile** r) {$/;"	f	class:leveldb::SpecialEnv
Next	db/db_test.cc	/^    virtual void Next() { ++iter_; }$/;"	f	class:leveldb::ModelDB::ModelIter
NumTableFilesAtLevel	db/db_test.cc	/^  int NumTableFilesAtLevel(int level) {$/;"	f	class:leveldb::DBTest
OptionConfig	db/db_test.cc	/^  enum OptionConfig {$/;"	g	class:leveldb::DBTest	file:
Prev	db/db_test.cc	/^    virtual void Prev() { --iter_; }$/;"	f	class:leveldb::ModelDB::ModelIter
Put	db/db_test.cc	/^  Status Put(const std::string& k, const std::string& v) {$/;"	f	class:leveldb::DBTest
Put	db/db_test.cc	/^  virtual Status Put(const WriteOptions& o, const Slice& k, const Slice& v) {$/;"	f	class:leveldb::ModelDB
RandomKey	db/db_test.cc	/^static std::string RandomKey(Random* rnd) {$/;"	f	namespace:leveldb
RandomString	db/db_test.cc	/^static std::string RandomString(Random* rnd, int len) {$/;"	f	namespace:leveldb
Read	db/db_test.cc	/^  int Read() {$/;"	f	class:leveldb::__anon11::AtomicCounter
ReleaseSnapshot	db/db_test.cc	/^  virtual void ReleaseSnapshot(const Snapshot* snapshot) {$/;"	f	class:leveldb::ModelDB
RenameLDBToSST	db/db_test.cc	/^  int RenameLDBToSST() {$/;"	f	class:leveldb::DBTest
Reopen	db/db_test.cc	/^  void Reopen(Options* options = NULL) {$/;"	f	class:leveldb::DBTest
Reset	db/db_test.cc	/^  void Reset() {$/;"	f	class:leveldb::__anon11::AtomicCounter
Seek	db/db_test.cc	/^    virtual void Seek(const Slice& k) {$/;"	f	class:leveldb::ModelDB::ModelIter
SeekToFirst	db/db_test.cc	/^    virtual void SeekToFirst() { iter_ = map_->begin(); }$/;"	f	class:leveldb::ModelDB::ModelIter
SeekToLast	db/db_test.cc	/^    virtual void SeekToLast() {$/;"	f	class:leveldb::ModelDB::ModelIter
Size	db/db_test.cc	/^  uint64_t Size(const Slice& start, const Slice& limit) {$/;"	f	class:leveldb::DBTest
SpecialEnv	db/db_test.cc	/^  explicit SpecialEnv(Env* base) : EnvWrapper(base) {$/;"	f	class:leveldb::SpecialEnv
SpecialEnv	db/db_test.cc	/^class SpecialEnv : public EnvWrapper {$/;"	c	namespace:leveldb	file:
TEST	db/db_test.cc	/^TEST(DBTest, ApproximateSizes) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, ApproximateSizes_MixOfSmallAndLarge) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, BloomFilter) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, CompactionsGenerateMultipleFiles) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, ComparatorCheck) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, CustomComparator) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, DBOpen_Options) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, DeletionMarkers1) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, DeletionMarkers2) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, Empty) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, FilesDeletedAfterCompaction) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, GetEncountersEmptyLevel) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, GetFromImmutableLayer) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, GetFromVersions) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, GetLevel0Ordering) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, GetMemUsage) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, GetOrderedByLevels) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, GetPicksCorrectFile) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, GetSnapshot) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, HiddenValuesAreRemoved) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, IterEmpty) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, IterMulti) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, IterMultiWithDelete) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, IterSingle) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, IterSmallAndLargeMix) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, IteratorPinsRef) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, L0_CompactionBug_Issue44_a) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, L0_CompactionBug_Issue44_b) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, Locking) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, ManifestWriteError) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, ManualCompaction) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, MinorCompactionsHappen) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, MissingSSTFile) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, MultiThreaded) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, NoSpace) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, NonWritableFileSystem) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, OverlapInLevel0) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, PutDeleteGet) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, Randomized) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, ReadWrite) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, Recover) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, RecoverDuringMemtableCompaction) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, RecoverWithLargeLog) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, RecoveryWithEmptyLog) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, RepeatedWritesToSameKey) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, Snapshot) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, SparseMerge) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, StillReadSST) {$/;"	f	namespace:leveldb
TEST	db/db_test.cc	/^TEST(DBTest, WriteSyncError) {$/;"	f	namespace:leveldb
TotalTableFiles	db/db_test.cc	/^  int TotalTableFiles() {$/;"	f	class:leveldb::DBTest
TryReopen	db/db_test.cc	/^  Status TryReopen(Options* options) {$/;"	f	class:leveldb::DBTest
Valid	db/db_test.cc	/^    virtual bool Valid() const { return iter_ != map_->end(); }$/;"	f	class:leveldb::ModelDB::ModelIter
Write	db/db_test.cc	/^  virtual Status Write(const WriteOptions& options, WriteBatch* batch) {$/;"	f	class:leveldb::ModelDB
bits_per_key_per_filters	db/db_test.cc	/^int bits_per_key_per_filters[]={4,4,4,0};$/;"	m	namespace:leveldb	file:
count_	db/db_test.cc	/^  int count_;$/;"	m	class:leveldb::__anon11::AtomicCounter	file:
count_random_reads_	db/db_test.cc	/^  bool count_random_reads_;$/;"	m	class:leveldb::SpecialEnv	file:
counter	db/db_test.cc	/^  port::AtomicPointer counter[kNumThreads];$/;"	m	struct:leveldb::__anon12::MTState	file:
data_sync_error_	db/db_test.cc	/^  port::AtomicPointer data_sync_error_;$/;"	m	class:leveldb::SpecialEnv	file:
db_	db/db_test.cc	/^  DB* db_;$/;"	m	class:leveldb::DBTest	file:
dbfull	db/db_test.cc	/^  DBImpl* dbfull() {$/;"	f	class:leveldb::DBTest
dbname_	db/db_test.cc	/^  std::string dbname_;$/;"	m	class:leveldb::DBTest	file:
delay_data_sync_	db/db_test.cc	/^  port::AtomicPointer delay_data_sync_;$/;"	m	class:leveldb::SpecialEnv	file:
env_	db/db_test.cc	/^  SpecialEnv* env_;$/;"	m	class:leveldb::DBTest	file:
filter_policy_	db/db_test.cc	/^  const FilterPolicy* filter_policy_;$/;"	m	class:leveldb::DBTest	file:
id	db/db_test.cc	/^  int id;$/;"	m	struct:leveldb::__anon12::MTThread	file:
iter_	db/db_test.cc	/^    KVMap::const_iterator iter_;$/;"	m	class:leveldb::ModelDB::ModelIter	file:
kDefault	db/db_test.cc	/^    kDefault,$/;"	e	enum:leveldb::DBTest::OptionConfig	file:
kEnd	db/db_test.cc	/^    kEnd$/;"	e	enum:leveldb::DBTest::OptionConfig	file:
kFilter	db/db_test.cc	/^    kFilter,$/;"	e	enum:leveldb::DBTest::OptionConfig	file:
kNumKeys	db/db_test.cc	/^static const int kNumKeys = 1000;$/;"	m	namespace:leveldb::__anon12	file:
kNumThreads	db/db_test.cc	/^static const int kNumThreads = 4;$/;"	m	namespace:leveldb::__anon12	file:
kReuse	db/db_test.cc	/^    kReuse,$/;"	e	enum:leveldb::DBTest::OptionConfig	file:
kTestSeconds	db/db_test.cc	/^static const int kTestSeconds = 10;$/;"	m	namespace:leveldb::__anon12	file:
kUncompressed	db/db_test.cc	/^    kUncompressed,$/;"	e	enum:leveldb::DBTest::OptionConfig	file:
key	db/db_test.cc	/^    virtual Slice key() const { return iter_->first; }$/;"	f	class:leveldb::ModelDB::ModelIter
last_options_	db/db_test.cc	/^  Options last_options_;$/;"	m	class:leveldb::DBTest	file:
leveldb	db/db_test.cc	/^namespace leveldb {$/;"	n	file:
main	db/db_test.cc	/^int main(int argc, char** argv) {$/;"	f
manifest_sync_error_	db/db_test.cc	/^  port::AtomicPointer manifest_sync_error_;$/;"	m	class:leveldb::SpecialEnv	file:
manifest_write_error_	db/db_test.cc	/^  port::AtomicPointer manifest_write_error_;$/;"	m	class:leveldb::SpecialEnv	file:
map_	db/db_test.cc	/^    KVMap map_;$/;"	m	class:leveldb::ModelDB::ModelSnapshot	file:
map_	db/db_test.cc	/^    const KVMap* const map_;$/;"	m	class:leveldb::ModelDB::ModelIter	file:
map_	db/db_test.cc	/^  KVMap map_;$/;"	m	class:leveldb::ModelDB	file:
mu_	db/db_test.cc	/^  port::Mutex mu_;$/;"	m	class:leveldb::__anon11::AtomicCounter	file:
no_space_	db/db_test.cc	/^  port::AtomicPointer no_space_;$/;"	m	class:leveldb::SpecialEnv	file:
non_writable_	db/db_test.cc	/^  port::AtomicPointer non_writable_;$/;"	m	class:leveldb::SpecialEnv	file:
option_config_	db/db_test.cc	/^  int option_config_;$/;"	m	class:leveldb::DBTest	file:
options_	db/db_test.cc	/^  const Options options_;$/;"	m	class:leveldb::ModelDB	file:
owned_	db/db_test.cc	/^    const bool owned_;  \/\/ Do we own map_$/;"	m	class:leveldb::ModelDB::ModelIter	file:
random_read_counter_	db/db_test.cc	/^  AtomicCounter random_read_counter_;$/;"	m	class:leveldb::SpecialEnv	file:
state	db/db_test.cc	/^  MTState* state;$/;"	m	struct:leveldb::__anon12::MTThread	file:
status	db/db_test.cc	/^    virtual Status status() const { return Status::OK(); }$/;"	f	class:leveldb::ModelDB::ModelIter
stop	db/db_test.cc	/^  port::AtomicPointer stop;$/;"	m	struct:leveldb::__anon12::MTState	file:
test	db/db_test.cc	/^  DBTest* test;$/;"	m	struct:leveldb::__anon12::MTState	file:
thread_done	db/db_test.cc	/^  port::AtomicPointer thread_done[kNumThreads];$/;"	m	struct:leveldb::__anon12::MTState	file:
value	db/db_test.cc	/^    virtual Slice value() const { return iter_->second; }$/;"	f	class:leveldb::ModelDB::ModelIter
~DBTest	db/db_test.cc	/^  ~DBTest() {$/;"	f	class:leveldb::DBTest
~ModelDB	db/db_test.cc	/^  ~ModelDB() { }$/;"	f	class:leveldb::ModelDB
~ModelIter	db/db_test.cc	/^    ~ModelIter() {$/;"	f	class:leveldb::ModelDB::ModelIter
AppendInternalKey	db/dbformat.cc	/^void AppendInternalKey(std::string* result, const ParsedInternalKey& key) {$/;"	f	namespace:leveldb
Compare	db/dbformat.cc	/^int InternalKeyComparator::Compare(const Slice& akey, const Slice& bkey) const {$/;"	f	class:leveldb::InternalKeyComparator
CreateFilter	db/dbformat.cc	/^void InternalFilterPolicy::CreateFilter(const Slice* keys, int n, std::list< std::string >& dsts) const$/;"	f	class:leveldb::InternalFilterPolicy
CreateFilter	db/dbformat.cc	/^void InternalFilterPolicy::CreateFilter(const Slice* keys, int n,$/;"	f	class:leveldb::InternalFilterPolicy
DebugString	db/dbformat.cc	/^std::string InternalKey::DebugString() const {$/;"	f	class:leveldb::InternalKey
DebugString	db/dbformat.cc	/^std::string ParsedInternalKey::DebugString() const {$/;"	f	class:leveldb::ParsedInternalKey
FindShortSuccessor	db/dbformat.cc	/^void InternalKeyComparator::FindShortSuccessor(std::string* key) const {$/;"	f	class:leveldb::InternalKeyComparator
FindShortestSeparator	db/dbformat.cc	/^void InternalKeyComparator::FindShortestSeparator($/;"	f	class:leveldb::InternalKeyComparator
KeyMayMatch	db/dbformat.cc	/^bool InternalFilterPolicy::KeyMayMatch(const Slice& key, const Slice& f) const {$/;"	f	class:leveldb::InternalFilterPolicy
KeyMayMatch	db/dbformat.cc	/^bool InternalFilterPolicy::KeyMayMatch(const Slice& key, const Slice& filter, int id) const$/;"	f	class:leveldb::InternalFilterPolicy
KeyMayMatchFilters	db/dbformat.cc	/^bool InternalFilterPolicy::KeyMayMatchFilters(const Slice& key, const std::list< Slice>& filters) const$/;"	f	class:leveldb::InternalFilterPolicy
LookupKey	db/dbformat.cc	/^LookupKey::LookupKey(const Slice& user_key, SequenceNumber s) {$/;"	f	class:leveldb::LookupKey
Name	db/dbformat.cc	/^const char* InternalFilterPolicy::Name() const {$/;"	f	class:leveldb::InternalFilterPolicy
Name	db/dbformat.cc	/^const char* InternalKeyComparator::Name() const {$/;"	f	class:leveldb::InternalKeyComparator
PackSequenceAndType	db/dbformat.cc	/^static uint64_t PackSequenceAndType(uint64_t seq, ValueType t) {$/;"	f	namespace:leveldb
filterNums	db/dbformat.cc	/^int InternalFilterPolicy::filterNums() const$/;"	f	class:leveldb::InternalFilterPolicy
leveldb	db/dbformat.cc	/^namespace leveldb {$/;"	n	file:
Clear	db/dbformat.h	/^  void Clear() { rep_.clear(); }$/;"	f	class:leveldb::InternalKey
Compare	db/dbformat.h	/^inline int InternalKeyComparator::Compare($/;"	f	class:leveldb::InternalKeyComparator
DecodeFrom	db/dbformat.h	/^  void DecodeFrom(const Slice& s) { rep_.assign(s.data(), s.size()); }$/;"	f	class:leveldb::InternalKey
Encode	db/dbformat.h	/^  Slice Encode() const {$/;"	f	class:leveldb::InternalKey
ExtractUserKey	db/dbformat.h	/^inline Slice ExtractUserKey(const Slice& internal_key) {$/;"	f	namespace:leveldb
ExtractValueType	db/dbformat.h	/^inline ValueType ExtractValueType(const Slice& internal_key) {$/;"	f	namespace:leveldb
InternalFilterPolicy	db/dbformat.h	/^  explicit InternalFilterPolicy(const FilterPolicy* p) : user_policy_(p) { }$/;"	f	class:leveldb::InternalFilterPolicy
InternalFilterPolicy	db/dbformat.h	/^class InternalFilterPolicy : public FilterPolicy {$/;"	c	namespace:leveldb
InternalKey	db/dbformat.h	/^  InternalKey() { }   \/\/ Leave rep_ as empty to indicate it is invalid$/;"	f	class:leveldb::InternalKey
InternalKey	db/dbformat.h	/^  InternalKey(const Slice& user_key, SequenceNumber s, ValueType t) {$/;"	f	class:leveldb::InternalKey
InternalKey	db/dbformat.h	/^class InternalKey {$/;"	c	namespace:leveldb
InternalKeyComparator	db/dbformat.h	/^  explicit InternalKeyComparator(const Comparator* c) : user_comparator_(c) { }$/;"	f	class:leveldb::InternalKeyComparator
InternalKeyComparator	db/dbformat.h	/^class InternalKeyComparator : public Comparator {$/;"	c	namespace:leveldb
InternalKeyEncodingLength	db/dbformat.h	/^inline size_t InternalKeyEncodingLength(const ParsedInternalKey& key) {$/;"	f	namespace:leveldb
LookupKey	db/dbformat.h	/^class LookupKey {$/;"	c	namespace:leveldb
ParseInternalKey	db/dbformat.h	/^inline bool ParseInternalKey(const Slice& internal_key,$/;"	f	namespace:leveldb
ParsedInternalKey	db/dbformat.h	/^  ParsedInternalKey() { }  \/\/ Intentionally left uninitialized (for speed)$/;"	f	struct:leveldb::ParsedInternalKey
ParsedInternalKey	db/dbformat.h	/^  ParsedInternalKey(const Slice& u, const SequenceNumber& seq, ValueType t)$/;"	f	struct:leveldb::ParsedInternalKey
ParsedInternalKey	db/dbformat.h	/^struct ParsedInternalKey {$/;"	s	namespace:leveldb
STORAGE_LEVELDB_DB_DBFORMAT_H_	db/dbformat.h	6;"	d
SequenceNumber	db/dbformat.h	/^typedef uint64_t SequenceNumber;$/;"	t	namespace:leveldb
SetFrom	db/dbformat.h	/^  void SetFrom(const ParsedInternalKey& p) {$/;"	f	class:leveldb::InternalKey
ValueType	db/dbformat.h	/^enum ValueType {$/;"	g	namespace:leveldb
config	db/dbformat.h	/^namespace config {$/;"	n	namespace:leveldb
end_	db/dbformat.h	/^  const char* end_;$/;"	m	class:leveldb::LookupKey
internal_key	db/dbformat.h	/^  Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }$/;"	f	class:leveldb::LookupKey
kL0_CompactionTrigger	db/dbformat.h	/^static const int kL0_CompactionTrigger = 4;$/;"	m	namespace:leveldb::config
kL0_SlowdownWritesTrigger	db/dbformat.h	/^static const int kL0_SlowdownWritesTrigger = 8;$/;"	m	namespace:leveldb::config
kL0_StopWritesTrigger	db/dbformat.h	/^static const int kL0_StopWritesTrigger = 12;$/;"	m	namespace:leveldb::config
kMaxMemCompactLevel	db/dbformat.h	/^static const int kMaxMemCompactLevel = 2;$/;"	m	namespace:leveldb::config
kMaxSequenceNumber	db/dbformat.h	/^static const SequenceNumber kMaxSequenceNumber =$/;"	m	namespace:leveldb
kNumLevels	db/dbformat.h	/^static const int kNumLevels = 8;$/;"	m	namespace:leveldb::config
kReadBytesPeriod	db/dbformat.h	/^static const int kReadBytesPeriod = 1048576;$/;"	m	namespace:leveldb::config
kTypeDeletion	db/dbformat.h	/^  kTypeDeletion = 0x0,$/;"	e	enum:leveldb::ValueType
kTypeValue	db/dbformat.h	/^  kTypeValue = 0x1$/;"	e	enum:leveldb::ValueType
kValueTypeForSeek	db/dbformat.h	/^static const ValueType kValueTypeForSeek = kTypeValue;$/;"	m	namespace:leveldb
kstart_	db/dbformat.h	/^  const char* kstart_;$/;"	m	class:leveldb::LookupKey
leveldb	db/dbformat.h	/^namespace leveldb {$/;"	n
memtable_key	db/dbformat.h	/^  Slice memtable_key() const { return Slice(start_, end_ - start_); }$/;"	f	class:leveldb::LookupKey
rep_	db/dbformat.h	/^  std::string rep_;$/;"	m	class:leveldb::InternalKey
sequence	db/dbformat.h	/^  SequenceNumber sequence;$/;"	m	struct:leveldb::ParsedInternalKey
space_	db/dbformat.h	/^  char space_[200];      \/\/ Avoid allocation for short keys$/;"	m	class:leveldb::LookupKey
start_	db/dbformat.h	/^  const char* start_;$/;"	m	class:leveldb::LookupKey
type	db/dbformat.h	/^  ValueType type;$/;"	m	struct:leveldb::ParsedInternalKey
user_comparator	db/dbformat.h	/^  const Comparator* user_comparator() const { return user_comparator_; }$/;"	f	class:leveldb::InternalKeyComparator
user_comparator_	db/dbformat.h	/^  const Comparator* user_comparator_;$/;"	m	class:leveldb::InternalKeyComparator
user_key	db/dbformat.h	/^  Slice user_key() const { return ExtractUserKey(rep_); }$/;"	f	class:leveldb::InternalKey
user_key	db/dbformat.h	/^  Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }$/;"	f	class:leveldb::LookupKey
user_key	db/dbformat.h	/^  Slice user_key;$/;"	m	struct:leveldb::ParsedInternalKey
user_policy_	db/dbformat.h	/^  const FilterPolicy* const user_policy_;$/;"	m	class:leveldb::InternalFilterPolicy
~LookupKey	db/dbformat.h	/^inline LookupKey::~LookupKey() {$/;"	f	class:leveldb::LookupKey
FormatTest	db/dbformat_test.cc	/^class FormatTest { };$/;"	c	namespace:leveldb	file:
IKey	db/dbformat_test.cc	/^static std::string IKey(const std::string& user_key,$/;"	f	namespace:leveldb
ShortSuccessor	db/dbformat_test.cc	/^static std::string ShortSuccessor(const std::string& s) {$/;"	f	namespace:leveldb
Shorten	db/dbformat_test.cc	/^static std::string Shorten(const std::string& s, const std::string& l) {$/;"	f	namespace:leveldb
TEST	db/dbformat_test.cc	/^TEST(FormatTest, InternalKeyShortSeparator) {$/;"	f	namespace:leveldb
TEST	db/dbformat_test.cc	/^TEST(FormatTest, InternalKeyShortestSuccessor) {$/;"	f	namespace:leveldb
TEST	db/dbformat_test.cc	/^TEST(FormatTest, InternalKey_EncodeDecode) {$/;"	f	namespace:leveldb
TestKey	db/dbformat_test.cc	/^static void TestKey(const std::string& key,$/;"	f	namespace:leveldb
leveldb	db/dbformat_test.cc	/^namespace leveldb {$/;"	n	file:
main	db/dbformat_test.cc	/^int main(int argc, char** argv) {$/;"	f
Corruption	db/dumpfile.cc	/^  virtual void Corruption(size_t bytes, const Status& status) {$/;"	f	class:leveldb::__anon2::CorruptionReporter
CorruptionReporter	db/dumpfile.cc	/^class CorruptionReporter : public log::Reader::Reporter {$/;"	c	namespace:leveldb::__anon2	file:
Delete	db/dumpfile.cc	/^  virtual void Delete(const Slice& key) {$/;"	f	class:leveldb::__anon2::WriteBatchItemPrinter
DumpDescriptor	db/dumpfile.cc	/^Status DumpDescriptor(Env* env, const std::string& fname, WritableFile* dst) {$/;"	f	namespace:leveldb::__anon2
DumpFile	db/dumpfile.cc	/^Status DumpFile(Env* env, const std::string& fname, WritableFile* dst) {$/;"	f	namespace:leveldb
DumpLog	db/dumpfile.cc	/^Status DumpLog(Env* env, const std::string& fname, WritableFile* dst) {$/;"	f	namespace:leveldb::__anon2
DumpTable	db/dumpfile.cc	/^Status DumpTable(Env* env, const std::string& fname, WritableFile* dst) {$/;"	f	namespace:leveldb::__anon2
GuessType	db/dumpfile.cc	/^bool GuessType(const std::string& fname, FileType* type) {$/;"	f	namespace:leveldb::__anon2
PrintLogContents	db/dumpfile.cc	/^Status PrintLogContents(Env* env, const std::string& fname,$/;"	f	namespace:leveldb::__anon2
Put	db/dumpfile.cc	/^  virtual void Put(const Slice& key, const Slice& value) {$/;"	f	class:leveldb::__anon2::WriteBatchItemPrinter
VersionEditPrinter	db/dumpfile.cc	/^static void VersionEditPrinter(uint64_t pos, Slice record, WritableFile* dst) {$/;"	f	namespace:leveldb::__anon2
WriteBatchItemPrinter	db/dumpfile.cc	/^class WriteBatchItemPrinter : public WriteBatch::Handler {$/;"	c	namespace:leveldb::__anon2	file:
WriteBatchPrinter	db/dumpfile.cc	/^static void WriteBatchPrinter(uint64_t pos, Slice record, WritableFile* dst) {$/;"	f	namespace:leveldb::__anon2
dst_	db/dumpfile.cc	/^  WritableFile* dst_;$/;"	m	class:leveldb::__anon2::CorruptionReporter	file:
dst_	db/dumpfile.cc	/^  WritableFile* dst_;$/;"	m	class:leveldb::__anon2::WriteBatchItemPrinter	file:
leveldb	db/dumpfile.cc	/^namespace leveldb {$/;"	n	file:
Append	db/fault_injection_test.cc	/^Status TestWritableFile::Append(const Slice& data) {$/;"	f	class:leveldb::TestWritableFile
Build	db/fault_injection_test.cc	/^  void Build(int start_idx, int num_vals) {$/;"	f	class:leveldb::FaultInjectionTest
Close	db/fault_injection_test.cc	/^Status TestWritableFile::Close() {$/;"	f	class:leveldb::TestWritableFile
CloseDB	db/fault_injection_test.cc	/^  void CloseDB() {$/;"	f	class:leveldb::FaultInjectionTest
DeleteAllData	db/fault_injection_test.cc	/^  void DeleteAllData() {$/;"	f	class:leveldb::FaultInjectionTest
DeleteFile	db/fault_injection_test.cc	/^Status FaultInjectionTestEnv::DeleteFile(const std::string& f) {$/;"	f	class:leveldb::FaultInjectionTestEnv
DeleteFilesCreatedAfterLastDirSync	db/fault_injection_test.cc	/^Status FaultInjectionTestEnv::DeleteFilesCreatedAfterLastDirSync() {$/;"	f	class:leveldb::FaultInjectionTestEnv
DirWasSynced	db/fault_injection_test.cc	/^void FaultInjectionTestEnv::DirWasSynced() {$/;"	f	class:leveldb::FaultInjectionTestEnv
DoTest	db/fault_injection_test.cc	/^  void DoTest() {$/;"	f	class:leveldb::FaultInjectionTest
DropUnsyncedData	db/fault_injection_test.cc	/^Status FileState::DropUnsyncedData() const {$/;"	f	class:leveldb::FileState
DropUnsyncedFileData	db/fault_injection_test.cc	/^Status FaultInjectionTestEnv::DropUnsyncedFileData() {$/;"	f	class:leveldb::FaultInjectionTestEnv
ExpectedVerifResult	db/fault_injection_test.cc	/^  enum ExpectedVerifResult { VAL_EXPECT_NO_ERROR, VAL_EXPECT_ERROR };$/;"	g	class:leveldb::FaultInjectionTest	file:
FaultInjectionTest	db/fault_injection_test.cc	/^  FaultInjectionTest()$/;"	f	class:leveldb::FaultInjectionTest
FaultInjectionTest	db/fault_injection_test.cc	/^class FaultInjectionTest {$/;"	c	namespace:leveldb	file:
FaultInjectionTestEnv	db/fault_injection_test.cc	/^  FaultInjectionTestEnv() : EnvWrapper(Env::Default()), filesystem_active_(true) {}$/;"	f	class:leveldb::FaultInjectionTestEnv
FaultInjectionTestEnv	db/fault_injection_test.cc	/^class FaultInjectionTestEnv : public EnvWrapper {$/;"	c	namespace:leveldb	file:
FileState	db/fault_injection_test.cc	/^  FileState() : pos_(-1), pos_at_last_sync_(-1), pos_at_last_flush_(-1) {}$/;"	f	struct:leveldb::__anon3::FileState
FileState	db/fault_injection_test.cc	/^  FileState(const std::string& filename)$/;"	f	struct:leveldb::__anon3::FileState
FileState	db/fault_injection_test.cc	/^struct FileState {$/;"	s	namespace:leveldb::__anon3	file:
Flush	db/fault_injection_test.cc	/^Status TestWritableFile::Flush() {$/;"	f	class:leveldb::TestWritableFile
GetDirName	db/fault_injection_test.cc	/^static std::string GetDirName(const std::string filename) {$/;"	f	namespace:leveldb::__anon3
IsFileCreatedSinceLastDirSync	db/fault_injection_test.cc	/^bool FaultInjectionTestEnv::IsFileCreatedSinceLastDirSync($/;"	f	class:leveldb::FaultInjectionTestEnv
IsFilesystemActive	db/fault_injection_test.cc	/^  bool IsFilesystemActive() const { return filesystem_active_; }$/;"	f	class:leveldb::FaultInjectionTestEnv
IsFullySynced	db/fault_injection_test.cc	/^  bool IsFullySynced() const { return pos_ <= 0 || pos_ == pos_at_last_sync_; }$/;"	f	struct:leveldb::__anon3::FileState
Key	db/fault_injection_test.cc	/^  Slice Key(int i, std::string* storage) const {$/;"	f	class:leveldb::FaultInjectionTest
NewAppendableFile	db/fault_injection_test.cc	/^Status FaultInjectionTestEnv::NewAppendableFile(const std::string& fname,$/;"	f	class:leveldb::FaultInjectionTestEnv
NewWritableFile	db/fault_injection_test.cc	/^Status FaultInjectionTestEnv::NewWritableFile(const std::string& fname,$/;"	f	class:leveldb::FaultInjectionTestEnv
NoWriteTestPreFault	db/fault_injection_test.cc	/^  void NoWriteTestPreFault() {$/;"	f	class:leveldb::FaultInjectionTest
NoWriteTestReopenWithFault	db/fault_injection_test.cc	/^  void NoWriteTestReopenWithFault(ResetMethod reset_method) {$/;"	f	class:leveldb::FaultInjectionTest
OpenDB	db/fault_injection_test.cc	/^  Status OpenDB() {$/;"	f	class:leveldb::FaultInjectionTest
PartialCompactTestPreFault	db/fault_injection_test.cc	/^  void PartialCompactTestPreFault(int num_pre_sync, int num_post_sync) {$/;"	f	class:leveldb::FaultInjectionTest
PartialCompactTestReopenWithFault	db/fault_injection_test.cc	/^  void PartialCompactTestReopenWithFault(ResetMethod reset_method,$/;"	f	class:leveldb::FaultInjectionTest
RESET_DELETE_UNSYNCED_FILES	db/fault_injection_test.cc	/^  enum ResetMethod { RESET_DROP_UNSYNCED_DATA, RESET_DELETE_UNSYNCED_FILES };$/;"	e	enum:leveldb::FaultInjectionTest::ResetMethod	file:
RESET_DROP_UNSYNCED_DATA	db/fault_injection_test.cc	/^  enum ResetMethod { RESET_DROP_UNSYNCED_DATA, RESET_DELETE_UNSYNCED_FILES };$/;"	e	enum:leveldb::FaultInjectionTest::ResetMethod	file:
ReadValue	db/fault_injection_test.cc	/^  Status ReadValue(int i, std::string* val) const {$/;"	f	class:leveldb::FaultInjectionTest
RenameFile	db/fault_injection_test.cc	/^Status FaultInjectionTestEnv::RenameFile(const std::string& s,$/;"	f	class:leveldb::FaultInjectionTestEnv
ResetDBState	db/fault_injection_test.cc	/^  void ResetDBState(ResetMethod reset_method) {$/;"	f	class:leveldb::FaultInjectionTest
ResetMethod	db/fault_injection_test.cc	/^  enum ResetMethod { RESET_DROP_UNSYNCED_DATA, RESET_DELETE_UNSYNCED_FILES };$/;"	g	class:leveldb::FaultInjectionTest	file:
ResetState	db/fault_injection_test.cc	/^void FaultInjectionTestEnv::ResetState() {$/;"	f	class:leveldb::FaultInjectionTestEnv
ReuseLogs	db/fault_injection_test.cc	/^  void ReuseLogs(bool reuse) {$/;"	f	class:leveldb::FaultInjectionTest
SetFilesystemActive	db/fault_injection_test.cc	/^  void SetFilesystemActive(bool active) { filesystem_active_ = active; }$/;"	f	class:leveldb::FaultInjectionTestEnv
Sync	db/fault_injection_test.cc	/^Status TestWritableFile::Sync() {$/;"	f	class:leveldb::TestWritableFile
SyncDir	db/fault_injection_test.cc	/^Status SyncDir(const std::string& dir) {$/;"	f	namespace:leveldb::__anon3
SyncParent	db/fault_injection_test.cc	/^Status TestWritableFile::SyncParent() {$/;"	f	class:leveldb::TestWritableFile
TEST	db/fault_injection_test.cc	/^TEST(FaultInjectionTest, FaultTestNoLogReuse) {$/;"	f	namespace:leveldb
TEST	db/fault_injection_test.cc	/^TEST(FaultInjectionTest, FaultTestWithLogReuse) {$/;"	f	namespace:leveldb
TestWritableFile	db/fault_injection_test.cc	/^TestWritableFile::TestWritableFile(const FileState& state,$/;"	f	class:leveldb::TestWritableFile
TestWritableFile	db/fault_injection_test.cc	/^class TestWritableFile : public WritableFile {$/;"	c	namespace:leveldb	file:
Truncate	db/fault_injection_test.cc	/^Status Truncate(const std::string& filename, uint64_t length) {$/;"	f	namespace:leveldb::__anon3
UntrackFile	db/fault_injection_test.cc	/^void FaultInjectionTestEnv::UntrackFile(const std::string& f) {$/;"	f	class:leveldb::FaultInjectionTestEnv
VAL_EXPECT_ERROR	db/fault_injection_test.cc	/^  enum ExpectedVerifResult { VAL_EXPECT_NO_ERROR, VAL_EXPECT_ERROR };$/;"	e	enum:leveldb::FaultInjectionTest::ExpectedVerifResult	file:
VAL_EXPECT_NO_ERROR	db/fault_injection_test.cc	/^  enum ExpectedVerifResult { VAL_EXPECT_NO_ERROR, VAL_EXPECT_ERROR };$/;"	e	enum:leveldb::FaultInjectionTest::ExpectedVerifResult	file:
Value	db/fault_injection_test.cc	/^  Slice Value(int k, std::string* storage) const {$/;"	f	class:leveldb::FaultInjectionTest
Verify	db/fault_injection_test.cc	/^  Status Verify(int start_idx, int num_vals,$/;"	f	class:leveldb::FaultInjectionTest
WritableFileClosed	db/fault_injection_test.cc	/^void FaultInjectionTestEnv::WritableFileClosed(const FileState& state) {$/;"	f	class:leveldb::FaultInjectionTestEnv
db_	db/fault_injection_test.cc	/^  DB* db_;$/;"	m	class:leveldb::FaultInjectionTest	file:
db_file_state_	db/fault_injection_test.cc	/^  std::map<std::string, FileState> db_file_state_;$/;"	m	class:leveldb::FaultInjectionTestEnv	file:
dbname_	db/fault_injection_test.cc	/^  std::string dbname_;$/;"	m	class:leveldb::FaultInjectionTest	file:
env_	db/fault_injection_test.cc	/^  FaultInjectionTestEnv* env_;$/;"	m	class:leveldb::FaultInjectionTest	file:
env_	db/fault_injection_test.cc	/^  FaultInjectionTestEnv* env_;$/;"	m	class:leveldb::TestWritableFile	file:
filename_	db/fault_injection_test.cc	/^  std::string filename_;$/;"	m	struct:leveldb::__anon3::FileState	file:
filesystem_active_	db/fault_injection_test.cc	/^  bool filesystem_active_;  \/\/ Record flushes, syncs, writes$/;"	m	class:leveldb::FaultInjectionTestEnv	file:
kMaxNumValues	db/fault_injection_test.cc	/^static const int kMaxNumValues = 2000;$/;"	m	namespace:leveldb	file:
kNumIterations	db/fault_injection_test.cc	/^static const size_t kNumIterations = 3;$/;"	m	namespace:leveldb	file:
kValueSize	db/fault_injection_test.cc	/^static const int kValueSize = 1000;$/;"	m	namespace:leveldb	file:
leveldb	db/fault_injection_test.cc	/^namespace leveldb {$/;"	n	file:
main	db/fault_injection_test.cc	/^int main(int argc, char** argv) {$/;"	f
mutex_	db/fault_injection_test.cc	/^  port::Mutex mutex_;$/;"	m	class:leveldb::FaultInjectionTestEnv	file:
new_files_since_last_dir_sync_	db/fault_injection_test.cc	/^  std::set<std::string> new_files_since_last_dir_sync_;$/;"	m	class:leveldb::FaultInjectionTestEnv	file:
options_	db/fault_injection_test.cc	/^  Options options_;$/;"	m	class:leveldb::FaultInjectionTest	file:
pos_	db/fault_injection_test.cc	/^  ssize_t pos_;$/;"	m	struct:leveldb::__anon3::FileState	file:
pos_at_last_flush_	db/fault_injection_test.cc	/^  ssize_t pos_at_last_flush_;$/;"	m	struct:leveldb::__anon3::FileState	file:
pos_at_last_sync_	db/fault_injection_test.cc	/^  ssize_t pos_at_last_sync_;$/;"	m	struct:leveldb::__anon3::FileState	file:
state_	db/fault_injection_test.cc	/^  FileState state_;$/;"	m	class:leveldb::TestWritableFile	file:
target_	db/fault_injection_test.cc	/^  WritableFile* target_;$/;"	m	class:leveldb::TestWritableFile	file:
tiny_cache_	db/fault_injection_test.cc	/^  Cache* tiny_cache_;$/;"	m	class:leveldb::FaultInjectionTest	file:
writable_file_opened_	db/fault_injection_test.cc	/^  bool writable_file_opened_;$/;"	m	class:leveldb::TestWritableFile	file:
~FaultInjectionTest	db/fault_injection_test.cc	/^  ~FaultInjectionTest() {$/;"	f	class:leveldb::FaultInjectionTest
~FaultInjectionTestEnv	db/fault_injection_test.cc	/^  virtual ~FaultInjectionTestEnv() { }$/;"	f	class:leveldb::FaultInjectionTestEnv
~TestWritableFile	db/fault_injection_test.cc	/^TestWritableFile::~TestWritableFile() {$/;"	f	class:leveldb::TestWritableFile
CurrentFileName	db/filename.cc	/^std::string CurrentFileName(const std::string& dbname) {$/;"	f	namespace:leveldb
DescriptorFileName	db/filename.cc	/^std::string DescriptorFileName(const std::string& dbname, uint64_t number) {$/;"	f	namespace:leveldb
InfoLogFileName	db/filename.cc	/^std::string InfoLogFileName(const std::string& dbname) {$/;"	f	namespace:leveldb
LockFileName	db/filename.cc	/^std::string LockFileName(const std::string& dbname) {$/;"	f	namespace:leveldb
LogFileName	db/filename.cc	/^std::string LogFileName(const std::string& name, uint64_t number) {$/;"	f	namespace:leveldb
MakeFileName	db/filename.cc	/^static std::string MakeFileName(const std::string& name, uint64_t number,$/;"	f	namespace:leveldb
OldInfoLogFileName	db/filename.cc	/^std::string OldInfoLogFileName(const std::string& dbname) {$/;"	f	namespace:leveldb
ParseFileName	db/filename.cc	/^bool ParseFileName(const std::string& fname,$/;"	f	namespace:leveldb
SSTTableFileName	db/filename.cc	/^std::string SSTTableFileName(const std::string& name, uint64_t number) {$/;"	f	namespace:leveldb
SetCurrentFile	db/filename.cc	/^Status SetCurrentFile(Env* env, const std::string& dbname,$/;"	f	namespace:leveldb
TableFileName	db/filename.cc	/^std::string TableFileName(const std::string& name, uint64_t number) {$/;"	f	namespace:leveldb
TempFileName	db/filename.cc	/^std::string TempFileName(const std::string& dbname, uint64_t number) {$/;"	f	namespace:leveldb
leveldb	db/filename.cc	/^namespace leveldb {$/;"	n	file:
FileType	db/filename.h	/^enum FileType {$/;"	g	namespace:leveldb
STORAGE_LEVELDB_DB_FILENAME_H_	db/filename.h	8;"	d
kCurrentFile	db/filename.h	/^  kCurrentFile,$/;"	e	enum:leveldb::FileType
kDBLockFile	db/filename.h	/^  kDBLockFile,$/;"	e	enum:leveldb::FileType
kDescriptorFile	db/filename.h	/^  kDescriptorFile,$/;"	e	enum:leveldb::FileType
kInfoLogFile	db/filename.h	/^  kInfoLogFile  \/\/ Either the current one, or an old one$/;"	e	enum:leveldb::FileType
kLogFile	db/filename.h	/^  kLogFile,$/;"	e	enum:leveldb::FileType
kTableFile	db/filename.h	/^  kTableFile,$/;"	e	enum:leveldb::FileType
kTempFile	db/filename.h	/^  kTempFile,$/;"	e	enum:leveldb::FileType
leveldb	db/filename.h	/^namespace leveldb {$/;"	n
FileNameTest	db/filename_test.cc	/^class FileNameTest { };$/;"	c	namespace:leveldb	file:
TEST	db/filename_test.cc	/^TEST(FileNameTest, Construction) {$/;"	f	namespace:leveldb
TEST	db/filename_test.cc	/^TEST(FileNameTest, Parse) {$/;"	f	namespace:leveldb
leveldb	db/filename_test.cc	/^namespace leveldb {$/;"	n	file:
main	db/filename_test.cc	/^int main(int argc, char** argv) {$/;"	f
Append	db/leveldbutil.cc	/^  virtual Status Append(const Slice& data) {$/;"	f	class:leveldb::__anon4::StdoutPrinter
Close	db/leveldbutil.cc	/^  virtual Status Close() { return Status::OK(); }$/;"	f	class:leveldb::__anon4::StdoutPrinter
Flush	db/leveldbutil.cc	/^  virtual Status Flush() { return Status::OK(); }$/;"	f	class:leveldb::__anon4::StdoutPrinter
HandleDumpCommand	db/leveldbutil.cc	/^bool HandleDumpCommand(Env* env, char** files, int num) {$/;"	f	namespace:leveldb::__anon4
StdoutPrinter	db/leveldbutil.cc	/^class StdoutPrinter : public WritableFile {$/;"	c	namespace:leveldb::__anon4	file:
Sync	db/leveldbutil.cc	/^  virtual Status Sync() { return Status::OK(); }$/;"	f	class:leveldb::__anon4::StdoutPrinter
Usage	db/leveldbutil.cc	/^static void Usage() {$/;"	f	file:
leveldb	db/leveldbutil.cc	/^namespace leveldb {$/;"	n	file:
main	db/leveldbutil.cc	/^int main(int argc, char** argv) {$/;"	f
RecordType	db/log_format.h	/^enum RecordType {$/;"	g	namespace:leveldb::log
STORAGE_LEVELDB_DB_LOG_FORMAT_H_	db/log_format.h	9;"	d
kBlockSize	db/log_format.h	/^static const int kBlockSize = 32768;$/;"	m	namespace:leveldb::log
kFirstType	db/log_format.h	/^  kFirstType = 2,$/;"	e	enum:leveldb::log::RecordType
kFullType	db/log_format.h	/^  kFullType = 1,$/;"	e	enum:leveldb::log::RecordType
kHeaderSize	db/log_format.h	/^static const int kHeaderSize = 4 + 2 + 1;$/;"	m	namespace:leveldb::log
kLastType	db/log_format.h	/^  kLastType = 4$/;"	e	enum:leveldb::log::RecordType
kMaxRecordType	db/log_format.h	/^static const int kMaxRecordType = kLastType;$/;"	m	namespace:leveldb::log
kMiddleType	db/log_format.h	/^  kMiddleType = 3,$/;"	e	enum:leveldb::log::RecordType
kZeroType	db/log_format.h	/^  kZeroType = 0,$/;"	e	enum:leveldb::log::RecordType
leveldb	db/log_format.h	/^namespace leveldb {$/;"	n
log	db/log_format.h	/^namespace log {$/;"	n	namespace:leveldb
LastRecordOffset	db/log_reader.cc	/^uint64_t Reader::LastRecordOffset() {$/;"	f	class:leveldb::log::Reader
ReadPhysicalRecord	db/log_reader.cc	/^unsigned int Reader::ReadPhysicalRecord(Slice* result) {$/;"	f	class:leveldb::log::Reader
ReadRecord	db/log_reader.cc	/^bool Reader::ReadRecord(Slice* record, std::string* scratch) {$/;"	f	class:leveldb::log::Reader
Reader	db/log_reader.cc	/^Reader::Reader(SequentialFile* file, Reporter* reporter, bool checksum,$/;"	f	class:leveldb::log::Reader
ReportCorruption	db/log_reader.cc	/^void Reader::ReportCorruption(uint64_t bytes, const char* reason) {$/;"	f	class:leveldb::log::Reader
ReportDrop	db/log_reader.cc	/^void Reader::ReportDrop(uint64_t bytes, const Status& reason) {$/;"	f	class:leveldb::log::Reader
SkipToInitialBlock	db/log_reader.cc	/^bool Reader::SkipToInitialBlock() {$/;"	f	class:leveldb::log::Reader
leveldb	db/log_reader.cc	/^namespace leveldb {$/;"	n	file:
log	db/log_reader.cc	/^namespace log {$/;"	n	namespace:leveldb	file:
~Reader	db/log_reader.cc	/^Reader::~Reader() {$/;"	f	class:leveldb::log::Reader
~Reporter	db/log_reader.cc	/^Reader::Reporter::~Reporter() {$/;"	f	class:leveldb::log::Reader::Reporter
Reader	db/log_reader.h	/^class Reader {$/;"	c	namespace:leveldb::log
Reporter	db/log_reader.h	/^  class Reporter {$/;"	c	class:leveldb::log::Reader
STORAGE_LEVELDB_DB_LOG_READER_H_	db/log_reader.h	6;"	d
backing_store_	db/log_reader.h	/^  char* const backing_store_;$/;"	m	class:leveldb::log::Reader
buffer_	db/log_reader.h	/^  Slice buffer_;$/;"	m	class:leveldb::log::Reader
checksum_	db/log_reader.h	/^  bool const checksum_;$/;"	m	class:leveldb::log::Reader
end_of_buffer_offset_	db/log_reader.h	/^  uint64_t end_of_buffer_offset_;$/;"	m	class:leveldb::log::Reader
eof_	db/log_reader.h	/^  bool eof_;   \/\/ Last Read() indicated EOF by returning < kBlockSize$/;"	m	class:leveldb::log::Reader
file_	db/log_reader.h	/^  SequentialFile* const file_;$/;"	m	class:leveldb::log::Reader
initial_offset_	db/log_reader.h	/^  uint64_t const initial_offset_;$/;"	m	class:leveldb::log::Reader
kBadRecord	db/log_reader.h	/^    kBadRecord = kMaxRecordType + 2$/;"	e	enum:leveldb::log::Reader::__anon5
kEof	db/log_reader.h	/^    kEof = kMaxRecordType + 1,$/;"	e	enum:leveldb::log::Reader::__anon5
last_record_offset_	db/log_reader.h	/^  uint64_t last_record_offset_;$/;"	m	class:leveldb::log::Reader
leveldb	db/log_reader.h	/^namespace leveldb {$/;"	n
log	db/log_reader.h	/^namespace log {$/;"	n	namespace:leveldb
reporter_	db/log_reader.h	/^  Reporter* const reporter_;$/;"	m	class:leveldb::log::Reader
resyncing_	db/log_reader.h	/^  bool resyncing_;$/;"	m	class:leveldb::log::Reader
Append	db/log_test.cc	/^    virtual Status Append(const Slice& slice) {$/;"	f	class:leveldb::log::LogTest::StringDest
BigString	db/log_test.cc	/^static std::string BigString(const std::string& partial_string, size_t n) {$/;"	f	namespace:leveldb::log
CheckInitialOffsetRecord	db/log_test.cc	/^  void CheckInitialOffsetRecord(uint64_t initial_offset,$/;"	f	class:leveldb::log::LogTest
CheckOffsetPastEndReturnsNoRecords	db/log_test.cc	/^  void CheckOffsetPastEndReturnsNoRecords(uint64_t offset_past_end) {$/;"	f	class:leveldb::log::LogTest
Close	db/log_test.cc	/^    virtual Status Close() { return Status::OK(); }$/;"	f	class:leveldb::log::LogTest::StringDest
Corruption	db/log_test.cc	/^    virtual void Corruption(size_t bytes, const Status& status) {$/;"	f	class:leveldb::log::LogTest::ReportCollector
DroppedBytes	db/log_test.cc	/^  size_t DroppedBytes() const {$/;"	f	class:leveldb::log::LogTest
FixChecksum	db/log_test.cc	/^  void FixChecksum(int header_offset, int len) {$/;"	f	class:leveldb::log::LogTest
Flush	db/log_test.cc	/^    virtual Status Flush() { return Status::OK(); }$/;"	f	class:leveldb::log::LogTest::StringDest
ForceError	db/log_test.cc	/^  void ForceError() {$/;"	f	class:leveldb::log::LogTest
IncrementByte	db/log_test.cc	/^  void IncrementByte(int offset, int delta) {$/;"	f	class:leveldb::log::LogTest
LogTest	db/log_test.cc	/^  LogTest() : reading_(false),$/;"	f	class:leveldb::log::LogTest
LogTest	db/log_test.cc	/^class LogTest {$/;"	c	namespace:leveldb::log	file:
MatchError	db/log_test.cc	/^  std::string MatchError(const std::string& msg) const {$/;"	f	class:leveldb::log::LogTest
NumberString	db/log_test.cc	/^static std::string NumberString(int n) {$/;"	f	namespace:leveldb::log
RandomSkewedString	db/log_test.cc	/^static std::string RandomSkewedString(int i, Random* rnd) {$/;"	f	namespace:leveldb::log
Read	db/log_test.cc	/^    virtual Status Read(size_t n, Slice* result, char* scratch) {$/;"	f	class:leveldb::log::LogTest::StringSource
Read	db/log_test.cc	/^  std::string Read() {$/;"	f	class:leveldb::log::LogTest
ReopenForAppend	db/log_test.cc	/^  void ReopenForAppend() {$/;"	f	class:leveldb::log::LogTest
ReportCollector	db/log_test.cc	/^    ReportCollector() : dropped_bytes_(0) { }$/;"	f	class:leveldb::log::LogTest::ReportCollector
ReportCollector	db/log_test.cc	/^  class ReportCollector : public Reader::Reporter {$/;"	c	class:leveldb::log::LogTest	file:
ReportMessage	db/log_test.cc	/^  std::string ReportMessage() const {$/;"	f	class:leveldb::log::LogTest
SetByte	db/log_test.cc	/^  void SetByte(int offset, char new_byte) {$/;"	f	class:leveldb::log::LogTest
ShrinkSize	db/log_test.cc	/^  void ShrinkSize(int bytes) {$/;"	f	class:leveldb::log::LogTest
Skip	db/log_test.cc	/^    virtual Status Skip(uint64_t n) {$/;"	f	class:leveldb::log::LogTest::StringSource
StartReadingAt	db/log_test.cc	/^  void StartReadingAt(uint64_t initial_offset) {$/;"	f	class:leveldb::log::LogTest
StringDest	db/log_test.cc	/^  class StringDest : public WritableFile {$/;"	c	class:leveldb::log::LogTest	file:
StringSource	db/log_test.cc	/^    StringSource() : force_error_(false), returned_partial_(false) { }$/;"	f	class:leveldb::log::LogTest::StringSource
StringSource	db/log_test.cc	/^  class StringSource : public SequentialFile {$/;"	c	class:leveldb::log::LogTest	file:
Sync	db/log_test.cc	/^    virtual Status Sync() { return Status::OK(); }$/;"	f	class:leveldb::log::LogTest::StringDest
TEST	db/log_test.cc	/^TEST(LogTest, AlignedEof) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, BadLength) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, BadLengthAtEndIsIgnored) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, BadRecordType) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ChecksumMismatch) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, Empty) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ErrorJoinsRecords) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, Fragmentation) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ManyBlocks) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, MarginalTrailer) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, MarginalTrailer2) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, MissingLastIsIgnored) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, OpenForAppend) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, PartialLastIsIgnored) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, RandomRead) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadEnd) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadError) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadFourthFirstBlockTrailer) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadFourthLastBlock) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadFourthMiddleBlock) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadFourthOneOff) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadFourthStart) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadInitialOffsetIntoBlockPadding) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadPastEnd) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadSecondOneOff) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadSecondStart) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadSecondTenThousand) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadStart) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadThirdOneOff) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadThirdStart) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ReadWrite) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, ShortTrailer) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, SkipIntoMultiRecord) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, TruncatedTrailingRecordIsIgnored) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, UnexpectedFirstType) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, UnexpectedFullType) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, UnexpectedLastType) {$/;"	f	namespace:leveldb::log
TEST	db/log_test.cc	/^TEST(LogTest, UnexpectedMiddleType) {$/;"	f	namespace:leveldb::log
Write	db/log_test.cc	/^  void Write(const std::string& msg) {$/;"	f	class:leveldb::log::LogTest
WriteInitialOffsetLog	db/log_test.cc	/^  void WriteInitialOffsetLog() {$/;"	f	class:leveldb::log::LogTest
WrittenBytes	db/log_test.cc	/^  size_t WrittenBytes() const {$/;"	f	class:leveldb::log::LogTest
contents_	db/log_test.cc	/^    Slice contents_;$/;"	m	class:leveldb::log::LogTest::StringSource	file:
contents_	db/log_test.cc	/^    std::string contents_;$/;"	m	class:leveldb::log::LogTest::StringDest	file:
dest_	db/log_test.cc	/^  StringDest dest_;$/;"	m	class:leveldb::log::LogTest	file:
dropped_bytes_	db/log_test.cc	/^    size_t dropped_bytes_;$/;"	m	class:leveldb::log::LogTest::ReportCollector	file:
force_error_	db/log_test.cc	/^    bool force_error_;$/;"	m	class:leveldb::log::LogTest::StringSource	file:
initial_offset_last_record_offsets_	db/log_test.cc	/^  static uint64_t initial_offset_last_record_offsets_[];$/;"	m	class:leveldb::log::LogTest	file:
initial_offset_last_record_offsets_	db/log_test.cc	/^uint64_t LogTest::initial_offset_last_record_offsets_[] =$/;"	m	class:leveldb::log::LogTest	file:
initial_offset_record_sizes_	db/log_test.cc	/^  static size_t initial_offset_record_sizes_[];$/;"	m	class:leveldb::log::LogTest	file:
initial_offset_record_sizes_	db/log_test.cc	/^size_t LogTest::initial_offset_record_sizes_[] =$/;"	m	class:leveldb::log::LogTest	file:
leveldb	db/log_test.cc	/^namespace leveldb {$/;"	n	file:
log	db/log_test.cc	/^namespace log {$/;"	n	namespace:leveldb	file:
main	db/log_test.cc	/^int main(int argc, char** argv) {$/;"	f
message_	db/log_test.cc	/^    std::string message_;$/;"	m	class:leveldb::log::LogTest::ReportCollector	file:
num_initial_offset_records_	db/log_test.cc	/^  static int num_initial_offset_records_;$/;"	m	class:leveldb::log::LogTest	file:
num_initial_offset_records_	db/log_test.cc	/^int LogTest::num_initial_offset_records_ =$/;"	m	class:leveldb::log::LogTest	file:
reader_	db/log_test.cc	/^  Reader* reader_;$/;"	m	class:leveldb::log::LogTest	file:
reading_	db/log_test.cc	/^  bool reading_;$/;"	m	class:leveldb::log::LogTest	file:
report_	db/log_test.cc	/^  ReportCollector report_;$/;"	m	class:leveldb::log::LogTest	file:
returned_partial_	db/log_test.cc	/^    bool returned_partial_;$/;"	m	class:leveldb::log::LogTest::StringSource	file:
source_	db/log_test.cc	/^  StringSource source_;$/;"	m	class:leveldb::log::LogTest	file:
writer_	db/log_test.cc	/^  Writer* writer_;$/;"	m	class:leveldb::log::LogTest	file:
~LogTest	db/log_test.cc	/^  ~LogTest() {$/;"	f	class:leveldb::log::LogTest
AddRecord	db/log_writer.cc	/^Status Writer::AddRecord(const Slice& slice) {$/;"	f	class:leveldb::log::Writer
EmitPhysicalRecord	db/log_writer.cc	/^Status Writer::EmitPhysicalRecord(RecordType t, const char* ptr, size_t n) {$/;"	f	class:leveldb::log::Writer
InitTypeCrc	db/log_writer.cc	/^static void InitTypeCrc(uint32_t* type_crc) {$/;"	f	namespace:leveldb::log
Writer	db/log_writer.cc	/^Writer::Writer(WritableFile* dest)$/;"	f	class:leveldb::log::Writer
Writer	db/log_writer.cc	/^Writer::Writer(WritableFile* dest, uint64_t dest_length)$/;"	f	class:leveldb::log::Writer
leveldb	db/log_writer.cc	/^namespace leveldb {$/;"	n	file:
log	db/log_writer.cc	/^namespace log {$/;"	n	namespace:leveldb	file:
~Writer	db/log_writer.cc	/^Writer::~Writer() {$/;"	f	class:leveldb::log::Writer
STORAGE_LEVELDB_DB_LOG_WRITER_H_	db/log_writer.h	6;"	d
Writer	db/log_writer.h	/^class Writer {$/;"	c	namespace:leveldb::log
block_offset_	db/log_writer.h	/^  int block_offset_;       \/\/ Current offset in block$/;"	m	class:leveldb::log::Writer
dest_	db/log_writer.h	/^  WritableFile* dest_;$/;"	m	class:leveldb::log::Writer
leveldb	db/log_writer.h	/^namespace leveldb {$/;"	n
log	db/log_writer.h	/^namespace log {$/;"	n	namespace:leveldb
type_crc_	db/log_writer.h	/^  uint32_t type_crc_[kMaxRecordType + 1];$/;"	m	class:leveldb::log::Writer
Add	db/memtable.cc	/^void MemTable::Add(SequenceNumber s, ValueType type,$/;"	f	class:leveldb::MemTable
ApproximateMemoryUsage	db/memtable.cc	/^size_t MemTable::ApproximateMemoryUsage() { return arena_.MemoryUsage(); }$/;"	f	class:leveldb::MemTable
EncodeKey	db/memtable.cc	/^static const char* EncodeKey(std::string* scratch, const Slice& target) {$/;"	f	namespace:leveldb
Get	db/memtable.cc	/^bool MemTable::Get(const LookupKey& key, std::string* value, Status* s) {$/;"	f	class:leveldb::MemTable
GetLengthPrefixedSlice	db/memtable.cc	/^static Slice GetLengthPrefixedSlice(const char* data) {$/;"	f	namespace:leveldb
MemTable	db/memtable.cc	/^MemTable::MemTable(const InternalKeyComparator& cmp)$/;"	f	class:leveldb::MemTable
MemTableIterator	db/memtable.cc	/^  explicit MemTableIterator(MemTable::Table* table) : iter_(table) { }$/;"	f	class:leveldb::MemTableIterator
MemTableIterator	db/memtable.cc	/^class MemTableIterator: public Iterator {$/;"	c	namespace:leveldb	file:
NewIterator	db/memtable.cc	/^Iterator* MemTable::NewIterator() {$/;"	f	class:leveldb::MemTable
Next	db/memtable.cc	/^  virtual void Next() { iter_.Next(); }$/;"	f	class:leveldb::MemTableIterator
Prev	db/memtable.cc	/^  virtual void Prev() { iter_.Prev(); }$/;"	f	class:leveldb::MemTableIterator
Seek	db/memtable.cc	/^  virtual void Seek(const Slice& k) { iter_.Seek(EncodeKey(&tmp_, k)); }$/;"	f	class:leveldb::MemTableIterator
SeekToFirst	db/memtable.cc	/^  virtual void SeekToFirst() { iter_.SeekToFirst(); }$/;"	f	class:leveldb::MemTableIterator
SeekToLast	db/memtable.cc	/^  virtual void SeekToLast() { iter_.SeekToLast(); }$/;"	f	class:leveldb::MemTableIterator
Valid	db/memtable.cc	/^  virtual bool Valid() const { return iter_.Valid(); }$/;"	f	class:leveldb::MemTableIterator
iter_	db/memtable.cc	/^  MemTable::Table::Iterator iter_;$/;"	m	class:leveldb::MemTableIterator	file:
key	db/memtable.cc	/^  virtual Slice key() const { return GetLengthPrefixedSlice(iter_.key()); }$/;"	f	class:leveldb::MemTableIterator
leveldb	db/memtable.cc	/^namespace leveldb {$/;"	n	file:
operator ()	db/memtable.cc	/^int MemTable::KeyComparator::operator()(const char* aptr, const char* bptr)$/;"	f	class:leveldb::MemTable::KeyComparator
status	db/memtable.cc	/^  virtual Status status() const { return Status::OK(); }$/;"	f	class:leveldb::MemTableIterator
tmp_	db/memtable.cc	/^  std::string tmp_;       \/\/ For passing to EncodeKey$/;"	m	class:leveldb::MemTableIterator	file:
value	db/memtable.cc	/^  virtual Slice value() const {$/;"	f	class:leveldb::MemTableIterator
~MemTable	db/memtable.cc	/^MemTable::~MemTable() {$/;"	f	class:leveldb::MemTable
KeyComparator	db/memtable.h	/^    explicit KeyComparator(const InternalKeyComparator& c) : comparator(c) { }$/;"	f	struct:leveldb::MemTable::KeyComparator
KeyComparator	db/memtable.h	/^  struct KeyComparator {$/;"	s	class:leveldb::MemTable
MemTable	db/memtable.h	/^class MemTable {$/;"	c	namespace:leveldb
Ref	db/memtable.h	/^  void Ref() { ++refs_; }$/;"	f	class:leveldb::MemTable
STORAGE_LEVELDB_DB_MEMTABLE_H_	db/memtable.h	6;"	d
Table	db/memtable.h	/^  typedef SkipList<const char*, KeyComparator> Table;$/;"	t	class:leveldb::MemTable
Unref	db/memtable.h	/^  void Unref() {$/;"	f	class:leveldb::MemTable
arena_	db/memtable.h	/^  Arena arena_;$/;"	m	class:leveldb::MemTable
comparator	db/memtable.h	/^    const InternalKeyComparator comparator;$/;"	m	struct:leveldb::MemTable::KeyComparator
comparator_	db/memtable.h	/^  KeyComparator comparator_;$/;"	m	class:leveldb::MemTable
leveldb	db/memtable.h	/^namespace leveldb {$/;"	n
refs_	db/memtable.h	/^  int refs_;$/;"	m	class:leveldb::MemTable
table_	db/memtable.h	/^  Table table_;$/;"	m	class:leveldb::MemTable
CanAppend	db/recovery_test.cc	/^  bool CanAppend() {$/;"	f	class:leveldb::RecoveryTest
Close	db/recovery_test.cc	/^  void Close() {$/;"	f	class:leveldb::RecoveryTest
CompactMemTable	db/recovery_test.cc	/^  void CompactMemTable() {$/;"	f	class:leveldb::RecoveryTest
DeleteLogFiles	db/recovery_test.cc	/^  size_t DeleteLogFiles() {$/;"	f	class:leveldb::RecoveryTest
DeleteManifestFile	db/recovery_test.cc	/^  void DeleteManifestFile() {$/;"	f	class:leveldb::RecoveryTest
FileSize	db/recovery_test.cc	/^  uint64_t FileSize(const std::string& fname) {$/;"	f	class:leveldb::RecoveryTest
FirstLogFile	db/recovery_test.cc	/^  uint64_t FirstLogFile() {$/;"	f	class:leveldb::RecoveryTest
Get	db/recovery_test.cc	/^  std::string Get(const std::string& k, const Snapshot* snapshot = NULL) {$/;"	f	class:leveldb::RecoveryTest
GetFiles	db/recovery_test.cc	/^  std::vector<uint64_t> GetFiles(FileType t) {$/;"	f	class:leveldb::RecoveryTest
LogName	db/recovery_test.cc	/^  std::string LogName(uint64_t number) {$/;"	f	class:leveldb::RecoveryTest
MakeLogFile	db/recovery_test.cc	/^  void MakeLogFile(uint64_t lognum, SequenceNumber seq, Slice key, Slice val) {$/;"	f	class:leveldb::RecoveryTest
ManifestFileName	db/recovery_test.cc	/^  std::string ManifestFileName() {$/;"	f	class:leveldb::RecoveryTest
NumLogs	db/recovery_test.cc	/^  int NumLogs() {$/;"	f	class:leveldb::RecoveryTest
NumTables	db/recovery_test.cc	/^  int NumTables() {$/;"	f	class:leveldb::RecoveryTest
Open	db/recovery_test.cc	/^  void Open(Options* options = NULL) {$/;"	f	class:leveldb::RecoveryTest
OpenWithStatus	db/recovery_test.cc	/^  Status OpenWithStatus(Options* options = NULL) {$/;"	f	class:leveldb::RecoveryTest
Put	db/recovery_test.cc	/^  Status Put(const std::string& k, const std::string& v) {$/;"	f	class:leveldb::RecoveryTest
RecoveryTest	db/recovery_test.cc	/^  RecoveryTest() : env_(Env::Default()), db_(NULL) {$/;"	f	class:leveldb::RecoveryTest
RecoveryTest	db/recovery_test.cc	/^class RecoveryTest {$/;"	c	namespace:leveldb	file:
TEST	db/recovery_test.cc	/^TEST(RecoveryTest, LargeManifestCompacted) {$/;"	f	namespace:leveldb
TEST	db/recovery_test.cc	/^TEST(RecoveryTest, LogFileReuse) {$/;"	f	namespace:leveldb
TEST	db/recovery_test.cc	/^TEST(RecoveryTest, ManifestMissing) {$/;"	f	namespace:leveldb
TEST	db/recovery_test.cc	/^TEST(RecoveryTest, ManifestReused) {$/;"	f	namespace:leveldb
TEST	db/recovery_test.cc	/^TEST(RecoveryTest, MultipleLogFiles) {$/;"	f	namespace:leveldb
TEST	db/recovery_test.cc	/^TEST(RecoveryTest, MultipleMemTables) {$/;"	f	namespace:leveldb
TEST	db/recovery_test.cc	/^TEST(RecoveryTest, NoLogFiles) {$/;"	f	namespace:leveldb
db_	db/recovery_test.cc	/^  DB* db_;$/;"	m	class:leveldb::RecoveryTest	file:
dbfull	db/recovery_test.cc	/^  DBImpl* dbfull() const { return reinterpret_cast<DBImpl*>(db_); }$/;"	f	class:leveldb::RecoveryTest
dbname_	db/recovery_test.cc	/^  std::string dbname_;$/;"	m	class:leveldb::RecoveryTest	file:
env	db/recovery_test.cc	/^  Env* env() const { return env_; }$/;"	f	class:leveldb::RecoveryTest
env_	db/recovery_test.cc	/^  Env* env_;$/;"	m	class:leveldb::RecoveryTest	file:
leveldb	db/recovery_test.cc	/^namespace leveldb {$/;"	n	file:
main	db/recovery_test.cc	/^int main(int argc, char** argv) {$/;"	f
~RecoveryTest	db/recovery_test.cc	/^  ~RecoveryTest() {$/;"	f	class:leveldb::RecoveryTest
ArchiveFile	db/repair.cc	/^  void ArchiveFile(const std::string& fname) {$/;"	f	class:leveldb::__anon6::Repairer	file:
ConvertLogFilesToTables	db/repair.cc	/^  void ConvertLogFilesToTables() {$/;"	f	class:leveldb::__anon6::Repairer	file:
ConvertLogToTable	db/repair.cc	/^  Status ConvertLogToTable(uint64_t log) {$/;"	f	class:leveldb::__anon6::Repairer	file:
ExtractMetaData	db/repair.cc	/^  void ExtractMetaData() {$/;"	f	class:leveldb::__anon6::Repairer	file:
FindFiles	db/repair.cc	/^  Status FindFiles() {$/;"	f	class:leveldb::__anon6::Repairer	file:
NewTableIterator	db/repair.cc	/^  Iterator* NewTableIterator(const FileMetaData& meta) {$/;"	f	class:leveldb::__anon6::Repairer	file:
RepairDB	db/repair.cc	/^Status RepairDB(const std::string& dbname, const Options& options) {$/;"	f	namespace:leveldb
RepairTable	db/repair.cc	/^  void RepairTable(const std::string& src, TableInfo t) {$/;"	f	class:leveldb::__anon6::Repairer	file:
Repairer	db/repair.cc	/^  Repairer(const std::string& dbname, const Options& options)$/;"	f	class:leveldb::__anon6::Repairer
Repairer	db/repair.cc	/^class Repairer {$/;"	c	namespace:leveldb::__anon6	file:
Run	db/repair.cc	/^  Status Run() {$/;"	f	class:leveldb::__anon6::Repairer
ScanTable	db/repair.cc	/^  void ScanTable(uint64_t number) {$/;"	f	class:leveldb::__anon6::Repairer	file:
TableInfo	db/repair.cc	/^  struct TableInfo {$/;"	s	class:leveldb::__anon6::Repairer	file:
WriteDescriptor	db/repair.cc	/^  Status WriteDescriptor() {$/;"	f	class:leveldb::__anon6::Repairer	file:
dbname_	db/repair.cc	/^  std::string const dbname_;$/;"	m	class:leveldb::__anon6::Repairer::std	file:
edit_	db/repair.cc	/^  VersionEdit edit_;$/;"	m	class:leveldb::__anon6::Repairer	file:
env_	db/repair.cc	/^  Env* const env_;$/;"	m	class:leveldb::__anon6::Repairer	file:
icmp_	db/repair.cc	/^  InternalKeyComparator const icmp_;$/;"	m	class:leveldb::__anon6::Repairer	file:
ipolicy_	db/repair.cc	/^  InternalFilterPolicy const ipolicy_;$/;"	m	class:leveldb::__anon6::Repairer	file:
leveldb	db/repair.cc	/^namespace leveldb {$/;"	n	file:
logs_	db/repair.cc	/^  std::vector<uint64_t> logs_;$/;"	m	class:leveldb::__anon6::Repairer	file:
manifests_	db/repair.cc	/^  std::vector<std::string> manifests_;$/;"	m	class:leveldb::__anon6::Repairer	file:
max_sequence	db/repair.cc	/^    SequenceNumber max_sequence;$/;"	m	struct:leveldb::__anon6::Repairer::TableInfo	file:
meta	db/repair.cc	/^    FileMetaData meta;$/;"	m	struct:leveldb::__anon6::Repairer::TableInfo	file:
next_file_number_	db/repair.cc	/^  uint64_t next_file_number_;$/;"	m	class:leveldb::__anon6::Repairer	file:
options_	db/repair.cc	/^  Options const options_;$/;"	m	class:leveldb::__anon6::Repairer	file:
owns_cache_	db/repair.cc	/^  bool owns_cache_;$/;"	m	class:leveldb::__anon6::Repairer	file:
owns_info_log_	db/repair.cc	/^  bool owns_info_log_;$/;"	m	class:leveldb::__anon6::Repairer	file:
table_cache_	db/repair.cc	/^  TableCache* table_cache_;$/;"	m	class:leveldb::__anon6::Repairer	file:
table_numbers_	db/repair.cc	/^  std::vector<uint64_t> table_numbers_;$/;"	m	class:leveldb::__anon6::Repairer	file:
tables_	db/repair.cc	/^  std::vector<TableInfo> tables_;$/;"	m	class:leveldb::__anon6::Repairer	file:
~Repairer	db/repair.cc	/^  ~Repairer() {$/;"	f	class:leveldb::__anon6::Repairer
Contains	db/skiplist.h	/^bool SkipList<Key,Comparator>::Contains(const Key& key) const {$/;"	f	class:leveldb::SkipList
Equal	db/skiplist.h	/^  bool Equal(const Key& a, const Key& b) const { return (compare_(a, b) == 0); }$/;"	f	class:leveldb::SkipList
FindGreaterOrEqual	db/skiplist.h	/^typename SkipList<Key,Comparator>::Node* SkipList<Key,Comparator>::FindGreaterOrEqual(const Key& key, Node** prev)$/;"	f	class:leveldb::SkipList
FindLast	db/skiplist.h	/^typename SkipList<Key,Comparator>::Node* SkipList<Key,Comparator>::FindLast()$/;"	f	class:leveldb::SkipList
FindLessThan	db/skiplist.h	/^SkipList<Key,Comparator>::FindLessThan(const Key& key) const {$/;"	f	class:leveldb::SkipList
GetMaxHeight	db/skiplist.h	/^  inline int GetMaxHeight() const {$/;"	f	class:leveldb::SkipList
Insert	db/skiplist.h	/^void SkipList<Key,Comparator>::Insert(const Key& key) {$/;"	f	class:leveldb::SkipList
Iterator	db/skiplist.h	/^  class Iterator {$/;"	c	class:leveldb::SkipList
Iterator	db/skiplist.h	/^inline SkipList<Key,Comparator>::Iterator::Iterator(const SkipList* list) {$/;"	f	class:leveldb::SkipList::Iterator
KeyIsAfterNode	db/skiplist.h	/^bool SkipList<Key,Comparator>::KeyIsAfterNode(const Key& key, Node* n) const {$/;"	f	class:leveldb::SkipList
NewNode	db/skiplist.h	/^SkipList<Key,Comparator>::NewNode(const Key& key, int height) {$/;"	f	class:leveldb::SkipList
Next	db/skiplist.h	/^  Node* Next(int n) {$/;"	f	struct:leveldb::SkipList::Node
Next	db/skiplist.h	/^inline void SkipList<Key,Comparator>::Iterator::Next() {$/;"	f	class:leveldb::SkipList::Iterator
NoBarrier_Next	db/skiplist.h	/^  Node* NoBarrier_Next(int n) {$/;"	f	struct:leveldb::SkipList::Node
NoBarrier_SetNext	db/skiplist.h	/^  void NoBarrier_SetNext(int n, Node* x) {$/;"	f	struct:leveldb::SkipList::Node
Node	db/skiplist.h	/^  explicit Node(const Key& k) : key(k) { }$/;"	f	struct:leveldb::SkipList::Node
Node	db/skiplist.h	/^struct SkipList<Key,Comparator>::Node {$/;"	s	class:leveldb::SkipList
Prev	db/skiplist.h	/^inline void SkipList<Key,Comparator>::Iterator::Prev() {$/;"	f	class:leveldb::SkipList::Iterator
RandomHeight	db/skiplist.h	/^int SkipList<Key,Comparator>::RandomHeight() {$/;"	f	class:leveldb::SkipList
STORAGE_LEVELDB_DB_SKIPLIST_H_	db/skiplist.h	6;"	d
Seek	db/skiplist.h	/^inline void SkipList<Key,Comparator>::Iterator::Seek(const Key& target) {$/;"	f	class:leveldb::SkipList::Iterator
SeekToFirst	db/skiplist.h	/^inline void SkipList<Key,Comparator>::Iterator::SeekToFirst() {$/;"	f	class:leveldb::SkipList::Iterator
SeekToLast	db/skiplist.h	/^inline void SkipList<Key,Comparator>::Iterator::SeekToLast() {$/;"	f	class:leveldb::SkipList::Iterator
SetNext	db/skiplist.h	/^  void SetNext(int n, Node* x) {$/;"	f	struct:leveldb::SkipList::Node
SkipList	db/skiplist.h	/^SkipList<Key,Comparator>::SkipList(Comparator cmp, Arena* arena)$/;"	f	class:leveldb::SkipList
SkipList	db/skiplist.h	/^class SkipList {$/;"	c	namespace:leveldb
Valid	db/skiplist.h	/^inline bool SkipList<Key,Comparator>::Iterator::Valid() const {$/;"	f	class:leveldb::SkipList::Iterator
arena_	db/skiplist.h	/^  Arena* const arena_;    \/\/ Arena used for allocations of nodes$/;"	m	class:leveldb::SkipList
compare_	db/skiplist.h	/^  Comparator const compare_;$/;"	m	class:leveldb::SkipList
head_	db/skiplist.h	/^  Node* const head_;$/;"	m	class:leveldb::SkipList
kMaxHeight	db/skiplist.h	/^  enum { kMaxHeight = 12 };$/;"	e	enum:leveldb::SkipList::__anon7
key	db/skiplist.h	/^  Key const key;$/;"	m	struct:leveldb::SkipList::Node
key	db/skiplist.h	/^inline const Key& SkipList<Key,Comparator>::Iterator::key() const {$/;"	f	class:leveldb::SkipList::Iterator
leveldb	db/skiplist.h	/^namespace leveldb {$/;"	n
list_	db/skiplist.h	/^    const SkipList* list_;$/;"	m	class:leveldb::SkipList::Iterator
max_height_	db/skiplist.h	/^  port::AtomicPointer max_height_;   \/\/ Height of the entire list$/;"	m	class:leveldb::SkipList
next_	db/skiplist.h	/^  port::AtomicPointer next_[1];$/;"	m	struct:leveldb::SkipList::Node
node_	db/skiplist.h	/^    Node* node_;$/;"	m	class:leveldb::SkipList::Iterator
rnd_	db/skiplist.h	/^  Random rnd_;$/;"	m	class:leveldb::SkipList
Change	db/skiplist_test.cc	/^  void Change(ReaderState s) {$/;"	f	class:leveldb::TestState
Comparator	db/skiplist_test.cc	/^struct Comparator {$/;"	s	namespace:leveldb	file:
ConcurrentReader	db/skiplist_test.cc	/^static void ConcurrentReader(void* arg) {$/;"	f	namespace:leveldb
ConcurrentTest	db/skiplist_test.cc	/^  ConcurrentTest() : list_(Comparator(), &arena_) { }$/;"	f	class:leveldb::ConcurrentTest
ConcurrentTest	db/skiplist_test.cc	/^class ConcurrentTest {$/;"	c	namespace:leveldb	file:
DONE	db/skiplist_test.cc	/^    DONE$/;"	e	enum:leveldb::TestState::ReaderState	file:
Get	db/skiplist_test.cc	/^    intptr_t Get(int k) {$/;"	f	struct:leveldb::ConcurrentTest::State
HashNumbers	db/skiplist_test.cc	/^  static uint64_t HashNumbers(uint64_t k, uint64_t g) {$/;"	f	class:leveldb::ConcurrentTest	file:
IsValidKey	db/skiplist_test.cc	/^  static bool IsValidKey(Key k) {$/;"	f	class:leveldb::ConcurrentTest	file:
K	db/skiplist_test.cc	/^  static const uint32_t K = 4;$/;"	m	class:leveldb::ConcurrentTest	file:
K	db/skiplist_test.cc	/^const uint32_t ConcurrentTest::K;$/;"	m	class:leveldb::ConcurrentTest	file:
Key	db/skiplist_test.cc	/^typedef uint64_t Key;$/;"	t	namespace:leveldb	file:
MakeKey	db/skiplist_test.cc	/^  static Key MakeKey(uint64_t k, uint64_t g) {$/;"	f	class:leveldb::ConcurrentTest	file:
RUNNING	db/skiplist_test.cc	/^    RUNNING,$/;"	e	enum:leveldb::TestState::ReaderState	file:
RandomTarget	db/skiplist_test.cc	/^  static Key RandomTarget(Random* rnd) {$/;"	f	class:leveldb::ConcurrentTest	file:
ReadStep	db/skiplist_test.cc	/^  void ReadStep(Random* rnd) {$/;"	f	class:leveldb::ConcurrentTest
ReaderState	db/skiplist_test.cc	/^  enum ReaderState {$/;"	g	class:leveldb::TestState	file:
RunConcurrent	db/skiplist_test.cc	/^static void RunConcurrent(int run) {$/;"	f	namespace:leveldb
STARTING	db/skiplist_test.cc	/^    STARTING,$/;"	e	enum:leveldb::TestState::ReaderState	file:
Set	db/skiplist_test.cc	/^    void Set(int k, intptr_t v) {$/;"	f	struct:leveldb::ConcurrentTest::State
SkipTest	db/skiplist_test.cc	/^class SkipTest { };$/;"	c	namespace:leveldb	file:
State	db/skiplist_test.cc	/^    State() {$/;"	f	struct:leveldb::ConcurrentTest::State
State	db/skiplist_test.cc	/^  struct State {$/;"	s	class:leveldb::ConcurrentTest	file:
TEST	db/skiplist_test.cc	/^TEST(SkipTest, Concurrent1) { RunConcurrent(1); }$/;"	f	namespace:leveldb
TEST	db/skiplist_test.cc	/^TEST(SkipTest, Concurrent2) { RunConcurrent(2); }$/;"	f	namespace:leveldb
TEST	db/skiplist_test.cc	/^TEST(SkipTest, Concurrent3) { RunConcurrent(3); }$/;"	f	namespace:leveldb
TEST	db/skiplist_test.cc	/^TEST(SkipTest, Concurrent4) { RunConcurrent(4); }$/;"	f	namespace:leveldb
TEST	db/skiplist_test.cc	/^TEST(SkipTest, Concurrent5) { RunConcurrent(5); }$/;"	f	namespace:leveldb
TEST	db/skiplist_test.cc	/^TEST(SkipTest, ConcurrentWithoutThreads) {$/;"	f	namespace:leveldb
TEST	db/skiplist_test.cc	/^TEST(SkipTest, Empty) {$/;"	f	namespace:leveldb
TEST	db/skiplist_test.cc	/^TEST(SkipTest, InsertAndLookup) {$/;"	f	namespace:leveldb
TestState	db/skiplist_test.cc	/^  explicit TestState(int s)$/;"	f	class:leveldb::TestState
TestState	db/skiplist_test.cc	/^class TestState {$/;"	c	namespace:leveldb	file:
Wait	db/skiplist_test.cc	/^  void Wait(ReaderState s) {$/;"	f	class:leveldb::TestState
WriteStep	db/skiplist_test.cc	/^  void WriteStep(Random* rnd) {$/;"	f	class:leveldb::ConcurrentTest
arena_	db/skiplist_test.cc	/^  Arena arena_;$/;"	m	class:leveldb::ConcurrentTest	file:
current_	db/skiplist_test.cc	/^  State current_;$/;"	m	class:leveldb::ConcurrentTest	file:
gen	db/skiplist_test.cc	/^  static uint64_t gen(Key key) { return (key >> 8) & 0xffffffffu; }$/;"	f	class:leveldb::ConcurrentTest	file:
generation	db/skiplist_test.cc	/^    port::AtomicPointer generation[K];$/;"	m	struct:leveldb::ConcurrentTest::State	file:
hash	db/skiplist_test.cc	/^  static uint64_t hash(Key key) { return key & 0xff; }$/;"	f	class:leveldb::ConcurrentTest	file:
key	db/skiplist_test.cc	/^  static uint64_t key(Key key) { return (key >> 40); }$/;"	f	class:leveldb::ConcurrentTest	file:
leveldb	db/skiplist_test.cc	/^namespace leveldb {$/;"	n	file:
list_	db/skiplist_test.cc	/^  SkipList<Key, Comparator> list_;$/;"	m	class:leveldb::ConcurrentTest	file:
main	db/skiplist_test.cc	/^int main(int argc, char** argv) {$/;"	f
mu_	db/skiplist_test.cc	/^  port::Mutex mu_;$/;"	m	class:leveldb::TestState	file:
operator ()	db/skiplist_test.cc	/^  int operator()(const Key& a, const Key& b) const {$/;"	f	struct:leveldb::Comparator
quit_flag_	db/skiplist_test.cc	/^  port::AtomicPointer quit_flag_;$/;"	m	class:leveldb::TestState	file:
seed_	db/skiplist_test.cc	/^  int seed_;$/;"	m	class:leveldb::TestState	file:
state_	db/skiplist_test.cc	/^  ReaderState state_;$/;"	m	class:leveldb::TestState	file:
state_cv_	db/skiplist_test.cc	/^  port::CondVar state_cv_;$/;"	m	class:leveldb::TestState	file:
t_	db/skiplist_test.cc	/^  ConcurrentTest t_;$/;"	m	class:leveldb::TestState	file:
Delete	db/snapshot.h	/^  void Delete(const SnapshotImpl* s) {$/;"	f	class:leveldb::SnapshotList
New	db/snapshot.h	/^  const SnapshotImpl* New(SequenceNumber seq) {$/;"	f	class:leveldb::SnapshotList
STORAGE_LEVELDB_DB_SNAPSHOT_H_	db/snapshot.h	6;"	d
SnapshotImpl	db/snapshot.h	/^class SnapshotImpl : public Snapshot {$/;"	c	namespace:leveldb
SnapshotList	db/snapshot.h	/^  SnapshotList() {$/;"	f	class:leveldb::SnapshotList
SnapshotList	db/snapshot.h	/^class SnapshotList {$/;"	c	namespace:leveldb
empty	db/snapshot.h	/^  bool empty() const { return list_.next_ == &list_; }$/;"	f	class:leveldb::SnapshotList
leveldb	db/snapshot.h	/^namespace leveldb {$/;"	n
list_	db/snapshot.h	/^  SnapshotImpl list_;$/;"	m	class:leveldb::SnapshotList
list_	db/snapshot.h	/^  SnapshotList* list_;                 \/\/ just for sanity checks$/;"	m	class:leveldb::SnapshotImpl
newest	db/snapshot.h	/^  SnapshotImpl* newest() const { assert(!empty()); return list_.prev_; }$/;"	f	class:leveldb::SnapshotList
next_	db/snapshot.h	/^  SnapshotImpl* next_;$/;"	m	class:leveldb::SnapshotImpl
number_	db/snapshot.h	/^  SequenceNumber number_;  \/\/ const after creation$/;"	m	class:leveldb::SnapshotImpl
oldest	db/snapshot.h	/^  SnapshotImpl* oldest() const { assert(!empty()); return list_.next_; }$/;"	f	class:leveldb::SnapshotList
prev_	db/snapshot.h	/^  SnapshotImpl* prev_;$/;"	m	class:leveldb::SnapshotImpl
DeleteEntry	db/table_cache.cc	/^static void DeleteEntry(const Slice& key, void* value) {$/;"	f	namespace:leveldb
DeleteEntry	db/table_cache.cc	/^static void DeleteEntry(void* arg1, void* arg2) {$/;"	f	namespace:leveldb
Evict	db/table_cache.cc	/^void TableCache::Evict(uint64_t file_number) {$/;"	f	class:leveldb::TableCache
FindBufferedTable	db/table_cache.cc	/^Status TableCache::FindBufferedTable(uint64_t file_number, uint64_t file_size,$/;"	f	class:leveldb::TableCache
FindTable	db/table_cache.cc	/^Status TableCache::FindTable(uint64_t file_number, uint64_t file_size,$/;"	f	class:leveldb::TableCache
Get	db/table_cache.cc	/^Status TableCache::Get(const ReadOptions& options,$/;"	f	class:leveldb::TableCache
GetTableCurrFiltersSize	db/table_cache.cc	/^size_t TableCache::GetTableCurrFiltersSize(uint64_t file_number,uint64_t file_size){$/;"	f	class:leveldb::TableCache
LRU_Status	db/table_cache.cc	/^std::string TableCache::LRU_Status()$/;"	f	class:leveldb::TableCache
LookupFreCount	db/table_cache.cc	/^uint64_t TableCache::LookupFreCount(uint64_t file_number)$/;"	f	class:leveldb::TableCache
NewBufferedIterator	db/table_cache.cc	/^Iterator* TableCache::NewBufferedIterator(const ReadOptions& options,$/;"	f	class:leveldb::TableCache
NewIterator	db/table_cache.cc	/^Iterator* TableCache::NewIterator(const ReadOptions& options,$/;"	f	class:leveldb::TableCache
SaveLevel0Freq	db/table_cache.cc	/^void TableCache::SaveLevel0Freq(uint64_t file_number) {$/;"	f	class:leveldb::TableCache
SetFreCount	db/table_cache.cc	/^void TableCache::SetFreCount(uint64_t file_number, uint64_t freCount)$/;"	f	class:leveldb::TableCache
TableCache	db/table_cache.cc	/^TableCache::TableCache(const std::string& dbname,$/;"	f	class:leveldb::TableCache
TurnOffAdjustment	db/table_cache.cc	/^void TableCache::TurnOffAdjustment() {$/;"	f	class:leveldb::TableCache
TurnOnAdjustment	db/table_cache.cc	/^void TableCache::TurnOnAdjustment() {$/;"	f	class:leveldb::TableCache
UnrefEntry	db/table_cache.cc	/^static void UnrefEntry(void* arg1, void* arg2) {$/;"	f	namespace:leveldb
adjustFilters	db/table_cache.cc	/^void TableCache::adjustFilters(uint64_t file_number, uint64_t file_size,int n)$/;"	f	class:leveldb::TableCache
directIO_of_RandomAccess	db/table_cache.cc	/^bool directIO_of_RandomAccess = false;$/;"	m	namespace:leveldb	file:
leveldb	db/table_cache.cc	/^namespace leveldb {$/;"	n	file:
~TableCache	db/table_cache.cc	/^TableCache::~TableCache() {$/;"	f	class:leveldb::TableCache
STORAGE_LEVELDB_DB_TABLE_CACHE_H_	db/table_cache.h	8;"	d
TableAndFile	db/table_cache.h	/^struct TableAndFile {$/;"	s	namespace:leveldb
TableCache	db/table_cache.h	/^class TableCache {$/;"	c	namespace:leveldb
cache_	db/table_cache.h	/^  Cache* cache_;$/;"	m	class:leveldb::TableCache
dbname_	db/table_cache.h	/^  const std::string dbname_;$/;"	m	class:leveldb::TableCache
env_	db/table_cache.h	/^  Env* const env_;$/;"	m	class:leveldb::TableCache
file	db/table_cache.h	/^  RandomAccessFile* file;$/;"	m	struct:leveldb::TableAndFile
getCacheValue	db/table_cache.h	/^  void *getCacheValue(Cache::Handle* handle) {return cache_->Value(handle);}$/;"	f	class:leveldb::TableCache
level0_freq	db/table_cache.h	/^  uint64_t level0_freq;$/;"	m	class:leveldb::TableCache
leveldb	db/table_cache.h	/^namespace leveldb {$/;"	n
options_	db/table_cache.h	/^  const Options* options_;$/;"	m	class:leveldb::TableCache
refs	db/table_cache.h	/^  uint32_t refs;$/;"	m	struct:leveldb::TableAndFile
releaseCacheHandle	db/table_cache.h	/^  void releaseCacheHandle(Cache::Handle* handle) {cache_->Release(handle);}$/;"	f	class:leveldb::TableCache
table	db/table_cache.h	/^  Table* table;$/;"	m	struct:leveldb::TableAndFile
Clear	db/version_edit.cc	/^void VersionEdit::Clear() {$/;"	f	class:leveldb::VersionEdit
DebugString	db/version_edit.cc	/^std::string VersionEdit::DebugString() const {$/;"	f	class:leveldb::VersionEdit
DecodeFrom	db/version_edit.cc	/^Status VersionEdit::DecodeFrom(const Slice& src) {$/;"	f	class:leveldb::VersionEdit
EncodeTo	db/version_edit.cc	/^void VersionEdit::EncodeTo(std::string* dst) const {$/;"	f	class:leveldb::VersionEdit
GetInternalKey	db/version_edit.cc	/^static bool GetInternalKey(Slice* input, InternalKey* dst) {$/;"	f	namespace:leveldb
GetLevel	db/version_edit.cc	/^static bool GetLevel(Slice* input, int* level) {$/;"	f	namespace:leveldb
Tag	db/version_edit.cc	/^enum Tag {$/;"	g	namespace:leveldb	file:
kCompactPointer	db/version_edit.cc	/^  kCompactPointer       = 5,$/;"	e	enum:leveldb::Tag	file:
kComparator	db/version_edit.cc	/^  kComparator           = 1,$/;"	e	enum:leveldb::Tag	file:
kDeletedFile	db/version_edit.cc	/^  kDeletedFile          = 6,$/;"	e	enum:leveldb::Tag	file:
kLastSequence	db/version_edit.cc	/^  kLastSequence         = 4,$/;"	e	enum:leveldb::Tag	file:
kLogNumber	db/version_edit.cc	/^  kLogNumber            = 2,$/;"	e	enum:leveldb::Tag	file:
kNewFile	db/version_edit.cc	/^  kNewFile              = 7,$/;"	e	enum:leveldb::Tag	file:
kNextFileNumber	db/version_edit.cc	/^  kNextFileNumber       = 3,$/;"	e	enum:leveldb::Tag	file:
kPrevLogNumber	db/version_edit.cc	/^  kPrevLogNumber        = 9$/;"	e	enum:leveldb::Tag	file:
leveldb	db/version_edit.cc	/^namespace leveldb {$/;"	n	file:
AddFile	db/version_edit.h	/^  void AddFile(int level, uint64_t file,$/;"	f	class:leveldb::VersionEdit
DeleteFile	db/version_edit.h	/^  void DeleteFile(int level, uint64_t file) {$/;"	f	class:leveldb::VersionEdit
DeletedFileSet	db/version_edit.h	/^  typedef std::set< std::pair<int, uint64_t> > DeletedFileSet;$/;"	t	class:leveldb::VersionEdit
FileExtraMetaData	db/version_edit.h	/^  FileExtraMetaData() : is_compacted(false), latency_sum(0), count(0){}$/;"	f	struct:leveldb::FileExtraMetaData
FileExtraMetaData	db/version_edit.h	/^struct FileExtraMetaData {$/;"	s	namespace:leveldb
FileMetaData	db/version_edit.h	/^  FileMetaData() : refs(0), allowed_seeks(1 << 30), file_size(0),access_time(0){}$/;"	f	struct:leveldb::FileMetaData
FileMetaData	db/version_edit.h	/^struct FileMetaData {$/;"	s	namespace:leveldb
STORAGE_LEVELDB_DB_VERSION_EDIT_H_	db/version_edit.h	6;"	d
SetCompactPointer	db/version_edit.h	/^  void SetCompactPointer(int level, const InternalKey& key) {$/;"	f	class:leveldb::VersionEdit
SetComparatorName	db/version_edit.h	/^  void SetComparatorName(const Slice& name) {$/;"	f	class:leveldb::VersionEdit
SetLastSequence	db/version_edit.h	/^  void SetLastSequence(SequenceNumber seq) {$/;"	f	class:leveldb::VersionEdit
SetLogNumber	db/version_edit.h	/^  void SetLogNumber(uint64_t num) {$/;"	f	class:leveldb::VersionEdit
SetNextFile	db/version_edit.h	/^  void SetNextFile(uint64_t num) {$/;"	f	class:leveldb::VersionEdit
SetPrevLogNumber	db/version_edit.h	/^  void SetPrevLogNumber(uint64_t num) {$/;"	f	class:leveldb::VersionEdit
VersionEdit	db/version_edit.h	/^  VersionEdit() { Clear(); }$/;"	f	class:leveldb::VersionEdit
VersionEdit	db/version_edit.h	/^class VersionEdit {$/;"	c	namespace:leveldb
access_time	db/version_edit.h	/^  int access_time;			\/\/file access_time in Get request$/;"	m	struct:leveldb::FileMetaData
allowed_seeks	db/version_edit.h	/^  int allowed_seeks;          \/\/ Seeks allowed until compaction$/;"	m	struct:leveldb::FileMetaData
compact_pointers_	db/version_edit.h	/^  std::vector< std::pair<int, InternalKey> > compact_pointers_;$/;"	m	class:leveldb::VersionEdit
comparator_	db/version_edit.h	/^  std::string comparator_;$/;"	m	class:leveldb::VersionEdit
count	db/version_edit.h	/^  uint64_t count;$/;"	m	struct:leveldb::FileExtraMetaData
deleted_files_	db/version_edit.h	/^  DeletedFileSet deleted_files_;$/;"	m	class:leveldb::VersionEdit
file_size	db/version_edit.h	/^  uint64_t file_size;         \/\/ File size in bytes$/;"	m	struct:leveldb::FileMetaData
has_comparator_	db/version_edit.h	/^  bool has_comparator_;$/;"	m	class:leveldb::VersionEdit
has_last_sequence_	db/version_edit.h	/^  bool has_last_sequence_;$/;"	m	class:leveldb::VersionEdit
has_log_number_	db/version_edit.h	/^  bool has_log_number_;$/;"	m	class:leveldb::VersionEdit
has_next_file_number_	db/version_edit.h	/^  bool has_next_file_number_;$/;"	m	class:leveldb::VersionEdit
has_prev_log_number_	db/version_edit.h	/^  bool has_prev_log_number_;$/;"	m	class:leveldb::VersionEdit
is_compacted	db/version_edit.h	/^  bool is_compacted;$/;"	m	struct:leveldb::FileExtraMetaData
largest	db/version_edit.h	/^  InternalKey largest;        \/\/ Largest internal key served by table$/;"	m	struct:leveldb::FileMetaData
last_sequence_	db/version_edit.h	/^  SequenceNumber last_sequence_;$/;"	m	class:leveldb::VersionEdit
latency_sum	db/version_edit.h	/^  uint64_t latency_sum;$/;"	m	struct:leveldb::FileExtraMetaData
leveldb	db/version_edit.h	/^namespace leveldb {$/;"	n
log_number_	db/version_edit.h	/^  uint64_t log_number_;$/;"	m	class:leveldb::VersionEdit
new_files_	db/version_edit.h	/^  std::vector< std::pair<int, FileMetaData> > new_files_;$/;"	m	class:leveldb::VersionEdit
next_file_number_	db/version_edit.h	/^  uint64_t next_file_number_;$/;"	m	class:leveldb::VersionEdit
number	db/version_edit.h	/^  uint64_t number;$/;"	m	struct:leveldb::FileMetaData
prev_log_number_	db/version_edit.h	/^  uint64_t prev_log_number_;$/;"	m	class:leveldb::VersionEdit
refs	db/version_edit.h	/^  int refs;$/;"	m	struct:leveldb::FileMetaData
smallest	db/version_edit.h	/^  InternalKey smallest;       \/\/ Smallest internal key served by table$/;"	m	struct:leveldb::FileMetaData
~VersionEdit	db/version_edit.h	/^  ~VersionEdit() { }$/;"	f	class:leveldb::VersionEdit
TEST	db/version_edit_test.cc	/^TEST(VersionEditTest, EncodeDecode) {$/;"	f	namespace:leveldb
TestEncodeDecode	db/version_edit_test.cc	/^static void TestEncodeDecode(const VersionEdit& edit) {$/;"	f	namespace:leveldb
VersionEditTest	db/version_edit_test.cc	/^class VersionEditTest { };$/;"	c	namespace:leveldb	file:
leveldb	db/version_edit_test.cc	/^namespace leveldb {$/;"	n	file:
main	db/version_edit_test.cc	/^int main(int argc, char** argv) {$/;"	f
AddInputDeletions	db/version_set.cc	/^void Compaction::AddInputDeletions(VersionEdit* edit) {$/;"	f	class:leveldb::Compaction
AddIterators	db/version_set.cc	/^void Version::AddIterators(const ReadOptions& options,$/;"	f	class:leveldb::Version
AddLiveFiles	db/version_set.cc	/^void VersionSet::AddLiveFiles(std::set<uint64_t>* live) {$/;"	f	class:leveldb::VersionSet
AfterFile	db/version_set.cc	/^static bool AfterFile(const Comparator* ucmp,$/;"	f	namespace:leveldb
AppendVersion	db/version_set.cc	/^void VersionSet::AppendVersion(Version* v) {$/;"	f	class:leveldb::VersionSet
Apply	db/version_set.cc	/^  void Apply(VersionEdit* edit) {$/;"	f	class:leveldb::VersionSet::Builder
ApproximateOffsetOf	db/version_set.cc	/^uint64_t VersionSet::ApproximateOffsetOf(Version* v, const InternalKey& ikey) {$/;"	f	class:leveldb::VersionSet
BeforeFile	db/version_set.cc	/^static bool BeforeFile(const Comparator* ucmp,$/;"	f	namespace:leveldb
Builder	db/version_set.cc	/^  Builder(VersionSet* vset, Version* base)$/;"	f	class:leveldb::VersionSet::Builder
Builder	db/version_set.cc	/^class VersionSet::Builder {$/;"	c	class:leveldb::VersionSet	file:
BySmallestKey	db/version_set.cc	/^  struct BySmallestKey {$/;"	s	class:leveldb::VersionSet::Builder	file:
CompactRange	db/version_set.cc	/^Compaction* VersionSet::CompactRange($/;"	f	class:leveldb::VersionSet
Compaction	db/version_set.cc	/^Compaction::Compaction(const Options* options, int level)$/;"	f	class:leveldb::Compaction
DebugString	db/version_set.cc	/^std::string Version::DebugString() const {$/;"	f	class:leveldb::Version
DeleteLevel0File	db/version_set.cc	/^  void DeleteLevel0File() {$/;"	f	class:leveldb::VersionSet::Builder
ExpandedCompactionByteSizeLimit	db/version_set.cc	/^static int64_t ExpandedCompactionByteSizeLimit(const Options* options) {$/;"	f	namespace:leveldb
FileSet	db/version_set.cc	/^  typedef std::set<FileMetaData*, BySmallestKey> FileSet;$/;"	t	class:leveldb::VersionSet::Builder	file:
Finalize	db/version_set.cc	/^void VersionSet::Finalize(Version* v) {$/;"	f	class:leveldb::VersionSet
FindFile	db/version_set.cc	/^int FindFile(const InternalKeyComparator& icmp,$/;"	f	namespace:leveldb
ForEachOverlapping	db/version_set.cc	/^void Version::ForEachOverlapping(Slice user_key, Slice internal_key,$/;"	f	class:leveldb::Version
Get	db/version_set.cc	/^Status Version::Get(const ReadOptions& options,$/;"	f	class:leveldb::Version
GetFileIterator	db/version_set.cc	/^static Iterator* GetFileIterator(void* arg,$/;"	f	namespace:leveldb
GetOverlappingInputs	db/version_set.cc	/^void Version::GetOverlappingInputs($/;"	f	class:leveldb::Version
GetRange	db/version_set.cc	/^void VersionSet::GetRange(const std::vector<FileMetaData*>& inputs,$/;"	f	class:leveldb::VersionSet
GetRange2	db/version_set.cc	/^void VersionSet::GetRange2(const std::vector<FileMetaData*>& inputs1,$/;"	f	class:leveldb::VersionSet
IsBaseLevelForKey	db/version_set.cc	/^bool Compaction::IsBaseLevelForKey(const Slice& user_key) {$/;"	f	class:leveldb::Compaction
IsTrivialMove	db/version_set.cc	/^bool Compaction::IsTrivialMove() const {$/;"	f	class:leveldb::Compaction
LevelFileNumIterator	db/version_set.cc	/^  LevelFileNumIterator(const InternalKeyComparator& icmp,$/;"	f	class:leveldb::Version::LevelFileNumIterator
LevelFileNumIterator	db/version_set.cc	/^class Version::LevelFileNumIterator : public Iterator {$/;"	c	class:leveldb::Version	file:
LevelState	db/version_set.cc	/^  struct LevelState {$/;"	s	class:leveldb::VersionSet::Builder	file:
LevelSummary	db/version_set.cc	/^const char* VersionSet::LevelSummary(LevelSummaryStorage* scratch) const {$/;"	f	class:leveldb::VersionSet
LogAndApply	db/version_set.cc	/^Status VersionSet::LogAndApply(VersionEdit* edit, port::Mutex* mu) {$/;"	f	class:leveldb::VersionSet
MakeInputIterator	db/version_set.cc	/^Iterator* VersionSet::MakeInputIterator(Compaction* c) {$/;"	f	class:leveldb::VersionSet
MarkFileNumberUsed	db/version_set.cc	/^void VersionSet::MarkFileNumberUsed(uint64_t number) {$/;"	f	class:leveldb::VersionSet
MaxBytesForLevel	db/version_set.cc	/^static double MaxBytesForLevel(const Options* options, int level) {$/;"	f	namespace:leveldb
MaxFileSizeForLevel	db/version_set.cc	/^static uint64_t MaxFileSizeForLevel(const Options* options, int level) {$/;"	f	namespace:leveldb
MaxGrandParentOverlapBytes	db/version_set.cc	/^static int64_t MaxGrandParentOverlapBytes(const Options* options) {$/;"	f	namespace:leveldb
MaxNextLevelOverlappingBytes	db/version_set.cc	/^int64_t VersionSet::MaxNextLevelOverlappingBytes() {$/;"	f	class:leveldb::VersionSet
MaybeAddFile	db/version_set.cc	/^  void MaybeAddFile(Version* v, int level, FileMetaData* f) {$/;"	f	class:leveldb::VersionSet::Builder
NewConcatenatingIterator	db/version_set.cc	/^Iterator* Version::NewConcatenatingIterator(const ReadOptions& options,$/;"	f	class:leveldb::Version
NewestFirst	db/version_set.cc	/^static bool NewestFirst(FileMetaData* a, FileMetaData* b) {$/;"	f	namespace:leveldb
Next	db/version_set.cc	/^  virtual void Next() {$/;"	f	class:leveldb::Version::LevelFileNumIterator
NumLevelBytes	db/version_set.cc	/^int64_t VersionSet::NumLevelBytes(int level) const {$/;"	f	class:leveldb::VersionSet
NumLevelFiles	db/version_set.cc	/^int VersionSet::NumLevelFiles(int level) const {$/;"	f	class:leveldb::VersionSet
OverlapInLevel	db/version_set.cc	/^bool Version::OverlapInLevel(int level,$/;"	f	class:leveldb::Version
PickCompaction	db/version_set.cc	/^Compaction* VersionSet::PickCompaction() {$/;"	f	class:leveldb::VersionSet
PickLevelForMemTableOutput	db/version_set.cc	/^int Version::PickLevelForMemTableOutput($/;"	f	class:leveldb::Version
Prev	db/version_set.cc	/^  virtual void Prev() {$/;"	f	class:leveldb::Version::LevelFileNumIterator
RecordReadSample	db/version_set.cc	/^bool Version::RecordReadSample(Slice internal_key) {$/;"	f	class:leveldb::Version
Recover	db/version_set.cc	/^Status VersionSet::Recover(bool *save_manifest) {$/;"	f	class:leveldb::VersionSet
Ref	db/version_set.cc	/^void Version::Ref() {$/;"	f	class:leveldb::Version
ReleaseInputs	db/version_set.cc	/^void Compaction::ReleaseInputs() {$/;"	f	class:leveldb::Compaction
ReuseManifest	db/version_set.cc	/^bool VersionSet::ReuseManifest(const std::string& dscname,$/;"	f	class:leveldb::VersionSet
SaveTo	db/version_set.cc	/^  void SaveTo(Version* v) {$/;"	f	class:leveldb::VersionSet::Builder
SaveValue	db/version_set.cc	/^static void SaveValue(void* arg, const Slice& ikey, const Slice& v) {$/;"	f	namespace:leveldb
Saver	db/version_set.cc	/^struct Saver {$/;"	s	namespace:leveldb::__anon14	file:
SaverState	db/version_set.cc	/^enum SaverState {$/;"	g	namespace:leveldb::__anon14	file:
Seek	db/version_set.cc	/^  virtual void Seek(const Slice& target) {$/;"	f	class:leveldb::Version::LevelFileNumIterator
SeekToFirst	db/version_set.cc	/^  virtual void SeekToFirst() { index_ = 0; }$/;"	f	class:leveldb::Version::LevelFileNumIterator
SeekToLast	db/version_set.cc	/^  virtual void SeekToLast() {$/;"	f	class:leveldb::Version::LevelFileNumIterator
SetupOtherInputs	db/version_set.cc	/^void VersionSet::SetupOtherInputs(Compaction* c) {$/;"	f	class:leveldb::VersionSet
ShouldStopBefore	db/version_set.cc	/^bool Compaction::ShouldStopBefore(const Slice& internal_key) {$/;"	f	class:leveldb::Compaction
SomeFileOverlapsRange	db/version_set.cc	/^bool SomeFileOverlapsRange($/;"	f	namespace:leveldb
TargetFileSize	db/version_set.cc	/^static int TargetFileSize(const Options* options) {$/;"	f	namespace:leveldb
TotalFileSize	db/version_set.cc	/^static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {$/;"	f	namespace:leveldb
Unref	db/version_set.cc	/^void Version::Unref() {$/;"	f	class:leveldb::Version
UpdateStats	db/version_set.cc	/^bool Version::UpdateStats(const GetStats& stats) {$/;"	f	class:leveldb::Version
Valid	db/version_set.cc	/^  virtual bool Valid() const {$/;"	f	class:leveldb::Version::LevelFileNumIterator
VersionSet	db/version_set.cc	/^VersionSet::VersionSet(const std::string& dbname,$/;"	f	class:leveldb::VersionSet
WriteSnapshot	db/version_set.cc	/^Status VersionSet::WriteSnapshot(log::Writer* log) {$/;"	f	class:leveldb::VersionSet
added_files	db/version_set.cc	/^    FileSet* added_files;$/;"	m	struct:leveldb::VersionSet::Builder::LevelState	file:
adjustFilter	db/version_set.cc	/^void VersionSet::adjustFilter()$/;"	f	class:leveldb::VersionSet
base_	db/version_set.cc	/^  Version* base_;$/;"	m	class:leveldb::VersionSet::Builder	file:
deleted_files	db/version_set.cc	/^    std::set<uint64_t> deleted_files;$/;"	m	struct:leveldb::VersionSet::Builder::LevelState	file:
findAllTables	db/version_set.cc	/^void Version::findAllTables(TableCache* table_cache)$/;"	f	class:leveldb::Version
findAllTables	db/version_set.cc	/^void VersionSet::findAllTables()$/;"	f	class:leveldb::VersionSet
flist_	db/version_set.cc	/^  const std::vector<FileMetaData*>* const flist_;$/;"	m	class:leveldb::Version::LevelFileNumIterator::std	file:
icmp_	db/version_set.cc	/^  const InternalKeyComparator icmp_;$/;"	m	class:leveldb::Version::LevelFileNumIterator	file:
index_	db/version_set.cc	/^  uint32_t index_;$/;"	m	class:leveldb::Version::LevelFileNumIterator	file:
internal_comparator	db/version_set.cc	/^    const InternalKeyComparator* internal_comparator;$/;"	m	struct:leveldb::VersionSet::Builder::BySmallestKey	file:
kCorrupt	db/version_set.cc	/^  kCorrupt,$/;"	e	enum:leveldb::__anon14::SaverState	file:
kDeleted	db/version_set.cc	/^  kDeleted,$/;"	e	enum:leveldb::__anon14::SaverState	file:
kFound	db/version_set.cc	/^  kFound,$/;"	e	enum:leveldb::__anon14::SaverState	file:
kNotFound	db/version_set.cc	/^  kNotFound,$/;"	e	enum:leveldb::__anon14::SaverState	file:
key	db/version_set.cc	/^  Slice key() const {$/;"	f	class:leveldb::Version::LevelFileNumIterator
leveldb	db/version_set.cc	/^namespace leveldb {$/;"	n	file:
levels_	db/version_set.cc	/^  LevelState levels_[config::kNumLevels];$/;"	m	class:leveldb::VersionSet::Builder	file:
operator ()	db/version_set.cc	/^    bool operator()(FileMetaData* f1, FileMetaData* f2) const {$/;"	f	struct:leveldb::VersionSet::Builder::BySmallestKey
printTableExtraInfos	db/version_set.cc	/^void VersionSet::printTableExtraInfos(int level,std::string *file_strs)$/;"	f	class:leveldb::VersionSet
printTables	db/version_set.cc	/^void Version::printTables(int level, std::string* file_strs,const char *property_str,TableCache *table_cache)$/;"	f	class:leveldb::Version
printTables	db/version_set.cc	/^void VersionSet::printTables(int level,std::string *file_strs,const char* property_str)$/;"	f	class:leveldb::VersionSet
state	db/version_set.cc	/^  SaverState state;$/;"	m	struct:leveldb::__anon14::Saver	file:
status	db/version_set.cc	/^  virtual Status status() const { return Status::OK(); }$/;"	f	class:leveldb::Version::LevelFileNumIterator
ucmp	db/version_set.cc	/^  const Comparator* ucmp;$/;"	m	struct:leveldb::__anon14::Saver	file:
user_key	db/version_set.cc	/^  Slice user_key;$/;"	m	struct:leveldb::__anon14::Saver	file:
value	db/version_set.cc	/^  Slice value() const {$/;"	f	class:leveldb::Version::LevelFileNumIterator
value	db/version_set.cc	/^  std::string* value;$/;"	m	struct:leveldb::__anon14::Saver	file:
value_buf_	db/version_set.cc	/^  mutable char value_buf_[16];$/;"	m	class:leveldb::Version::LevelFileNumIterator	file:
vset_	db/version_set.cc	/^  VersionSet* vset_;$/;"	m	class:leveldb::VersionSet::Builder	file:
~Builder	db/version_set.cc	/^  ~Builder() {$/;"	f	class:leveldb::VersionSet::Builder
~Compaction	db/version_set.cc	/^Compaction::~Compaction() {$/;"	f	class:leveldb::Compaction
~Version	db/version_set.cc	/^Version::~Version() {$/;"	f	class:leveldb::Version
~VersionSet	db/version_set.cc	/^VersionSet::~VersionSet() {$/;"	f	class:leveldb::VersionSet
Compaction	db/version_set.h	/^class Compaction {$/;"	c	namespace:leveldb
GetStats	db/version_set.h	/^  struct GetStats {$/;"	s	class:leveldb::Version
LastSequence	db/version_set.h	/^  uint64_t LastSequence() const { return last_sequence_; }$/;"	f	class:leveldb::VersionSet
LevelSummaryStorage	db/version_set.h	/^  struct LevelSummaryStorage {$/;"	s	class:leveldb::VersionSet
LogNumber	db/version_set.h	/^  uint64_t LogNumber() const { return log_number_; }$/;"	f	class:leveldb::VersionSet
ManifestFileNumber	db/version_set.h	/^  uint64_t ManifestFileNumber() const { return manifest_file_number_; }$/;"	f	class:leveldb::VersionSet
MaxOutputFileSize	db/version_set.h	/^  uint64_t MaxOutputFileSize() const { return max_output_file_size_; }$/;"	f	class:leveldb::Compaction
NeedsCompaction	db/version_set.h	/^  bool NeedsCompaction() const {$/;"	f	class:leveldb::VersionSet
NewFileNumber	db/version_set.h	/^  uint64_t NewFileNumber() { return next_file_number_++; }$/;"	f	class:leveldb::VersionSet
NumFiles	db/version_set.h	/^  int NumFiles(int level) const { return files_[level].size(); }$/;"	f	class:leveldb::Version
PrevLogNumber	db/version_set.h	/^  uint64_t PrevLogNumber() const { return prev_log_number_; }$/;"	f	class:leveldb::VersionSet
ReuseFileNumber	db/version_set.h	/^  void ReuseFileNumber(uint64_t file_number) {$/;"	f	class:leveldb::VersionSet
STORAGE_LEVELDB_DB_VERSION_SET_H_	db/version_set.h	16;"	d
SetLastSequence	db/version_set.h	/^  void SetLastSequence(uint64_t s) {$/;"	f	class:leveldb::VersionSet
Version	db/version_set.h	/^  explicit Version(VersionSet* vset)$/;"	f	class:leveldb::Version
Version	db/version_set.h	/^class Version {$/;"	c	namespace:leveldb
VersionSet	db/version_set.h	/^class VersionSet {$/;"	c	namespace:leveldb
buffer	db/version_set.h	/^    char buffer[100];$/;"	m	struct:leveldb::VersionSet::LevelSummaryStorage
compact_pointer_	db/version_set.h	/^  std::string compact_pointer_[config::kNumLevels];$/;"	m	class:leveldb::VersionSet
compaction_level_	db/version_set.h	/^  int compaction_level_;$/;"	m	class:leveldb::Version
compaction_score_	db/version_set.h	/^  double compaction_score_;$/;"	m	class:leveldb::Version
current	db/version_set.h	/^  Version* current() const { return current_; }$/;"	f	class:leveldb::VersionSet
current_	db/version_set.h	/^  Version* current_;        \/\/ == dummy_versions_.prev_$/;"	m	class:leveldb::VersionSet
dbname_	db/version_set.h	/^  const std::string dbname_;$/;"	m	class:leveldb::VersionSet
descriptor_file_	db/version_set.h	/^  WritableFile* descriptor_file_;$/;"	m	class:leveldb::VersionSet
descriptor_log_	db/version_set.h	/^  log::Writer* descriptor_log_;$/;"	m	class:leveldb::VersionSet
dummy_versions_	db/version_set.h	/^  Version dummy_versions_;  \/\/ Head of circular doubly-linked list of versions.$/;"	m	class:leveldb::VersionSet
edit	db/version_set.h	/^  VersionEdit* edit() { return &edit_; }$/;"	f	class:leveldb::Compaction
edit_	db/version_set.h	/^  VersionEdit edit_;$/;"	m	class:leveldb::Compaction
env_	db/version_set.h	/^  Env* const env_;$/;"	m	class:leveldb::VersionSet
file_to_compact_	db/version_set.h	/^  FileMetaData* file_to_compact_;$/;"	m	class:leveldb::Version
file_to_compact_level_	db/version_set.h	/^  int file_to_compact_level_;$/;"	m	class:leveldb::Version
files_	db/version_set.h	/^  std::vector<FileMetaData*> files_[config::kNumLevels];$/;"	m	class:leveldb::Version
files_extra_	db/version_set.h	/^  std::map<uint64_t, FileExtraMetaData*> *files_extra_;$/;"	m	class:leveldb::Version
files_extra_	db/version_set.h	/^  std::map<uint64_t, FileExtraMetaData*> files_extra_[config::kNumLevels];$/;"	m	class:leveldb::VersionSet
grandparent_index_	db/version_set.h	/^  size_t grandparent_index_;  \/\/ Index in grandparent_starts_$/;"	m	class:leveldb::Compaction
grandparents_	db/version_set.h	/^  std::vector<FileMetaData*> grandparents_;$/;"	m	class:leveldb::Compaction
icmp_	db/version_set.h	/^  const InternalKeyComparator icmp_;$/;"	m	class:leveldb::VersionSet
input	db/version_set.h	/^  FileMetaData* input(int which, int i) const { return inputs_[which][i]; }$/;"	f	class:leveldb::Compaction
input_version_	db/version_set.h	/^  Version* input_version_;$/;"	m	class:leveldb::Compaction
inputs_	db/version_set.h	/^  std::vector<FileMetaData*> inputs_[2];      \/\/ The two sets of inputs$/;"	m	class:leveldb::Compaction
last_sequence_	db/version_set.h	/^  uint64_t last_sequence_;$/;"	m	class:leveldb::VersionSet
level	db/version_set.h	/^  int level() const { return level_; }$/;"	f	class:leveldb::Compaction
level_	db/version_set.h	/^  int level_;$/;"	m	class:leveldb::Compaction
level_ptrs_	db/version_set.h	/^  size_t level_ptrs_[config::kNumLevels];$/;"	m	class:leveldb::Compaction
leveldb	db/version_set.h	/^namespace leveldb {$/;"	n
log	db/version_set.h	/^namespace log { class Writer; }$/;"	n	namespace:leveldb
log_number_	db/version_set.h	/^  uint64_t log_number_;$/;"	m	class:leveldb::VersionSet
manifest_file_number_	db/version_set.h	/^  uint64_t manifest_file_number_;$/;"	m	class:leveldb::VersionSet
max_output_file_size_	db/version_set.h	/^  uint64_t max_output_file_size_;$/;"	m	class:leveldb::Compaction
next_	db/version_set.h	/^  Version* next_;               \/\/ Next version in linked list$/;"	m	class:leveldb::Version
next_file_number_	db/version_set.h	/^  uint64_t next_file_number_;$/;"	m	class:leveldb::VersionSet
num_input_files	db/version_set.h	/^  int num_input_files(int which) const { return inputs_[which].size(); }$/;"	f	class:leveldb::Compaction
options_	db/version_set.h	/^  const Options* const options_;$/;"	m	class:leveldb::VersionSet
overlapped_bytes_	db/version_set.h	/^  int64_t overlapped_bytes_;  \/\/ Bytes of overlap between current output$/;"	m	class:leveldb::Compaction
prev_	db/version_set.h	/^  Version* prev_;               \/\/ Previous version in linked list$/;"	m	class:leveldb::Version
prev_log_number_	db/version_set.h	/^  uint64_t prev_log_number_;  \/\/ 0 or backing store for memtable being compacted$/;"	m	class:leveldb::VersionSet
refs_	db/version_set.h	/^  int refs_;                    \/\/ Number of live refs to this version$/;"	m	class:leveldb::Version
seek_file	db/version_set.h	/^    FileMetaData* seek_file;$/;"	m	struct:leveldb::Version::GetStats
seek_file_level	db/version_set.h	/^    int seek_file_level;$/;"	m	struct:leveldb::Version::GetStats
seen_key_	db/version_set.h	/^  bool seen_key_;             \/\/ Some output key has been seen$/;"	m	class:leveldb::Compaction
table_cache_	db/version_set.h	/^  TableCache* const table_cache_;$/;"	m	class:leveldb::VersionSet
vset_	db/version_set.h	/^  VersionSet* vset_;            \/\/ VersionSet to which this Version belongs$/;"	m	class:leveldb::Version
Add	db/version_set_test.cc	/^  void Add(const char* smallest, const char* largest,$/;"	f	class:leveldb::FindFileTest
Find	db/version_set_test.cc	/^  int Find(const char* key) {$/;"	f	class:leveldb::FindFileTest
FindFileTest	db/version_set_test.cc	/^  FindFileTest() : disjoint_sorted_files_(true) { }$/;"	f	class:leveldb::FindFileTest
FindFileTest	db/version_set_test.cc	/^class FindFileTest {$/;"	c	namespace:leveldb	file:
Overlaps	db/version_set_test.cc	/^  bool Overlaps(const char* smallest, const char* largest) {$/;"	f	class:leveldb::FindFileTest
TEST	db/version_set_test.cc	/^TEST(FindFileTest, Empty) {$/;"	f	namespace:leveldb
TEST	db/version_set_test.cc	/^TEST(FindFileTest, Multiple) {$/;"	f	namespace:leveldb
TEST	db/version_set_test.cc	/^TEST(FindFileTest, MultipleNullBoundaries) {$/;"	f	namespace:leveldb
TEST	db/version_set_test.cc	/^TEST(FindFileTest, OverlapSequenceChecks) {$/;"	f	namespace:leveldb
TEST	db/version_set_test.cc	/^TEST(FindFileTest, OverlappingFiles) {$/;"	f	namespace:leveldb
TEST	db/version_set_test.cc	/^TEST(FindFileTest, Single) {$/;"	f	namespace:leveldb
disjoint_sorted_files_	db/version_set_test.cc	/^  bool disjoint_sorted_files_;$/;"	m	class:leveldb::FindFileTest	file:
files_	db/version_set_test.cc	/^  std::vector<FileMetaData*> files_;$/;"	m	class:leveldb::FindFileTest	file:
leveldb	db/version_set_test.cc	/^namespace leveldb {$/;"	n	file:
main	db/version_set_test.cc	/^int main(int argc, char** argv) {$/;"	f
~FindFileTest	db/version_set_test.cc	/^  ~FindFileTest() {$/;"	f	class:leveldb::FindFileTest
Append	db/write_batch.cc	/^void WriteBatchInternal::Append(WriteBatch* dst, const WriteBatch* src) {$/;"	f	class:leveldb::WriteBatchInternal
ApproximateSize	db/write_batch.cc	/^size_t WriteBatch::ApproximateSize() {$/;"	f	class:leveldb::WriteBatch
Clear	db/write_batch.cc	/^void WriteBatch::Clear() {$/;"	f	class:leveldb::WriteBatch
Count	db/write_batch.cc	/^int WriteBatchInternal::Count(const WriteBatch* b) {$/;"	f	class:leveldb::WriteBatchInternal
Delete	db/write_batch.cc	/^  virtual void Delete(const Slice& key) {$/;"	f	class:leveldb::__anon8::MemTableInserter
Delete	db/write_batch.cc	/^void WriteBatch::Delete(const Slice& key) {$/;"	f	class:leveldb::WriteBatch
InsertInto	db/write_batch.cc	/^Status WriteBatchInternal::InsertInto(const WriteBatch* b,$/;"	f	class:leveldb::WriteBatchInternal
Iterate	db/write_batch.cc	/^Status WriteBatch::Iterate(Handler* handler) const {$/;"	f	class:leveldb::WriteBatch
MemTableInserter	db/write_batch.cc	/^class MemTableInserter : public WriteBatch::Handler {$/;"	c	namespace:leveldb::__anon8	file:
Put	db/write_batch.cc	/^  virtual void Put(const Slice& key, const Slice& value) {$/;"	f	class:leveldb::__anon8::MemTableInserter
Put	db/write_batch.cc	/^void WriteBatch::Put(const Slice& key, const Slice& value) {$/;"	f	class:leveldb::WriteBatch
Sequence	db/write_batch.cc	/^SequenceNumber WriteBatchInternal::Sequence(const WriteBatch* b) {$/;"	f	class:leveldb::WriteBatchInternal
SetContents	db/write_batch.cc	/^void WriteBatchInternal::SetContents(WriteBatch* b, const Slice& contents) {$/;"	f	class:leveldb::WriteBatchInternal
SetCount	db/write_batch.cc	/^void WriteBatchInternal::SetCount(WriteBatch* b, int n) {$/;"	f	class:leveldb::WriteBatchInternal
SetSequence	db/write_batch.cc	/^void WriteBatchInternal::SetSequence(WriteBatch* b, SequenceNumber seq) {$/;"	f	class:leveldb::WriteBatchInternal
WriteBatch	db/write_batch.cc	/^WriteBatch::WriteBatch() {$/;"	f	class:leveldb::WriteBatch
kHeader	db/write_batch.cc	/^static const size_t kHeader = 12;$/;"	m	namespace:leveldb	file:
leveldb	db/write_batch.cc	/^namespace leveldb {$/;"	n	file:
mem_	db/write_batch.cc	/^  MemTable* mem_;$/;"	m	class:leveldb::__anon8::MemTableInserter	file:
sequence_	db/write_batch.cc	/^  SequenceNumber sequence_;$/;"	m	class:leveldb::__anon8::MemTableInserter	file:
~Handler	db/write_batch.cc	/^WriteBatch::Handler::~Handler() { }$/;"	f	class:leveldb::WriteBatch::Handler
~WriteBatch	db/write_batch.cc	/^WriteBatch::~WriteBatch() { }$/;"	f	class:leveldb::WriteBatch
ByteSize	db/write_batch_internal.h	/^  static size_t ByteSize(const WriteBatch* batch) {$/;"	f	class:leveldb::WriteBatchInternal
Contents	db/write_batch_internal.h	/^  static Slice Contents(const WriteBatch* batch) {$/;"	f	class:leveldb::WriteBatchInternal
STORAGE_LEVELDB_DB_WRITE_BATCH_INTERNAL_H_	db/write_batch_internal.h	6;"	d
WriteBatchInternal	db/write_batch_internal.h	/^class WriteBatchInternal {$/;"	c	namespace:leveldb
leveldb	db/write_batch_internal.h	/^namespace leveldb {$/;"	n
PrintContents	db/write_batch_test.cc	/^static std::string PrintContents(WriteBatch* b) {$/;"	f	namespace:leveldb
TEST	db/write_batch_test.cc	/^TEST(WriteBatchTest, Append) {$/;"	f	namespace:leveldb
TEST	db/write_batch_test.cc	/^TEST(WriteBatchTest, ApproximateSize) {$/;"	f	namespace:leveldb
TEST	db/write_batch_test.cc	/^TEST(WriteBatchTest, Corruption) {$/;"	f	namespace:leveldb
TEST	db/write_batch_test.cc	/^TEST(WriteBatchTest, Empty) {$/;"	f	namespace:leveldb
TEST	db/write_batch_test.cc	/^TEST(WriteBatchTest, Multiple) {$/;"	f	namespace:leveldb
WriteBatchTest	db/write_batch_test.cc	/^class WriteBatchTest { };$/;"	c	namespace:leveldb	file:
leveldb	db/write_batch_test.cc	/^namespace leveldb {$/;"	n	file:
main	db/write_batch_test.cc	/^int main(int argc, char** argv) {$/;"	f
Benchmark	doc/bench/db_bench_sqlite3.cc	/^  Benchmark()$/;"	f	class:leveldb::Benchmark
Benchmark	doc/bench/db_bench_sqlite3.cc	/^class Benchmark {$/;"	c	namespace:leveldb	file:
DBState	doc/bench/db_bench_sqlite3.cc	/^  enum DBState {$/;"	g	class:leveldb::Benchmark	file:
EXISTING	doc/bench/db_bench_sqlite3.cc	/^    EXISTING$/;"	e	enum:leveldb::Benchmark::DBState	file:
ErrorCheck	doc/bench/db_bench_sqlite3.cc	/^static void ErrorCheck(int status) {$/;"	f	file:
ExecErrorCheck	doc/bench/db_bench_sqlite3.cc	/^static void ExecErrorCheck(int status, char *err_msg) {$/;"	f	file:
FLAGS_WAL_enabled	doc/bench/db_bench_sqlite3.cc	/^static bool FLAGS_WAL_enabled = true;$/;"	v	file:
FLAGS_benchmarks	doc/bench/db_bench_sqlite3.cc	/^static const char* FLAGS_benchmarks =$/;"	v	file:
FLAGS_compression_ratio	doc/bench/db_bench_sqlite3.cc	/^static double FLAGS_compression_ratio = 0.5;$/;"	v	file:
FLAGS_db	doc/bench/db_bench_sqlite3.cc	/^static const char* FLAGS_db = NULL;$/;"	v	file:
FLAGS_histogram	doc/bench/db_bench_sqlite3.cc	/^static bool FLAGS_histogram = false;$/;"	v	file:
FLAGS_num	doc/bench/db_bench_sqlite3.cc	/^static int FLAGS_num = 1000000;$/;"	v	file:
FLAGS_num_pages	doc/bench/db_bench_sqlite3.cc	/^static int FLAGS_num_pages = 4096;$/;"	v	file:
FLAGS_page_size	doc/bench/db_bench_sqlite3.cc	/^static int FLAGS_page_size = 1024;$/;"	v	file:
FLAGS_reads	doc/bench/db_bench_sqlite3.cc	/^static int FLAGS_reads = -1;$/;"	v	file:
FLAGS_transaction	doc/bench/db_bench_sqlite3.cc	/^static bool FLAGS_transaction = true;$/;"	v	file:
FLAGS_use_existing_db	doc/bench/db_bench_sqlite3.cc	/^static bool FLAGS_use_existing_db = false;$/;"	v	file:
FLAGS_value_size	doc/bench/db_bench_sqlite3.cc	/^static int FLAGS_value_size = 100;$/;"	v	file:
FRESH	doc/bench/db_bench_sqlite3.cc	/^    FRESH,$/;"	e	enum:leveldb::Benchmark::DBState	file:
FinishedSingleOp	doc/bench/db_bench_sqlite3.cc	/^  void FinishedSingleOp() {$/;"	f	class:leveldb::Benchmark	file:
Generate	doc/bench/db_bench_sqlite3.cc	/^  Slice Generate(int len) {$/;"	f	class:leveldb::__anon15::RandomGenerator
Open	doc/bench/db_bench_sqlite3.cc	/^  void Open() {$/;"	f	class:leveldb::Benchmark
Order	doc/bench/db_bench_sqlite3.cc	/^  enum Order {$/;"	g	class:leveldb::Benchmark	file:
PrintEnvironment	doc/bench/db_bench_sqlite3.cc	/^  void PrintEnvironment() {$/;"	f	class:leveldb::Benchmark	file:
PrintHeader	doc/bench/db_bench_sqlite3.cc	/^  void PrintHeader() {$/;"	f	class:leveldb::Benchmark	file:
PrintWarnings	doc/bench/db_bench_sqlite3.cc	/^  void PrintWarnings() {$/;"	f	class:leveldb::Benchmark	file:
RANDOM	doc/bench/db_bench_sqlite3.cc	/^    RANDOM$/;"	e	enum:leveldb::Benchmark::Order	file:
RandomGenerator	doc/bench/db_bench_sqlite3.cc	/^  RandomGenerator() {$/;"	f	class:leveldb::__anon15::RandomGenerator
RandomGenerator	doc/bench/db_bench_sqlite3.cc	/^class RandomGenerator {$/;"	c	namespace:leveldb::__anon15	file:
Read	doc/bench/db_bench_sqlite3.cc	/^  void Read(Order order, int entries_per_batch) {$/;"	f	class:leveldb::Benchmark
ReadSequential	doc/bench/db_bench_sqlite3.cc	/^  void ReadSequential() {$/;"	f	class:leveldb::Benchmark
Run	doc/bench/db_bench_sqlite3.cc	/^  void Run() {$/;"	f	class:leveldb::Benchmark
SEQUENTIAL	doc/bench/db_bench_sqlite3.cc	/^    SEQUENTIAL,$/;"	e	enum:leveldb::Benchmark::Order	file:
Start	doc/bench/db_bench_sqlite3.cc	/^  void Start() {$/;"	f	class:leveldb::Benchmark	file:
StepErrorCheck	doc/bench/db_bench_sqlite3.cc	/^static void StepErrorCheck(int status) {$/;"	f	file:
Stop	doc/bench/db_bench_sqlite3.cc	/^  void Stop(const Slice& name) {$/;"	f	class:leveldb::Benchmark	file:
TrimSpace	doc/bench/db_bench_sqlite3.cc	/^static Slice TrimSpace(Slice s) {$/;"	f	namespace:leveldb::__anon15
WalCheckpoint	doc/bench/db_bench_sqlite3.cc	/^static void WalCheckpoint(sqlite3* db_) {$/;"	f	file:
Write	doc/bench/db_bench_sqlite3.cc	/^  void Write(bool write_sync, Order order, DBState state,$/;"	f	class:leveldb::Benchmark
bytes_	doc/bench/db_bench_sqlite3.cc	/^  int64_t bytes_;$/;"	m	class:leveldb::Benchmark	file:
data_	doc/bench/db_bench_sqlite3.cc	/^  std::string data_;$/;"	m	class:leveldb::__anon15::RandomGenerator	file:
db_	doc/bench/db_bench_sqlite3.cc	/^  sqlite3* db_;$/;"	m	class:leveldb::Benchmark	file:
db_num_	doc/bench/db_bench_sqlite3.cc	/^  int db_num_;$/;"	m	class:leveldb::Benchmark	file:
done_	doc/bench/db_bench_sqlite3.cc	/^  int done_;$/;"	m	class:leveldb::Benchmark	file:
gen_	doc/bench/db_bench_sqlite3.cc	/^  RandomGenerator gen_;$/;"	m	class:leveldb::Benchmark	file:
hist_	doc/bench/db_bench_sqlite3.cc	/^  Histogram hist_;$/;"	m	class:leveldb::Benchmark	file:
last_op_finish_	doc/bench/db_bench_sqlite3.cc	/^  double last_op_finish_;$/;"	m	class:leveldb::Benchmark	file:
leveldb	doc/bench/db_bench_sqlite3.cc	/^namespace leveldb {$/;"	n	file:
main	doc/bench/db_bench_sqlite3.cc	/^int main(int argc, char** argv) {$/;"	f
message_	doc/bench/db_bench_sqlite3.cc	/^  std::string message_;$/;"	m	class:leveldb::Benchmark	file:
next_report_	doc/bench/db_bench_sqlite3.cc	/^  int next_report_;     \/\/ When to report next$/;"	m	class:leveldb::Benchmark	file:
num_	doc/bench/db_bench_sqlite3.cc	/^  int num_;$/;"	m	class:leveldb::Benchmark	file:
pos_	doc/bench/db_bench_sqlite3.cc	/^  int pos_;$/;"	m	class:leveldb::__anon15::RandomGenerator	file:
rand_	doc/bench/db_bench_sqlite3.cc	/^  Random rand_;$/;"	m	class:leveldb::Benchmark	file:
reads_	doc/bench/db_bench_sqlite3.cc	/^  int reads_;$/;"	m	class:leveldb::Benchmark	file:
start_	doc/bench/db_bench_sqlite3.cc	/^  double start_;$/;"	m	class:leveldb::Benchmark	file:
~Benchmark	doc/bench/db_bench_sqlite3.cc	/^  ~Benchmark() {$/;"	f	class:leveldb::Benchmark
Benchmark	doc/bench/db_bench_tree_db.cc	/^  Benchmark()$/;"	f	class:leveldb::Benchmark
Benchmark	doc/bench/db_bench_tree_db.cc	/^class Benchmark {$/;"	c	namespace:leveldb	file:
DBState	doc/bench/db_bench_tree_db.cc	/^  enum DBState {$/;"	g	class:leveldb::Benchmark	file:
DBSynchronize	doc/bench/db_bench_tree_db.cc	/^static void DBSynchronize(kyotocabinet::TreeDB* db_)$/;"	f	file:
EXISTING	doc/bench/db_bench_tree_db.cc	/^    EXISTING$/;"	e	enum:leveldb::Benchmark::DBState	file:
FLAGS_benchmarks	doc/bench/db_bench_tree_db.cc	/^static const char* FLAGS_benchmarks =$/;"	v	file:
FLAGS_cache_size	doc/bench/db_bench_tree_db.cc	/^static int FLAGS_cache_size = 4194304;$/;"	v	file:
FLAGS_compression	doc/bench/db_bench_tree_db.cc	/^static bool FLAGS_compression = true;$/;"	v	file:
FLAGS_compression_ratio	doc/bench/db_bench_tree_db.cc	/^static double FLAGS_compression_ratio = 0.5;$/;"	v	file:
FLAGS_db	doc/bench/db_bench_tree_db.cc	/^static const char* FLAGS_db = NULL;$/;"	v	file:
FLAGS_histogram	doc/bench/db_bench_tree_db.cc	/^static bool FLAGS_histogram = false;$/;"	v	file:
FLAGS_num	doc/bench/db_bench_tree_db.cc	/^static int FLAGS_num = 1000000;$/;"	v	file:
FLAGS_page_size	doc/bench/db_bench_tree_db.cc	/^static int FLAGS_page_size = 1024;$/;"	v	file:
FLAGS_reads	doc/bench/db_bench_tree_db.cc	/^static int FLAGS_reads = -1;$/;"	v	file:
FLAGS_use_existing_db	doc/bench/db_bench_tree_db.cc	/^static bool FLAGS_use_existing_db = false;$/;"	v	file:
FLAGS_value_size	doc/bench/db_bench_tree_db.cc	/^static int FLAGS_value_size = 100;$/;"	v	file:
FRESH	doc/bench/db_bench_tree_db.cc	/^    FRESH,$/;"	e	enum:leveldb::Benchmark::DBState	file:
FinishedSingleOp	doc/bench/db_bench_tree_db.cc	/^  void FinishedSingleOp() {$/;"	f	class:leveldb::Benchmark	file:
Generate	doc/bench/db_bench_tree_db.cc	/^  Slice Generate(int len) {$/;"	f	class:leveldb::__anon16::RandomGenerator
Open	doc/bench/db_bench_tree_db.cc	/^    void Open(bool sync) {$/;"	f	class:leveldb::Benchmark	file:
Order	doc/bench/db_bench_tree_db.cc	/^  enum Order {$/;"	g	class:leveldb::Benchmark	file:
PrintEnvironment	doc/bench/db_bench_tree_db.cc	/^  void PrintEnvironment() {$/;"	f	class:leveldb::Benchmark	file:
PrintHeader	doc/bench/db_bench_tree_db.cc	/^  void PrintHeader() {$/;"	f	class:leveldb::Benchmark	file:
PrintWarnings	doc/bench/db_bench_tree_db.cc	/^  void PrintWarnings() {$/;"	f	class:leveldb::Benchmark	file:
RANDOM	doc/bench/db_bench_tree_db.cc	/^    RANDOM$/;"	e	enum:leveldb::Benchmark::Order	file:
RandomGenerator	doc/bench/db_bench_tree_db.cc	/^  RandomGenerator() {$/;"	f	class:leveldb::__anon16::RandomGenerator
RandomGenerator	doc/bench/db_bench_tree_db.cc	/^class RandomGenerator {$/;"	c	namespace:leveldb::__anon16	file:
ReadRandom	doc/bench/db_bench_tree_db.cc	/^  void ReadRandom() {$/;"	f	class:leveldb::Benchmark	file:
ReadSequential	doc/bench/db_bench_tree_db.cc	/^  void ReadSequential() {$/;"	f	class:leveldb::Benchmark	file:
Run	doc/bench/db_bench_tree_db.cc	/^  void Run() {$/;"	f	class:leveldb::Benchmark
SEQUENTIAL	doc/bench/db_bench_tree_db.cc	/^    SEQUENTIAL,$/;"	e	enum:leveldb::Benchmark::Order	file:
Start	doc/bench/db_bench_tree_db.cc	/^  void Start() {$/;"	f	class:leveldb::Benchmark	file:
Stop	doc/bench/db_bench_tree_db.cc	/^  void Stop(const Slice& name) {$/;"	f	class:leveldb::Benchmark	file:
TrimSpace	doc/bench/db_bench_tree_db.cc	/^static Slice TrimSpace(Slice s) {$/;"	f	namespace:leveldb::__anon16
Write	doc/bench/db_bench_tree_db.cc	/^  void Write(bool sync, Order order, DBState state,$/;"	f	class:leveldb::Benchmark	file:
bytes_	doc/bench/db_bench_tree_db.cc	/^  int64_t bytes_;$/;"	m	class:leveldb::Benchmark	file:
comp_	doc/bench/db_bench_tree_db.cc	/^  kyotocabinet::LZOCompressor<kyotocabinet::LZO::RAW> comp_;$/;"	m	class:leveldb::Benchmark	file:
data_	doc/bench/db_bench_tree_db.cc	/^  std::string data_;$/;"	m	class:leveldb::__anon16::RandomGenerator	file:
db_	doc/bench/db_bench_tree_db.cc	/^  kyotocabinet::TreeDB* db_;$/;"	m	class:leveldb::Benchmark	file:
db_num_	doc/bench/db_bench_tree_db.cc	/^  int db_num_;$/;"	m	class:leveldb::Benchmark	file:
done_	doc/bench/db_bench_tree_db.cc	/^  int done_;$/;"	m	class:leveldb::Benchmark	file:
gen_	doc/bench/db_bench_tree_db.cc	/^  RandomGenerator gen_;$/;"	m	class:leveldb::Benchmark	file:
hist_	doc/bench/db_bench_tree_db.cc	/^  Histogram hist_;$/;"	m	class:leveldb::Benchmark	file:
last_op_finish_	doc/bench/db_bench_tree_db.cc	/^  double last_op_finish_;$/;"	m	class:leveldb::Benchmark	file:
leveldb	doc/bench/db_bench_tree_db.cc	/^namespace leveldb {$/;"	n	file:
main	doc/bench/db_bench_tree_db.cc	/^int main(int argc, char** argv) {$/;"	f
message_	doc/bench/db_bench_tree_db.cc	/^  std::string message_;$/;"	m	class:leveldb::Benchmark	file:
next_report_	doc/bench/db_bench_tree_db.cc	/^  int next_report_;     \/\/ When to report next$/;"	m	class:leveldb::Benchmark	file:
num_	doc/bench/db_bench_tree_db.cc	/^  int num_;$/;"	m	class:leveldb::Benchmark	file:
pos_	doc/bench/db_bench_tree_db.cc	/^  int pos_;$/;"	m	class:leveldb::__anon16::RandomGenerator	file:
rand_	doc/bench/db_bench_tree_db.cc	/^  Random rand_;$/;"	m	class:leveldb::Benchmark	file:
reads_	doc/bench/db_bench_tree_db.cc	/^  int reads_;$/;"	m	class:leveldb::Benchmark	file:
start_	doc/bench/db_bench_tree_db.cc	/^  double start_;$/;"	m	class:leveldb::Benchmark	file:
~Benchmark	doc/bench/db_bench_tree_db.cc	/^  ~Benchmark() {$/;"	f	class:leveldb::Benchmark
Append	helpers/memenv/memenv.cc	/^  Status Append(const Slice& data) {$/;"	f	class:leveldb::__anon17::FileState
Append	helpers/memenv/memenv.cc	/^  virtual Status Append(const Slice& data) {$/;"	f	class:leveldb::__anon17::WritableFileImpl
Close	helpers/memenv/memenv.cc	/^  virtual Status Close() { return Status::OK(); }$/;"	f	class:leveldb::__anon17::WritableFileImpl
CreateDir	helpers/memenv/memenv.cc	/^  virtual Status CreateDir(const std::string& dirname) {$/;"	f	class:leveldb::__anon17::InMemoryEnv
DeleteDir	helpers/memenv/memenv.cc	/^  virtual Status DeleteDir(const std::string& dirname) {$/;"	f	class:leveldb::__anon17::InMemoryEnv
DeleteFile	helpers/memenv/memenv.cc	/^  virtual Status DeleteFile(const std::string& fname) {$/;"	f	class:leveldb::__anon17::InMemoryEnv
DeleteFileInternal	helpers/memenv/memenv.cc	/^  void DeleteFileInternal(const std::string& fname) {$/;"	f	class:leveldb::__anon17::InMemoryEnv
FileExists	helpers/memenv/memenv.cc	/^  virtual bool FileExists(const std::string& fname) {$/;"	f	class:leveldb::__anon17::InMemoryEnv
FileState	helpers/memenv/memenv.cc	/^  FileState() : refs_(0), size_(0) {}$/;"	f	class:leveldb::__anon17::FileState
FileState	helpers/memenv/memenv.cc	/^class FileState {$/;"	c	namespace:leveldb::__anon17	file:
FileSystem	helpers/memenv/memenv.cc	/^  typedef std::map<std::string, FileState*> FileSystem;$/;"	t	class:leveldb::__anon17::InMemoryEnv	file:
Flush	helpers/memenv/memenv.cc	/^  virtual Status Flush() { return Status::OK(); }$/;"	f	class:leveldb::__anon17::WritableFileImpl
GetChildren	helpers/memenv/memenv.cc	/^  virtual Status GetChildren(const std::string& dir,$/;"	f	class:leveldb::__anon17::InMemoryEnv
GetFileSize	helpers/memenv/memenv.cc	/^  virtual Status GetFileSize(const std::string& fname, uint64_t* file_size) {$/;"	f	class:leveldb::__anon17::InMemoryEnv
GetTestDirectory	helpers/memenv/memenv.cc	/^  virtual Status GetTestDirectory(std::string* path) {$/;"	f	class:leveldb::__anon17::InMemoryEnv
InMemoryEnv	helpers/memenv/memenv.cc	/^  explicit InMemoryEnv(Env* base_env) : EnvWrapper(base_env) { }$/;"	f	class:leveldb::__anon17::InMemoryEnv
InMemoryEnv	helpers/memenv/memenv.cc	/^class InMemoryEnv : public EnvWrapper {$/;"	c	namespace:leveldb::__anon17	file:
LockFile	helpers/memenv/memenv.cc	/^  virtual Status LockFile(const std::string& fname, FileLock** lock) {$/;"	f	class:leveldb::__anon17::InMemoryEnv
Logv	helpers/memenv/memenv.cc	/^  virtual void Logv(const char* format, va_list ap) { }$/;"	f	class:leveldb::__anon17::NoOpLogger
NewAppendableFile	helpers/memenv/memenv.cc	/^  virtual Status NewAppendableFile(const std::string& fname,$/;"	f	class:leveldb::__anon17::InMemoryEnv
NewLogger	helpers/memenv/memenv.cc	/^  virtual Status NewLogger(const std::string& fname, Logger** result) {$/;"	f	class:leveldb::__anon17::InMemoryEnv
NewMemEnv	helpers/memenv/memenv.cc	/^Env* NewMemEnv(Env* base_env) {$/;"	f	namespace:leveldb
NewRandomAccessFile	helpers/memenv/memenv.cc	/^  virtual Status NewRandomAccessFile(const std::string& fname,$/;"	f	class:leveldb::__anon17::InMemoryEnv
NewSequentialFile	helpers/memenv/memenv.cc	/^  virtual Status NewSequentialFile(const std::string& fname,$/;"	f	class:leveldb::__anon17::InMemoryEnv
NewWritableFile	helpers/memenv/memenv.cc	/^  virtual Status NewWritableFile(const std::string& fname,$/;"	f	class:leveldb::__anon17::InMemoryEnv
NoOpLogger	helpers/memenv/memenv.cc	/^class NoOpLogger : public Logger {$/;"	c	namespace:leveldb::__anon17	file:
RandomAccessFileImpl	helpers/memenv/memenv.cc	/^  explicit RandomAccessFileImpl(FileState* file) : file_(file) {$/;"	f	class:leveldb::__anon17::RandomAccessFileImpl
RandomAccessFileImpl	helpers/memenv/memenv.cc	/^class RandomAccessFileImpl : public RandomAccessFile {$/;"	c	namespace:leveldb::__anon17	file:
Read	helpers/memenv/memenv.cc	/^  Status Read(uint64_t offset, size_t n, Slice* result, char* scratch) const {$/;"	f	class:leveldb::__anon17::FileState
Read	helpers/memenv/memenv.cc	/^  virtual Status Read(size_t n, Slice* result, char* scratch) {$/;"	f	class:leveldb::__anon17::SequentialFileImpl
Read	helpers/memenv/memenv.cc	/^  virtual Status Read(uint64_t offset, size_t n, Slice* result,$/;"	f	class:leveldb::__anon17::RandomAccessFileImpl
Ref	helpers/memenv/memenv.cc	/^  void Ref() {$/;"	f	class:leveldb::__anon17::FileState
RenameFile	helpers/memenv/memenv.cc	/^  virtual Status RenameFile(const std::string& src,$/;"	f	class:leveldb::__anon17::InMemoryEnv
SequentialFileImpl	helpers/memenv/memenv.cc	/^  explicit SequentialFileImpl(FileState* file) : file_(file), pos_(0) {$/;"	f	class:leveldb::__anon17::SequentialFileImpl
SequentialFileImpl	helpers/memenv/memenv.cc	/^class SequentialFileImpl : public SequentialFile {$/;"	c	namespace:leveldb::__anon17	file:
Size	helpers/memenv/memenv.cc	/^  uint64_t Size() const { return size_; }$/;"	f	class:leveldb::__anon17::FileState
Skip	helpers/memenv/memenv.cc	/^  virtual Status Skip(uint64_t n) {$/;"	f	class:leveldb::__anon17::SequentialFileImpl
Sync	helpers/memenv/memenv.cc	/^  virtual Status Sync() { return Status::OK(); }$/;"	f	class:leveldb::__anon17::WritableFileImpl
UnlockFile	helpers/memenv/memenv.cc	/^  virtual Status UnlockFile(FileLock* lock) {$/;"	f	class:leveldb::__anon17::InMemoryEnv
Unref	helpers/memenv/memenv.cc	/^  void Unref() {$/;"	f	class:leveldb::__anon17::FileState
WritableFileImpl	helpers/memenv/memenv.cc	/^  WritableFileImpl(FileState* file) : file_(file) {$/;"	f	class:leveldb::__anon17::WritableFileImpl
WritableFileImpl	helpers/memenv/memenv.cc	/^class WritableFileImpl : public WritableFile {$/;"	c	namespace:leveldb::__anon17	file:
blocks_	helpers/memenv/memenv.cc	/^  std::vector<char*> blocks_;$/;"	m	class:leveldb::__anon17::FileState	file:
file_	helpers/memenv/memenv.cc	/^  FileState* file_;$/;"	m	class:leveldb::__anon17::RandomAccessFileImpl	file:
file_	helpers/memenv/memenv.cc	/^  FileState* file_;$/;"	m	class:leveldb::__anon17::SequentialFileImpl	file:
file_	helpers/memenv/memenv.cc	/^  FileState* file_;$/;"	m	class:leveldb::__anon17::WritableFileImpl	file:
file_map_	helpers/memenv/memenv.cc	/^  FileSystem file_map_;  \/\/ Protected by mutex_.$/;"	m	class:leveldb::__anon17::InMemoryEnv	file:
kBlockSize	helpers/memenv/memenv.cc	/^  enum { kBlockSize = 8 * 1024 };$/;"	e	enum:leveldb::__anon17::FileState::__anon18	file:
leveldb	helpers/memenv/memenv.cc	/^namespace leveldb {$/;"	n	file:
mutex_	helpers/memenv/memenv.cc	/^  port::Mutex mutex_;$/;"	m	class:leveldb::__anon17::InMemoryEnv	file:
pos_	helpers/memenv/memenv.cc	/^  uint64_t pos_;$/;"	m	class:leveldb::__anon17::SequentialFileImpl	file:
refs_	helpers/memenv/memenv.cc	/^  int refs_;  \/\/ Protected by refs_mutex_;$/;"	m	class:leveldb::__anon17::FileState	file:
refs_mutex_	helpers/memenv/memenv.cc	/^  port::Mutex refs_mutex_;$/;"	m	class:leveldb::__anon17::FileState	file:
size_	helpers/memenv/memenv.cc	/^  uint64_t size_;$/;"	m	class:leveldb::__anon17::FileState	file:
~FileState	helpers/memenv/memenv.cc	/^  ~FileState() {$/;"	f	class:leveldb::__anon17::FileState	file:
~InMemoryEnv	helpers/memenv/memenv.cc	/^  virtual ~InMemoryEnv() {$/;"	f	class:leveldb::__anon17::InMemoryEnv
~RandomAccessFileImpl	helpers/memenv/memenv.cc	/^  ~RandomAccessFileImpl() {$/;"	f	class:leveldb::__anon17::RandomAccessFileImpl
~SequentialFileImpl	helpers/memenv/memenv.cc	/^  ~SequentialFileImpl() {$/;"	f	class:leveldb::__anon17::SequentialFileImpl
~WritableFileImpl	helpers/memenv/memenv.cc	/^  ~WritableFileImpl() {$/;"	f	class:leveldb::__anon17::WritableFileImpl
STORAGE_LEVELDB_HELPERS_MEMENV_MEMENV_H_	helpers/memenv/memenv.h	6;"	d
leveldb	helpers/memenv/memenv.h	/^namespace leveldb {$/;"	n
MemEnvTest	helpers/memenv/memenv_test.cc	/^  MemEnvTest()$/;"	f	class:leveldb::MemEnvTest
MemEnvTest	helpers/memenv/memenv_test.cc	/^class MemEnvTest {$/;"	c	namespace:leveldb	file:
TEST	helpers/memenv/memenv_test.cc	/^TEST(MemEnvTest, Basics) {$/;"	f	namespace:leveldb
TEST	helpers/memenv/memenv_test.cc	/^TEST(MemEnvTest, DBTest) {$/;"	f	namespace:leveldb
TEST	helpers/memenv/memenv_test.cc	/^TEST(MemEnvTest, LargeWrite) {$/;"	f	namespace:leveldb
TEST	helpers/memenv/memenv_test.cc	/^TEST(MemEnvTest, Locks) {$/;"	f	namespace:leveldb
TEST	helpers/memenv/memenv_test.cc	/^TEST(MemEnvTest, Misc) {$/;"	f	namespace:leveldb
TEST	helpers/memenv/memenv_test.cc	/^TEST(MemEnvTest, ReadWrite) {$/;"	f	namespace:leveldb
env_	helpers/memenv/memenv_test.cc	/^  Env* env_;$/;"	m	class:leveldb::MemEnvTest	file:
leveldb	helpers/memenv/memenv_test.cc	/^namespace leveldb {$/;"	n	file:
main	helpers/memenv/memenv_test.cc	/^int main(int argc, char** argv) {$/;"	f
~MemEnvTest	helpers/memenv/memenv_test.cc	/^  ~MemEnvTest() {$/;"	f	class:leveldb::MemEnvTest
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
STORAGE_LEVELDB_INCLUDE_C_H_	include/leveldb/c.h	41;"	d
leveldb_cache_t	include/leveldb/c.h	/^typedef struct leveldb_cache_t         leveldb_cache_t;$/;"	t	typeref:struct:leveldb_cache_t
leveldb_comparator_t	include/leveldb/c.h	/^typedef struct leveldb_comparator_t    leveldb_comparator_t;$/;"	t	typeref:struct:leveldb_comparator_t
leveldb_env_t	include/leveldb/c.h	/^typedef struct leveldb_env_t           leveldb_env_t;$/;"	t	typeref:struct:leveldb_env_t
leveldb_filelock_t	include/leveldb/c.h	/^typedef struct leveldb_filelock_t      leveldb_filelock_t;$/;"	t	typeref:struct:leveldb_filelock_t
leveldb_filterpolicy_t	include/leveldb/c.h	/^typedef struct leveldb_filterpolicy_t  leveldb_filterpolicy_t;$/;"	t	typeref:struct:leveldb_filterpolicy_t
leveldb_iterator_t	include/leveldb/c.h	/^typedef struct leveldb_iterator_t      leveldb_iterator_t;$/;"	t	typeref:struct:leveldb_iterator_t
leveldb_logger_t	include/leveldb/c.h	/^typedef struct leveldb_logger_t        leveldb_logger_t;$/;"	t	typeref:struct:leveldb_logger_t
leveldb_no_compression	include/leveldb/c.h	/^  leveldb_no_compression = 0,$/;"	e	enum:__anon19
leveldb_options_t	include/leveldb/c.h	/^typedef struct leveldb_options_t       leveldb_options_t;$/;"	t	typeref:struct:leveldb_options_t
leveldb_randomfile_t	include/leveldb/c.h	/^typedef struct leveldb_randomfile_t    leveldb_randomfile_t;$/;"	t	typeref:struct:leveldb_randomfile_t
leveldb_readoptions_t	include/leveldb/c.h	/^typedef struct leveldb_readoptions_t   leveldb_readoptions_t;$/;"	t	typeref:struct:leveldb_readoptions_t
leveldb_seqfile_t	include/leveldb/c.h	/^typedef struct leveldb_seqfile_t       leveldb_seqfile_t;$/;"	t	typeref:struct:leveldb_seqfile_t
leveldb_snappy_compression	include/leveldb/c.h	/^  leveldb_snappy_compression = 1$/;"	e	enum:__anon19
leveldb_snapshot_t	include/leveldb/c.h	/^typedef struct leveldb_snapshot_t      leveldb_snapshot_t;$/;"	t	typeref:struct:leveldb_snapshot_t
leveldb_t	include/leveldb/c.h	/^typedef struct leveldb_t               leveldb_t;$/;"	t	typeref:struct:leveldb_t
leveldb_writablefile_t	include/leveldb/c.h	/^typedef struct leveldb_writablefile_t  leveldb_writablefile_t;$/;"	t	typeref:struct:leveldb_writablefile_t
leveldb_writebatch_t	include/leveldb/c.h	/^typedef struct leveldb_writebatch_t    leveldb_writebatch_t;$/;"	t	typeref:struct:leveldb_writebatch_t
leveldb_writeoptions_t	include/leveldb/c.h	/^typedef struct leveldb_writeoptions_t  leveldb_writeoptions_t;$/;"	t	typeref:struct:leveldb_writeoptions_t
AllocFilterNums	include/leveldb/cache.h	/^  virtual int AllocFilterNums(int freq) {}$/;"	f	class:leveldb::Cache
Cache	include/leveldb/cache.h	/^  Cache() { }$/;"	f	class:leveldb::Cache
Cache	include/leveldb/cache.h	/^class Cache {$/;"	c	namespace:leveldb
GetLRUFreCount	include/leveldb/cache.h	/^  virtual uint64_t GetLRUFreCount() const{} $/;"	f	class:leveldb::Cache
Handle	include/leveldb/cache.h	/^  struct Handle { };$/;"	s	class:leveldb::Cache
Insert	include/leveldb/cache.h	/^  virtual Handle* Insert(const Slice& key, void* value, size_t charge,$/;"	f	class:leveldb::Cache
IsCacheFull	include/leveldb/cache.h	/^  virtual bool IsCacheFull() const{} $/;"	f	class:leveldb::Cache
LRU_Status	include/leveldb/cache.h	/^  virtual std::string LRU_Status(){}$/;"	f	class:leveldb::Cache
Lookup	include/leveldb/cache.h	/^  virtual Handle* Lookup(const Slice& key,bool Get) {}$/;"	f	class:leveldb::Cache
LookupFreCount	include/leveldb/cache.h	/^  virtual uint64_t LookupFreCount(const Slice & key) {}$/;"	f	class:leveldb::Cache
Prune	include/leveldb/cache.h	/^  virtual void Prune() {}$/;"	f	class:leveldb::Cache
STORAGE_LEVELDB_INCLUDE_CACHE_H_	include/leveldb/cache.h	19;"	d
SetFreCount	include/leveldb/cache.h	/^  virtual void SetFreCount(const Slice & key,uint64_t freCount) {}$/;"	f	class:leveldb::Cache
TurnOffAdjustment	include/leveldb/cache.h	/^  virtual void TurnOffAdjustment() {}$/;"	f	class:leveldb::Cache
TurnOnAdjustment	include/leveldb/cache.h	/^  virtual void TurnOnAdjustment() {}$/;"	f	class:leveldb::Cache
addCurrentTime	include/leveldb/cache.h	/^  virtual void addCurrentTime(){}$/;"	f	class:leveldb::Cache
leveldb	include/leveldb/cache.h	/^namespace leveldb {$/;"	n
rep_	include/leveldb/cache.h	/^  Rep* rep_;$/;"	m	class:leveldb::Cache
Comparator	include/leveldb/comparator.h	/^class Comparator {$/;"	c	namespace:leveldb
FindShortSuccessorBeginWith	include/leveldb/comparator.h	/^  virtual void FindShortSuccessorBeginWith(std::string* key, size_t pos) const {$/;"	f	class:leveldb::Comparator
STORAGE_LEVELDB_INCLUDE_COMPARATOR_H_	include/leveldb/comparator.h	6;"	d
leveldb	include/leveldb/comparator.h	/^namespace leveldb {$/;"	n
DB	include/leveldb/db.h	/^  DB() { }$/;"	f	class:leveldb::DB
DB	include/leveldb/db.h	/^class DB {$/;"	c	namespace:leveldb
DoSomeThing	include/leveldb/db.h	/^  virtual void DoSomeThing(void *arg) {};$/;"	f	class:leveldb::DB
Range	include/leveldb/db.h	/^  Range() { }$/;"	f	struct:leveldb::Range
Range	include/leveldb/db.h	/^  Range(const Slice& s, const Slice& l) : start(s), limit(l) { }$/;"	f	struct:leveldb::Range
Range	include/leveldb/db.h	/^struct Range {$/;"	s	namespace:leveldb
STORAGE_LEVELDB_INCLUDE_DB_H_	include/leveldb/db.h	6;"	d
Snapshot	include/leveldb/db.h	/^class Snapshot {$/;"	c	namespace:leveldb
kMajorVersion	include/leveldb/db.h	/^static const int kMajorVersion = 1;$/;"	m	namespace:leveldb
kMinorVersion	include/leveldb/db.h	/^static const int kMinorVersion = 20;$/;"	m	namespace:leveldb
leveldb	include/leveldb/db.h	/^namespace leveldb {$/;"	n
limit	include/leveldb/db.h	/^  Slice limit;          \/\/ Not included in the range$/;"	m	struct:leveldb::Range
start	include/leveldb/db.h	/^  Slice start;          \/\/ Included in the range$/;"	m	struct:leveldb::Range
STORAGE_LEVELDB_INCLUDE_DUMPFILE_H_	include/leveldb/dumpfile.h	6;"	d
leveldb	include/leveldb/dumpfile.h	/^namespace leveldb {$/;"	n
BOTTOM	include/leveldb/env.h	/^  enum Priority { BOTTOM, LOW, HIGH, TOTAL };$/;"	e	enum:leveldb::Env::Priority
CreateDir	include/leveldb/env.h	/^  Status CreateDir(const std::string& d) { return target_->CreateDir(d); }$/;"	f	class:leveldb::EnvWrapper
DeleteDir	include/leveldb/env.h	/^  Status DeleteDir(const std::string& d) { return target_->DeleteDir(d); }$/;"	f	class:leveldb::EnvWrapper
DeleteFile	include/leveldb/env.h	/^  Status DeleteFile(const std::string& f) { return target_->DeleteFile(f); }$/;"	f	class:leveldb::EnvWrapper
Env	include/leveldb/env.h	/^  Env() { }$/;"	f	class:leveldb::Env
Env	include/leveldb/env.h	/^class Env {$/;"	c	namespace:leveldb
EnvWrapper	include/leveldb/env.h	/^  explicit EnvWrapper(Env* t) : target_(t) { }$/;"	f	class:leveldb::EnvWrapper
EnvWrapper	include/leveldb/env.h	/^class EnvWrapper : public Env {$/;"	c	namespace:leveldb
FileExists	include/leveldb/env.h	/^  bool FileExists(const std::string& f) { return target_->FileExists(f); }$/;"	f	class:leveldb::EnvWrapper
FileLock	include/leveldb/env.h	/^  FileLock() { }$/;"	f	class:leveldb::FileLock
FileLock	include/leveldb/env.h	/^class FileLock {$/;"	c	namespace:leveldb
GetChildren	include/leveldb/env.h	/^  Status GetChildren(const std::string& dir, std::vector<std::string>* r) {$/;"	f	class:leveldb::EnvWrapper
GetFileSize	include/leveldb/env.h	/^  Status GetFileSize(const std::string& f, uint64_t* s) {$/;"	f	class:leveldb::EnvWrapper
GetTestDirectory	include/leveldb/env.h	/^  virtual Status GetTestDirectory(std::string* path) {$/;"	f	class:leveldb::EnvWrapper
HIGH	include/leveldb/env.h	/^  enum Priority { BOTTOM, LOW, HIGH, TOTAL };$/;"	e	enum:leveldb::Env::Priority
IOPriority	include/leveldb/env.h	/^  enum IOPriority {$/;"	g	class:leveldb::Env
IO_HIGH	include/leveldb/env.h	/^    IO_HIGH = 1,$/;"	e	enum:leveldb::Env::IOPriority
IO_LOW	include/leveldb/env.h	/^    IO_LOW = 0,$/;"	e	enum:leveldb::Env::IOPriority
IO_TOTAL	include/leveldb/env.h	/^    IO_TOTAL = 2$/;"	e	enum:leveldb::Env::IOPriority
LOW	include/leveldb/env.h	/^  enum Priority { BOTTOM, LOW, HIGH, TOTAL };$/;"	e	enum:leveldb::Env::Priority
LockFile	include/leveldb/env.h	/^  Status LockFile(const std::string& f, FileLock** l) {$/;"	f	class:leveldb::EnvWrapper
Logger	include/leveldb/env.h	/^  Logger() { }$/;"	f	class:leveldb::Logger
Logger	include/leveldb/env.h	/^class Logger {$/;"	c	namespace:leveldb
NewAppendableFile	include/leveldb/env.h	/^  Status NewAppendableFile(const std::string& f, WritableFile** r) {$/;"	f	class:leveldb::EnvWrapper
NewBufferedRandomAccessFile	include/leveldb/env.h	/^  Status NewBufferedRandomAccessFile(const std::string& f, RandomAccessFile** r){$/;"	f	class:leveldb::EnvWrapper
NewLogger	include/leveldb/env.h	/^  virtual Status NewLogger(const std::string& fname, Logger** result) {$/;"	f	class:leveldb::EnvWrapper
NewRandomAccessFile	include/leveldb/env.h	/^  Status NewRandomAccessFile(const std::string& f, RandomAccessFile** r,bool direct_IO_flag=false) {$/;"	f	class:leveldb::EnvWrapper
NewSequentialFile	include/leveldb/env.h	/^  Status NewSequentialFile(const std::string& f, SequentialFile** r) {$/;"	f	class:leveldb::EnvWrapper
NewWritableFile	include/leveldb/env.h	/^  Status NewWritableFile(const std::string& f, WritableFile** r) {$/;"	f	class:leveldb::EnvWrapper
NowMicros	include/leveldb/env.h	/^  uint64_t NowMicros() {$/;"	f	class:leveldb::EnvWrapper
Priority	include/leveldb/env.h	/^  enum Priority { BOTTOM, LOW, HIGH, TOTAL };$/;"	g	class:leveldb::Env
RandomAccessFile	include/leveldb/env.h	/^  RandomAccessFile(){ }$/;"	f	class:leveldb::RandomAccessFile
RandomAccessFile	include/leveldb/env.h	/^class RandomAccessFile {$/;"	c	namespace:leveldb
Reads	include/leveldb/env.h	/^ virtual Status Reads(uint64_t offset, size_t n, Slice results[],$/;"	f	class:leveldb::RandomAccessFile
RenameFile	include/leveldb/env.h	/^  Status RenameFile(const std::string& s, const std::string& t) {$/;"	f	class:leveldb::EnvWrapper
STORAGE_LEVELDB_INCLUDE_ENV_H_	include/leveldb/env.h	14;"	d
Schedule	include/leveldb/env.h	/^  void Schedule(void (*f)(void*), void* a) {$/;"	f	class:leveldb::EnvWrapper
SequentialFile	include/leveldb/env.h	/^  SequentialFile() { }$/;"	f	class:leveldb::SequentialFile
SequentialFile	include/leveldb/env.h	/^class SequentialFile {$/;"	c	namespace:leveldb
SleepForMicroseconds	include/leveldb/env.h	/^  void SleepForMicroseconds(int micros) {$/;"	f	class:leveldb::EnvWrapper
StartThread	include/leveldb/env.h	/^  void StartThread(void (*f)(void*), void* a) {$/;"	f	class:leveldb::EnvWrapper
TOTAL	include/leveldb/env.h	/^  enum Priority { BOTTOM, LOW, HIGH, TOTAL };$/;"	e	enum:leveldb::Env::Priority
UnlockFile	include/leveldb/env.h	/^  Status UnlockFile(FileLock* l) { return target_->UnlockFile(l); }$/;"	f	class:leveldb::EnvWrapper
WritableFile	include/leveldb/env.h	/^  WritableFile() { }$/;"	f	class:leveldb::WritableFile
WritableFile	include/leveldb/env.h	/^class WritableFile {$/;"	c	namespace:leveldb
leveldb	include/leveldb/env.h	/^namespace leveldb {$/;"	n
target	include/leveldb/env.h	/^  Env* target() const { return target_; }$/;"	f	class:leveldb::EnvWrapper
target_	include/leveldb/env.h	/^  Env* target_;$/;"	m	class:leveldb::EnvWrapper
CreateFilter	include/leveldb/filter_policy.h	/^  virtual void CreateFilter(const Slice *keys,int n,std::list<std::string> &dsts) const{$/;"	f	class:leveldb::FilterPolicy
FilterPolicy	include/leveldb/filter_policy.h	/^class FilterPolicy {$/;"	c	namespace:leveldb
KeyMayMatch	include/leveldb/filter_policy.h	/^  virtual bool KeyMayMatch(const Slice& key,const Slice& filter,int id) const {$/;"	f	class:leveldb::FilterPolicy
KeyMayMatchFilters	include/leveldb/filter_policy.h	/^  virtual bool KeyMayMatchFilters(const Slice& key, const std::list<leveldb::Slice>& filters) const {$/;"	f	class:leveldb::FilterPolicy
STORAGE_LEVELDB_INCLUDE_FILTER_POLICY_H_	include/leveldb/filter_policy.h	17;"	d
bits_per_key_per_filter_	include/leveldb/filter_policy.h	/^  static size_t *bits_per_key_per_filter_;$/;"	m	class:leveldb::FilterPolicy
filterNums	include/leveldb/filter_policy.h	/^  virtual int filterNums() const {$/;"	f	class:leveldb::FilterPolicy
leveldb	include/leveldb/filter_policy.h	/^namespace leveldb {$/;"	n
Cleanup	include/leveldb/iterator.h	/^  struct Cleanup {$/;"	s	class:leveldb::Iterator
CleanupFunction	include/leveldb/iterator.h	/^  typedef void (*CleanupFunction)(void* arg1, void* arg2);$/;"	t	class:leveldb::Iterator
Iterator	include/leveldb/iterator.h	/^class Iterator {$/;"	c	namespace:leveldb
STORAGE_LEVELDB_INCLUDE_ITERATOR_H_	include/leveldb/iterator.h	16;"	d
SeekByValue	include/leveldb/iterator.h	/^  virtual void SeekByValue(uint64_t target) {};$/;"	f	class:leveldb::Iterator
arg1	include/leveldb/iterator.h	/^    void* arg1;$/;"	m	struct:leveldb::Iterator::Cleanup
arg2	include/leveldb/iterator.h	/^    void* arg2;$/;"	m	struct:leveldb::Iterator::Cleanup
cleanup_	include/leveldb/iterator.h	/^  Cleanup cleanup_;$/;"	m	class:leveldb::Iterator
function	include/leveldb/iterator.h	/^    CleanupFunction function;$/;"	m	struct:leveldb::Iterator::Cleanup
leveldb	include/leveldb/iterator.h	/^namespace leveldb {$/;"	n
next	include/leveldb/iterator.h	/^    Cleanup* next;$/;"	m	struct:leveldb::Iterator::Cleanup
CompressionType	include/leveldb/options.h	/^enum CompressionType {$/;"	g	namespace:leveldb
OptionExp	include/leveldb/options.h	/^    OptionExp():no_cache_io_(false),seek_compaction_(false),key_value_size(1000),stats_(nullptr),filter_capacity_ratio(1.0),base_num(64),life_time(50),findAllTable(false),setFreCountInCompaction(false), freq_divide_size(8192), region_divide_size(8192), \/\/2097152(2MB), 134217728(128MB)$/;"	f	struct:leveldb::OptionExp
OptionExp	include/leveldb/options.h	/^typedef struct OptionExp{$/;"	s	namespace:leveldb
OptionExp	include/leveldb/options.h	/^}OptionExp;$/;"	t	namespace:leveldb	typeref:struct:leveldb::OptionExp
Options	include/leveldb/options.h	/^struct Options {$/;"	s	namespace:leveldb
ReadOptions	include/leveldb/options.h	/^  ReadOptions()$/;"	f	struct:leveldb::ReadOptions
ReadOptions	include/leveldb/options.h	/^struct ReadOptions {$/;"	s	namespace:leveldb
STORAGE_LEVELDB_INCLUDE_OPTIONS_H_	include/leveldb/options.h	6;"	d
WriteOptions	include/leveldb/options.h	/^  WriteOptions()$/;"	f	struct:leveldb::WriteOptions
WriteOptions	include/leveldb/options.h	/^struct WriteOptions {$/;"	s	namespace:leveldb
access_compacted_file_nums	include/leveldb/options.h	/^  mutable unsigned short access_compacted_file_nums;$/;"	m	struct:leveldb::ReadOptions
access_file_nums	include/leveldb/options.h	/^  mutable unsigned short access_file_nums;$/;"	m	struct:leveldb::ReadOptions
add_filter	include/leveldb/options.h	/^    mutable bool add_filter;$/;"	m	struct:leveldb::OptionExp
base_num	include/leveldb/options.h	/^    int base_num;$/;"	m	struct:leveldb::OptionExp
block_cache	include/leveldb/options.h	/^  Cache* block_cache;$/;"	m	struct:leveldb::Options
block_restart_interval	include/leveldb/options.h	/^  int block_restart_interval;$/;"	m	struct:leveldb::Options
block_size	include/leveldb/options.h	/^  size_t block_size;$/;"	m	struct:leveldb::Options
change_ratio	include/leveldb/options.h	/^    double change_ratio;$/;"	m	struct:leveldb::OptionExp
comparator	include/leveldb/options.h	/^  const Comparator* comparator;$/;"	m	struct:leveldb::Options
compression	include/leveldb/options.h	/^  CompressionType compression;$/;"	m	struct:leveldb::Options
create_if_missing	include/leveldb/options.h	/^  bool create_if_missing;$/;"	m	struct:leveldb::Options
env	include/leveldb/options.h	/^  Env* env;$/;"	m	struct:leveldb::Options
error_if_exists	include/leveldb/options.h	/^  bool error_if_exists;$/;"	m	struct:leveldb::Options
file_level	include/leveldb/options.h	/^  mutable int file_level;$/;"	m	struct:leveldb::ReadOptions
file_number	include/leveldb/options.h	/^  mutable uint64_t file_number;$/;"	m	struct:leveldb::ReadOptions
fill_cache	include/leveldb/options.h	/^  bool fill_cache;$/;"	m	struct:leveldb::ReadOptions
filter_capacity_ratio	include/leveldb/options.h	/^    double filter_capacity_ratio;$/;"	m	struct:leveldb::OptionExp
filter_policy	include/leveldb/options.h	/^  const FilterPolicy* filter_policy;$/;"	m	struct:leveldb::Options
findAllTable	include/leveldb/options.h	/^    bool findAllTable;$/;"	m	struct:leveldb::OptionExp
force_delete_level0_file	include/leveldb/options.h	/^    bool force_delete_level0_file;$/;"	m	struct:leveldb::OptionExp
force_disable_compaction	include/leveldb/options.h	/^    bool force_disable_compaction;$/;"	m	struct:leveldb::OptionExp
force_shrink_ratio	include/leveldb/options.h	/^    double force_shrink_ratio;$/;"	m	struct:leveldb::OptionExp
fp_stat_num	include/leveldb/options.h	/^    uint64_t fp_stat_num;$/;"	m	struct:leveldb::OptionExp
freq_divide_size	include/leveldb/options.h	/^    uint64_t freq_divide_size;$/;"	m	struct:leveldb::OptionExp
info_log	include/leveldb/options.h	/^  Logger* info_log;$/;"	m	struct:leveldb::Options
init_filter_nums	include/leveldb/options.h	/^    int init_filter_nums;$/;"	m	struct:leveldb::OptionExp
isLevel0	include/leveldb/options.h	/^  bool isLevel0;  \/\/new file isLevel0?$/;"	m	struct:leveldb::ReadOptions
kFilterBaseLg	include/leveldb/options.h	/^    size_t kFilterBaseLg;$/;"	m	struct:leveldb::OptionExp
kNoCompression	include/leveldb/options.h	/^  kNoCompression     = 0x0,$/;"	e	enum:leveldb::CompressionType
kSnappyCompression	include/leveldb/options.h	/^  kSnappyCompression = 0x1$/;"	e	enum:leveldb::CompressionType
key_value_size	include/leveldb/options.h	/^    int key_value_size;$/;"	m	struct:leveldb::OptionExp
l0_base_ratio	include/leveldb/options.h	/^    double l0_base_ratio;$/;"	m	struct:leveldb::OptionExp
leveldb	include/leveldb/options.h	/^namespace leveldb {$/;"	n
life_time	include/leveldb/options.h	/^    uint64_t life_time;$/;"	m	struct:leveldb::OptionExp
log_base	include/leveldb/options.h	/^    int log_base;$/;"	m	struct:leveldb::OptionExp
lrus_num_	include/leveldb/options.h	/^    int lrus_num_;$/;"	m	struct:leveldb::OptionExp
max_file_size	include/leveldb/options.h	/^  size_t max_file_size;$/;"	m	struct:leveldb::Options
max_open_files	include/leveldb/options.h	/^  int max_open_files;$/;"	m	struct:leveldb::Options
no_cache_io_	include/leveldb/options.h	/^    bool no_cache_io_;$/;"	m	struct:leveldb::OptionExp
opEp_	include/leveldb/options.h	/^  struct OptionExp opEp_;$/;"	m	struct:leveldb::Options	typeref:struct:leveldb::Options::OptionExp
paranoid_checks	include/leveldb/options.h	/^  bool paranoid_checks;$/;"	m	struct:leveldb::Options
read_file_nums	include/leveldb/options.h	/^  mutable unsigned short read_file_nums;$/;"	m	struct:leveldb::ReadOptions
region_divide_size	include/leveldb/options.h	/^    uint64_t region_divide_size;$/;"	m	struct:leveldb::OptionExp
reuse_logs	include/leveldb/options.h	/^  bool reuse_logs;$/;"	m	struct:leveldb::Options
seek_compaction_	include/leveldb/options.h	/^    bool seek_compaction_;$/;"	m	struct:leveldb::OptionExp
setFreCountInCompaction	include/leveldb/options.h	/^    bool setFreCountInCompaction;$/;"	m	struct:leveldb::OptionExp
size_ratio	include/leveldb/options.h	/^    int size_ratio;$/;"	m	struct:leveldb::OptionExp
slow_ratio	include/leveldb/options.h	/^    double slow_ratio;$/;"	m	struct:leveldb::OptionExp
slow_shrink_ratio	include/leveldb/options.h	/^    double slow_shrink_ratio;$/;"	m	struct:leveldb::OptionExp
snapshot	include/leveldb/options.h	/^  const Snapshot* snapshot;$/;"	m	struct:leveldb::ReadOptions
stats_	include/leveldb/options.h	/^    std::shared_ptr<Statistics> stats_;$/;"	m	struct:leveldb::OptionExp
sync	include/leveldb/options.h	/^  bool sync;$/;"	m	struct:leveldb::WriteOptions
total_fpr	include/leveldb/options.h	/^  mutable double total_fpr;$/;"	m	struct:leveldb::ReadOptions
verify_checksums	include/leveldb/options.h	/^  bool verify_checksums;$/;"	m	struct:leveldb::ReadOptions
write_buffer_size	include/leveldb/options.h	/^  size_t write_buffer_size;$/;"	m	struct:leveldb::Options
STORAGE_LEVELDB_INCLUDE_SLICE_H_	include/leveldb/slice.h	16;"	d
Slice	include/leveldb/slice.h	/^  Slice() : data_(""), size_(0) { }$/;"	f	class:leveldb::Slice
Slice	include/leveldb/slice.h	/^  Slice(const char* d, size_t n) : data_(d), size_(n) { }$/;"	f	class:leveldb::Slice
Slice	include/leveldb/slice.h	/^  Slice(const char* s) : data_(s), size_(strlen(s)) { }$/;"	f	class:leveldb::Slice
Slice	include/leveldb/slice.h	/^  Slice(const std::string& s) : data_(s.data()), size_(s.size()) { }$/;"	f	class:leveldb::Slice
Slice	include/leveldb/slice.h	/^class Slice {$/;"	c	namespace:leveldb
ToString	include/leveldb/slice.h	/^  std::string ToString() const { return std::string(data_, size_); }$/;"	f	class:leveldb::Slice
clear	include/leveldb/slice.h	/^  void clear() { data_ = ""; size_ = 0; }$/;"	f	class:leveldb::Slice
compare	include/leveldb/slice.h	/^inline int Slice::compare(const Slice& b) const {$/;"	f	class:leveldb::Slice
copy	include/leveldb/slice.h	/^  Slice copy() {$/;"	f	class:leveldb::Slice
data	include/leveldb/slice.h	/^  const char* data() const { return data_; }$/;"	f	class:leveldb::Slice
data_	include/leveldb/slice.h	/^  const char* data_;$/;"	m	class:leveldb::Slice
empty	include/leveldb/slice.h	/^  bool empty() const { return size_ == 0; }$/;"	f	class:leveldb::Slice
leveldb	include/leveldb/slice.h	/^namespace leveldb {$/;"	n
operator !=	include/leveldb/slice.h	/^inline bool operator!=(const Slice& x, const Slice& y) {$/;"	f	namespace:leveldb
operator ==	include/leveldb/slice.h	/^inline bool operator==(const Slice& x, const Slice& y) {$/;"	f	namespace:leveldb
operator []	include/leveldb/slice.h	/^  char operator[](size_t n) const {$/;"	f	class:leveldb::Slice
remove_prefix	include/leveldb/slice.h	/^  void remove_prefix(size_t n) {$/;"	f	class:leveldb::Slice
size	include/leveldb/slice.h	/^  size_t size() const { return size_; }$/;"	f	class:leveldb::Slice
size_	include/leveldb/slice.h	/^  size_t size_;$/;"	m	class:leveldb::Slice
starts_with	include/leveldb/slice.h	/^  bool starts_with(const Slice& x) const {$/;"	f	class:leveldb::Slice
GetStatistics	include/leveldb/statistics.h	/^	static std::shared_ptr<Statistics>  GetStatistics(){$/;"	f	class:leveldb::Statistics
HistogramData	include/leveldb/statistics.h	/^struct HistogramData{$/;"	s	namespace:leveldb
STORAGE_LEVELDB_INCLUDE_STATISTICS_H_	include/leveldb/statistics.h	2;"	d
SetStatisitics	include/leveldb/statistics.h	/^	static void SetStatisitics(std::shared_ptr<Statistics> sp){$/;"	f	class:leveldb::Statistics
Statistics	include/leveldb/statistics.h	/^class Statistics {$/;"	c	namespace:leveldb
TickersNameMap	include/leveldb/statistics.h	/^ const std::vector<std::pair<Tickers,std::string>> TickersNameMap={$/;"	m	namespace:leveldb
average	include/leveldb/statistics.h	/^	double average;$/;"	m	struct:leveldb::HistogramData
histograms_	include/leveldb/statistics.h	/^	HistogramData histograms_[TICKER_ENUM_MAX];$/;"	m	class:leveldb::Statistics
leveldb	include/leveldb/statistics.h	/^namespace leveldb{$/;"	n
max	include/leveldb/statistics.h	/^	double max = 0.0;$/;"	m	struct:leveldb::HistogramData
min	include/leveldb/statistics.h	/^	double min;$/;"	m	struct:leveldb::HistogramData
statis_	include/leveldb/statistics.h	/^	static std::shared_ptr<Statistics> statis_;$/;"	m	class:leveldb::Statistics
tickers_	include/leveldb/statistics.h	/^	uint64_t tickers_[TICKER_ENUM_MAX];$/;"	m	class:leveldb::Statistics
~Statistics	include/leveldb/statistics.h	/^	virtual ~Statistics() {}$/;"	f	class:leveldb::Statistics
Code	include/leveldb/status.h	/^  enum Code {$/;"	g	class:leveldb::Status
Corruption	include/leveldb/status.h	/^  static Status Corruption(const Slice& msg, const Slice& msg2 = Slice()) {$/;"	f	class:leveldb::Status
IOError	include/leveldb/status.h	/^  static Status IOError(const Slice& msg, const Slice& msg2 = Slice()) {$/;"	f	class:leveldb::Status
InvalidArgument	include/leveldb/status.h	/^  static Status InvalidArgument(const Slice& msg, const Slice& msg2 = Slice()) {$/;"	f	class:leveldb::Status
IsCorruption	include/leveldb/status.h	/^  bool IsCorruption() const { return code() == kCorruption; }$/;"	f	class:leveldb::Status
IsIOError	include/leveldb/status.h	/^  bool IsIOError() const { return code() == kIOError; }$/;"	f	class:leveldb::Status
IsInvalidArgument	include/leveldb/status.h	/^  bool IsInvalidArgument() const { return code() == kInvalidArgument; }$/;"	f	class:leveldb::Status
IsNotFound	include/leveldb/status.h	/^  bool IsNotFound() const { return code() == kNotFound; }$/;"	f	class:leveldb::Status
IsNotSupportedError	include/leveldb/status.h	/^  bool IsNotSupportedError() const { return code() == kNotSupported; }$/;"	f	class:leveldb::Status
NotFound	include/leveldb/status.h	/^  static Status NotFound(const Slice& msg, const Slice& msg2 = Slice()) {$/;"	f	class:leveldb::Status
NotSupported	include/leveldb/status.h	/^  static Status NotSupported(const Slice& msg, const Slice& msg2 = Slice()) {$/;"	f	class:leveldb::Status
OK	include/leveldb/status.h	/^  static Status OK() { return Status(); }$/;"	f	class:leveldb::Status
STORAGE_LEVELDB_INCLUDE_STATUS_H_	include/leveldb/status.h	14;"	d
Status	include/leveldb/status.h	/^  Status() : state_(NULL) { }$/;"	f	class:leveldb::Status
Status	include/leveldb/status.h	/^class Status {$/;"	c	namespace:leveldb
Status	include/leveldb/status.h	/^inline Status::Status(const Status& s) {$/;"	f	class:leveldb::Status
code	include/leveldb/status.h	/^  Code code() const {$/;"	f	class:leveldb::Status
kCorruption	include/leveldb/status.h	/^    kCorruption = 2,$/;"	e	enum:leveldb::Status::Code
kIOError	include/leveldb/status.h	/^    kIOError = 5$/;"	e	enum:leveldb::Status::Code
kInvalidArgument	include/leveldb/status.h	/^    kInvalidArgument = 4,$/;"	e	enum:leveldb::Status::Code
kNotFound	include/leveldb/status.h	/^    kNotFound = 1,$/;"	e	enum:leveldb::Status::Code
kNotSupported	include/leveldb/status.h	/^    kNotSupported = 3,$/;"	e	enum:leveldb::Status::Code
kOk	include/leveldb/status.h	/^    kOk = 0,$/;"	e	enum:leveldb::Status::Code
leveldb	include/leveldb/status.h	/^namespace leveldb {$/;"	n
ok	include/leveldb/status.h	/^  bool ok() const { return (state_ == NULL); }$/;"	f	class:leveldb::Status
operator =	include/leveldb/status.h	/^inline void Status::operator=(const Status& s) {$/;"	f	class:leveldb::Status
state_	include/leveldb/status.h	/^  const char* state_;$/;"	m	class:leveldb::Status
~Status	include/leveldb/status.h	/^  ~Status() { delete[] state_; }$/;"	f	class:leveldb::Status
LRU_Fre_Count	include/leveldb/table.h	/^   static uint64_t LRU_Fre_Count;$/;"	m	class:leveldb::Table
STORAGE_LEVELDB_INCLUDE_TABLE_H_	include/leveldb/table.h	6;"	d
Table	include/leveldb/table.h	/^  explicit Table(Rep* rep) : freq_count(0) { rep_ = rep; }$/;"	f	class:leveldb::Table
Table	include/leveldb/table.h	/^class Table {$/;"	c	namespace:leveldb
freq_count	include/leveldb/table.h	/^  int freq_count;$/;"	m	class:leveldb::Table
freqs	include/leveldb/table.h	/^  int *freqs;$/;"	m	class:leveldb::Table
leveldb	include/leveldb/table.h	/^namespace leveldb {$/;"	n
rep_	include/leveldb/table.h	/^  Rep* rep_;$/;"	m	class:leveldb::Table
STORAGE_LEVELDB_INCLUDE_TABLE_BUILDER_H_	include/leveldb/table_builder.h	14;"	d
TableBuilder	include/leveldb/table_builder.h	/^class TableBuilder {$/;"	c	namespace:leveldb
TableMetaData	include/leveldb/table_builder.h	/^struct TableMetaData {$/;"	s	namespace:leveldb
filter_data	include/leveldb/table_builder.h	/^  Slice filter_data[16];$/;"	m	struct:leveldb::TableMetaData
filter_num	include/leveldb/table_builder.h	/^  int filter_num;$/;"	m	struct:leveldb::TableMetaData
index_data	include/leveldb/table_builder.h	/^  Slice index_data;$/;"	m	struct:leveldb::TableMetaData
leveldb	include/leveldb/table_builder.h	/^namespace leveldb {$/;"	n
load_filter_num	include/leveldb/table_builder.h	/^  int *load_filter_num;$/;"	m	struct:leveldb::TableMetaData
metaindex_data	include/leveldb/table_builder.h	/^  Slice metaindex_data;$/;"	m	struct:leveldb::TableMetaData
ok	include/leveldb/table_builder.h	/^  bool ok() const { return status().ok(); }$/;"	f	class:leveldb::TableBuilder
region_num	include/leveldb/table_builder.h	/^  int region_num;$/;"	m	struct:leveldb::TableMetaData
rep_	include/leveldb/table_builder.h	/^  Rep* rep_;$/;"	m	class:leveldb::TableBuilder
tableMetaData_	include/leveldb/table_builder.h	/^  TableMetaData* tableMetaData_;$/;"	m	class:leveldb::TableBuilder
~TableMetaData	include/leveldb/table_builder.h	/^  ~TableMetaData() {$/;"	f	struct:leveldb::TableMetaData
ThreadPool	include/leveldb/threadpool.h	/^class ThreadPool {$/;"	c	namespace:leveldb
leveldb	include/leveldb/threadpool.h	/^namespace leveldb {$/;"	n
~ThreadPool	include/leveldb/threadpool.h	/^  virtual ~ThreadPool() {}$/;"	f	class:leveldb::ThreadPool
Handler	include/leveldb/write_batch.h	/^  class Handler {$/;"	c	class:leveldb::WriteBatch
STORAGE_LEVELDB_INCLUDE_WRITE_BATCH_H_	include/leveldb/write_batch.h	22;"	d
WriteBatch	include/leveldb/write_batch.h	/^class WriteBatch {$/;"	c	namespace:leveldb
leveldb	include/leveldb/write_batch.h	/^namespace leveldb {$/;"	n
rep_	include/leveldb/write_batch.h	/^  std::string rep_;  \/\/ See comment in write_batch.cc for the format of rep_$/;"	m	class:leveldb::WriteBatch
Issue178	issues/issue178_test.cc	/^class Issue178 { };$/;"	c	namespace:__anon20	file:
Key1	issues/issue178_test.cc	/^std::string Key1(int i) {$/;"	f	namespace:__anon20
Key2	issues/issue178_test.cc	/^std::string Key2(int i) {$/;"	f	namespace:__anon20
TEST	issues/issue178_test.cc	/^TEST(Issue178, Test) {$/;"	f	namespace:__anon20
kNumKeys	issues/issue178_test.cc	/^const int kNumKeys = 1100000;$/;"	m	namespace:__anon20	file:
main	issues/issue178_test.cc	/^int main(int argc, char** argv) {$/;"	f
Issue200	issues/issue200_test.cc	/^class Issue200 { };$/;"	c	namespace:leveldb	file:
TEST	issues/issue200_test.cc	/^TEST(Issue200, Test) {$/;"	f	namespace:leveldb
leveldb	issues/issue200_test.cc	/^namespace leveldb {$/;"	n	file:
main	issues/issue200_test.cc	/^int main(int argc, char** argv) {$/;"	f
ARCH_CPU_ARM64_FAMILY	port/atomic_pointer.h	236;"	d
ARCH_CPU_ARM64_FAMILY	port/atomic_pointer.h	39;"	d
ARCH_CPU_ARM_FAMILY	port/atomic_pointer.h	235;"	d
ARCH_CPU_ARM_FAMILY	port/atomic_pointer.h	37;"	d
ARCH_CPU_MIPS_FAMILY	port/atomic_pointer.h	43;"	d
ARCH_CPU_PPC_FAMILY	port/atomic_pointer.h	237;"	d
ARCH_CPU_PPC_FAMILY	port/atomic_pointer.h	41;"	d
ARCH_CPU_X86_FAMILY	port/atomic_pointer.h	234;"	d
ARCH_CPU_X86_FAMILY	port/atomic_pointer.h	33;"	d
ARCH_CPU_X86_FAMILY	port/atomic_pointer.h	35;"	d
Acquire_Load	port/atomic_pointer.h	/^  inline void* Acquire_Load() const {$/;"	f	class:leveldb::port::AtomicPointer
AtomicPointer	port/atomic_pointer.h	/^  AtomicPointer() { }$/;"	f	class:leveldb::port::AtomicPointer
AtomicPointer	port/atomic_pointer.h	/^  explicit AtomicPointer(void* p) : rep_(p) {}$/;"	f	class:leveldb::port::AtomicPointer
AtomicPointer	port/atomic_pointer.h	/^class AtomicPointer {$/;"	c	namespace:leveldb::port
LEVELDB_HAVE_MEMORY_BARRIER	port/atomic_pointer.h	233;"	d
LEVELDB_HAVE_MEMORY_BARRIER	port/atomic_pointer.h	54;"	d
NoBarrier_Load	port/atomic_pointer.h	/^  inline void* NoBarrier_Load() const { return rep_; }$/;"	f	class:leveldb::port::AtomicPointer
NoBarrier_Store	port/atomic_pointer.h	/^  inline void NoBarrier_Store(void* v) { rep_ = v; }$/;"	f	class:leveldb::port::AtomicPointer
PORT_ATOMIC_POINTER_H_	port/atomic_pointer.h	19;"	d
Release_Store	port/atomic_pointer.h	/^  inline void Release_Store(void* v) {$/;"	f	class:leveldb::port::AtomicPointer
leveldb	port/atomic_pointer.h	/^namespace leveldb {$/;"	n
port	port/atomic_pointer.h	/^namespace port {$/;"	n	namespace:leveldb
rep_	port/atomic_pointer.h	/^  void* rep_;$/;"	m	class:leveldb::port::AtomicPointer
STORAGE_LEVELDB_PORT_PORT_H_	port/port.h	6;"	d
AtomicPointer	port/port_example.h	/^  explicit AtomicPointer(void* v) : rep_(v) { }$/;"	f	class:leveldb::port::AtomicPointer
AtomicPointer	port/port_example.h	/^class AtomicPointer {$/;"	c	namespace:leveldb::port
CondVar	port/port_example.h	/^class CondVar {$/;"	c	namespace:leveldb::port
LEVELDB_ONCE_INIT	port/port_example.h	70;"	d
Mutex	port/port_example.h	/^class Mutex {$/;"	c	namespace:leveldb::port
OnceType	port/port_example.h	/^typedef intptr_t OnceType;$/;"	t	namespace:leveldb::port
STORAGE_LEVELDB_PORT_PORT_EXAMPLE_H_	port/port_example.h	11;"	d
kLittleEndian	port/port_example.h	/^static const bool kLittleEndian = true \/* or some other expression *\/;$/;"	m	namespace:leveldb::port
leveldb	port/port_example.h	/^namespace leveldb {$/;"	n
port	port/port_example.h	/^namespace port {$/;"	n	namespace:leveldb
rep_	port/port_example.h	/^  intptr_t rep_;$/;"	m	class:leveldb::port::AtomicPointer
CondVar	port/port_posix.cc	/^CondVar::CondVar(Mutex* mu)$/;"	f	class:leveldb::port::CondVar
InitOnce	port/port_posix.cc	/^void InitOnce(OnceType* once, void (*initializer)()) {$/;"	f	namespace:leveldb::port
Lock	port/port_posix.cc	/^void Mutex::Lock() { PthreadCall("lock", pthread_mutex_lock(&mu_)); }$/;"	f	class:leveldb::port::Mutex
Mutex	port/port_posix.cc	/^Mutex::Mutex() { PthreadCall("init mutex", pthread_mutex_init(&mu_, NULL)); }$/;"	f	class:leveldb::port::Mutex
PthreadCall	port/port_posix.cc	/^static void PthreadCall(const char* label, int result) {$/;"	f	namespace:leveldb::port
Signal	port/port_posix.cc	/^void CondVar::Signal() {$/;"	f	class:leveldb::port::CondVar
SignalAll	port/port_posix.cc	/^void CondVar::SignalAll() {$/;"	f	class:leveldb::port::CondVar
Unlock	port/port_posix.cc	/^void Mutex::Unlock() { PthreadCall("unlock", pthread_mutex_unlock(&mu_)); }$/;"	f	class:leveldb::port::Mutex
Wait	port/port_posix.cc	/^void CondVar::Wait() {$/;"	f	class:leveldb::port::CondVar
leveldb	port/port_posix.cc	/^namespace leveldb {$/;"	n	file:
port	port/port_posix.cc	/^namespace port {$/;"	n	namespace:leveldb	file:
~CondVar	port/port_posix.cc	/^CondVar::~CondVar() { PthreadCall("destroy cv", pthread_cond_destroy(&cv_)); }$/;"	f	class:leveldb::port::CondVar
~Mutex	port/port_posix.cc	/^Mutex::~Mutex() { PthreadCall("destroy mutex", pthread_mutex_destroy(&mu_)); }$/;"	f	class:leveldb::port::Mutex
AsmVolatilePause	port/port_posix.h	/^static inline void AsmVolatilePause() {$/;"	f	namespace:leveldb::port
AssertHeld	port/port_posix.h	/^  void AssertHeld() { }$/;"	f	class:leveldb::port::Mutex
CondVar	port/port_posix.h	/^class CondVar {$/;"	c	namespace:leveldb::port
GetHeapProfile	port/port_posix.h	/^inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {$/;"	f	namespace:leveldb::port
LEVELDB_ONCE_INIT	port/port_posix.h	114;"	d
LEVELDB_PRIszt	port/port_posix.h	9;"	d
Mutex	port/port_posix.h	/^class Mutex {$/;"	c	namespace:leveldb::port
OnceType	port/port_posix.h	/^typedef pthread_once_t OnceType;$/;"	t	namespace:leveldb::port
PLATFORM_IS_LITTLE_ENDIAN	port/port_posix.h	10;"	d
PLATFORM_IS_LITTLE_ENDIAN	port/port_posix.h	14;"	d
PLATFORM_IS_LITTLE_ENDIAN	port/port_posix.h	20;"	d
PLATFORM_IS_LITTLE_ENDIAN	port/port_posix.h	22;"	d
PLATFORM_IS_LITTLE_ENDIAN	port/port_posix.h	28;"	d
PLATFORM_IS_LITTLE_ENDIAN	port/port_posix.h	30;"	d
PLATFORM_IS_LITTLE_ENDIAN	port/port_posix.h	36;"	d
PLATFORM_IS_LITTLE_ENDIAN	port/port_posix.h	51;"	d
PLATFORM_IS_LITTLE_ENDIAN	port/port_posix.h	79;"	d
STORAGE_LEVELDB_PORT_PORT_POSIX_H_	port/port_posix.h	8;"	d
Snappy_Compress	port/port_posix.h	/^inline bool Snappy_Compress(const char* input, size_t length,$/;"	f	namespace:leveldb::port
Snappy_GetUncompressedLength	port/port_posix.h	/^inline bool Snappy_GetUncompressedLength(const char* input, size_t length,$/;"	f	namespace:leveldb::port
Snappy_Uncompress	port/port_posix.h	/^inline bool Snappy_Uncompress(const char* input, size_t length,$/;"	f	namespace:leveldb::port
cv_	port/port_posix.h	/^  pthread_cond_t cv_;$/;"	m	class:leveldb::port::CondVar
fdatasync	port/port_posix.h	66;"	d
fdatasync	port/port_posix.h	72;"	d
fflush_unlocked	port/port_posix.h	60;"	d
fread_unlocked	port/port_posix.h	58;"	d
fwrite_unlocked	port/port_posix.h	59;"	d
kLittleEndian	port/port_posix.h	/^static const bool kLittleEndian = PLATFORM_IS_LITTLE_ENDIAN;$/;"	m	namespace:leveldb::port
leveldb	port/port_posix.h	/^namespace leveldb {$/;"	n
mu_	port/port_posix.h	/^  Mutex* mu_;$/;"	m	class:leveldb::port::CondVar
mu_	port/port_posix.h	/^  pthread_mutex_t mu_;$/;"	m	class:leveldb::port::Mutex
port	port/port_posix.h	/^namespace port {$/;"	n	namespace:leveldb
AcceleratedCRC32C	port/port_posix_sse.cc	/^uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size) {$/;"	f	namespace:leveldb::port
HaveSSE42	port/port_posix_sse.cc	/^static inline bool HaveSSE42() {$/;"	f	namespace:leveldb::port
LE_LOAD32	port/port_posix_sse.cc	/^static inline uint32_t LE_LOAD32(const uint8_t *p) {$/;"	f	namespace:leveldb::port
LE_LOAD64	port/port_posix_sse.cc	/^static inline uint64_t LE_LOAD64(const uint8_t *p) {$/;"	f	namespace:leveldb::port
leveldb	port/port_posix_sse.cc	/^namespace leveldb {$/;"	n	file:
port	port/port_posix_sse.cc	/^namespace port {$/;"	n	namespace:leveldb	file:
EXCLUSIVE_LOCKS_REQUIRED	port/thread_annotations.h	13;"	d
EXCLUSIVE_LOCK_FUNCTION	port/thread_annotations.h	37;"	d
EXCLUSIVE_TRYLOCK_FUNCTION	port/thread_annotations.h	45;"	d
LOCKABLE	port/thread_annotations.h	29;"	d
LOCKS_EXCLUDED	port/thread_annotations.h	21;"	d
LOCK_RETURNED	port/thread_annotations.h	25;"	d
NO_THREAD_SAFETY_ANALYSIS	port/thread_annotations.h	57;"	d
SCOPED_LOCKABLE	port/thread_annotations.h	33;"	d
SHARED_LOCKS_REQUIRED	port/thread_annotations.h	17;"	d
SHARED_LOCK_FUNCTION	port/thread_annotations.h	41;"	d
SHARED_TRYLOCK_FUNCTION	port/thread_annotations.h	49;"	d
STORAGE_LEVELDB_PORT_THREAD_ANNOTATIONS_H_	port/thread_annotations.h	6;"	d
UNLOCK_FUNCTION	port/thread_annotations.h	53;"	d
STORAGE_LEVELDB_PORT_WIN_STDINT_H_	port/win/stdint.h	8;"	d
int16_t	port/win/stdint.h	/^typedef signed short          int16_t;$/;"	t
int32_t	port/win/stdint.h	/^typedef signed int            int32_t;$/;"	t
int64_t	port/win/stdint.h	/^typedef signed long long      int64_t;$/;"	t
int8_t	port/win/stdint.h	/^typedef signed char           int8_t;$/;"	t
uint16_t	port/win/stdint.h	/^typedef unsigned short        uint16_t;$/;"	t
uint32_t	port/win/stdint.h	/^typedef unsigned int          uint32_t;$/;"	t
uint64_t	port/win/stdint.h	/^typedef unsigned long long    uint64_t;$/;"	t
uint8_t	port/win/stdint.h	/^typedef unsigned char         uint8_t;$/;"	t
Block	table/block.cc	/^Block::Block(const BlockContents& contents)$/;"	f	class:leveldb::Block
Compare	table/block.cc	/^  inline int Compare(const Slice& a, const Slice& b) const {$/;"	f	class:leveldb::Block::Iter	file:
CorruptionError	table/block.cc	/^  void CorruptionError() {$/;"	f	class:leveldb::Block::Iter	file:
DecodeEntry	table/block.cc	/^static inline const char* DecodeEntry(const char* p, const char* limit,$/;"	f	namespace:leveldb
GetRestartPoint	table/block.cc	/^  uint32_t GetRestartPoint(uint32_t index) {$/;"	f	class:leveldb::Block::Iter	file:
Iter	table/block.cc	/^  Iter(const Comparator* comparator,$/;"	f	class:leveldb::Block::Iter
Iter	table/block.cc	/^class Block::Iter : public Iterator {$/;"	c	class:leveldb::Block	file:
NewIterator	table/block.cc	/^Iterator* Block::NewIterator(const Comparator* cmp) {$/;"	f	class:leveldb::Block
Next	table/block.cc	/^  virtual void Next() {$/;"	f	class:leveldb::Block::Iter
NextEntryOffset	table/block.cc	/^  inline uint32_t NextEntryOffset() const {$/;"	f	class:leveldb::Block::Iter	file:
NumRestarts	table/block.cc	/^inline uint32_t Block::NumRestarts() const {$/;"	f	class:leveldb::Block
ParseNextKey	table/block.cc	/^  bool ParseNextKey() {$/;"	f	class:leveldb::Block::Iter	file:
Prev	table/block.cc	/^  virtual void Prev() {$/;"	f	class:leveldb::Block::Iter
Seek	table/block.cc	/^  virtual void Seek(const Slice& target) {$/;"	f	class:leveldb::Block::Iter
SeekByValue	table/block.cc	/^  virtual void SeekByValue(uint64_t target) {$/;"	f	class:leveldb::Block::Iter
SeekToFirst	table/block.cc	/^  virtual void SeekToFirst() {$/;"	f	class:leveldb::Block::Iter
SeekToLast	table/block.cc	/^  virtual void SeekToLast() {$/;"	f	class:leveldb::Block::Iter
SeekToRestartPoint	table/block.cc	/^  void SeekToRestartPoint(uint32_t index) {$/;"	f	class:leveldb::Block::Iter	file:
Valid	table/block.cc	/^  virtual bool Valid() const { return current_ < restarts_; }$/;"	f	class:leveldb::Block::Iter
comparator_	table/block.cc	/^  const Comparator* const comparator_;$/;"	m	class:leveldb::Block::Iter	file:
current_	table/block.cc	/^  uint32_t current_;$/;"	m	class:leveldb::Block::Iter	file:
data_	table/block.cc	/^  const char* const data_;      \/\/ underlying block contents$/;"	m	class:leveldb::Block::Iter	file:
key	table/block.cc	/^  virtual Slice key() const {$/;"	f	class:leveldb::Block::Iter
key_	table/block.cc	/^  std::string key_;$/;"	m	class:leveldb::Block::Iter	file:
leveldb	table/block.cc	/^namespace leveldb {$/;"	n	file:
num_restarts_	table/block.cc	/^  uint32_t const num_restarts_; \/\/ Number of uint32_t entries in restart array$/;"	m	class:leveldb::Block::Iter	file:
restart_index_	table/block.cc	/^  uint32_t restart_index_;  \/\/ Index of restart block in which current_ falls$/;"	m	class:leveldb::Block::Iter	file:
restarts_	table/block.cc	/^  uint32_t const restarts_;     \/\/ Offset of restart array (list of fixed32)$/;"	m	class:leveldb::Block::Iter	file:
status	table/block.cc	/^  virtual Status status() const { return status_; }$/;"	f	class:leveldb::Block::Iter
status_	table/block.cc	/^  Status status_;$/;"	m	class:leveldb::Block::Iter	file:
value	table/block.cc	/^  virtual Slice value() const {$/;"	f	class:leveldb::Block::Iter
value_	table/block.cc	/^  Slice value_;$/;"	m	class:leveldb::Block::Iter	file:
~Block	table/block.cc	/^Block::~Block() {$/;"	f	class:leveldb::Block
Block	table/block.h	/^class Block {$/;"	c	namespace:leveldb
STORAGE_LEVELDB_TABLE_BLOCK_H_	table/block.h	6;"	d
data_	table/block.h	/^  const char* data_;$/;"	m	class:leveldb::Block
leveldb	table/block.h	/^namespace leveldb {$/;"	n
owned_	table/block.h	/^  bool owned_;                  \/\/ Block owns data_[]$/;"	m	class:leveldb::Block
restart_offset_	table/block.h	/^  uint32_t restart_offset_;     \/\/ Offset in data_ of restart array$/;"	m	class:leveldb::Block
size	table/block.h	/^  size_t size() const { return size_; }$/;"	f	class:leveldb::Block
size_	table/block.h	/^  size_t size_;$/;"	m	class:leveldb::Block
Add	table/block_builder.cc	/^void BlockBuilder::Add(const Slice& key, const Slice& value) {$/;"	f	class:leveldb::BlockBuilder
BlockBuilder	table/block_builder.cc	/^BlockBuilder::BlockBuilder(const Options* options)$/;"	f	class:leveldb::BlockBuilder
CurrentSizeEstimate	table/block_builder.cc	/^size_t BlockBuilder::CurrentSizeEstimate() const {$/;"	f	class:leveldb::BlockBuilder
Finish	table/block_builder.cc	/^Slice BlockBuilder::Finish() {$/;"	f	class:leveldb::BlockBuilder
Reset	table/block_builder.cc	/^void BlockBuilder::Reset() {$/;"	f	class:leveldb::BlockBuilder
leveldb	table/block_builder.cc	/^namespace leveldb {$/;"	n	file:
BlockBuilder	table/block_builder.h	/^class BlockBuilder {$/;"	c	namespace:leveldb
STORAGE_LEVELDB_TABLE_BLOCK_BUILDER_H_	table/block_builder.h	6;"	d
buffer_	table/block_builder.h	/^  std::string           buffer_;      \/\/ Destination buffer$/;"	m	class:leveldb::BlockBuilder
counter_	table/block_builder.h	/^  int                   counter_;     \/\/ Number of entries emitted since restart$/;"	m	class:leveldb::BlockBuilder
empty	table/block_builder.h	/^  bool empty() const {$/;"	f	class:leveldb::BlockBuilder
finished_	table/block_builder.h	/^  bool                  finished_;    \/\/ Has Finish() been called?$/;"	m	class:leveldb::BlockBuilder
last_key_	table/block_builder.h	/^  std::string           last_key_;$/;"	m	class:leveldb::BlockBuilder
leveldb	table/block_builder.h	/^namespace leveldb {$/;"	n
options_	table/block_builder.h	/^  const Options*        options_;$/;"	m	class:leveldb::BlockBuilder
restarts_	table/block_builder.h	/^  std::vector<uint32_t> restarts_;    \/\/ Restart points$/;"	m	class:leveldb::BlockBuilder
AddFilter	table/filter_block.cc	/^void FilterBlockReader::AddFilter(Slice &contents, int regionId)$/;"	f	class:leveldb::FilterBlockReader
AddKey	table/filter_block.cc	/^void FilterBlockBuilder::AddKey(const Slice& key) {$/;"	f	class:leveldb::FilterBlockBuilder
CreateThread	table/filter_block.cc	/^void FilterBlockReader::CreateThread(int filters_num,const leveldb::FilterPolicy *policy)$/;"	f	class:leveldb::FilterBlockReader
FilterBlockBuilder	table/filter_block.cc	/^FilterBlockBuilder::FilterBlockBuilder(const FilterPolicy* policy)$/;"	f	class:leveldb::FilterBlockBuilder
FilterBlockReader	table/filter_block.cc	/^FilterBlockReader::FilterBlockReader(const FilterPolicy* policy,$/;"	f	class:leveldb::FilterBlockReader
Finish	table/filter_block.cc	/^std::list<std::string>& FilterBlockBuilder::Finish() {$/;"	f	class:leveldb::FilterBlockBuilder
GenerateFilter	table/filter_block.cc	/^void FilterBlockBuilder::GenerateFilter() {$/;"	f	class:leveldb::FilterBlockBuilder
KeyMayMatch	table/filter_block.cc	/^bool FilterBlockReader::KeyMayMatch(uint64_t block_offset, const Slice &key)$/;"	f	class:leveldb::FilterBlockReader
KeyMayMatch_Thread	table/filter_block.cc	/^void *FilterBlockReader::KeyMayMatch_Thread(void* arg)$/;"	f	class:leveldb::FilterBlockReader
RemoveFilters	table/filter_block.cc	/^size_t FilterBlockReader::RemoveFilters(int n, int regionId)$/;"	f	class:leveldb::FilterBlockReader
StartBlock	table/filter_block.cc	/^void FilterBlockBuilder::StartBlock(uint64_t block_offset) {$/;"	f	class:leveldb::FilterBlockBuilder
filter_datas	table/filter_block.cc	/^std::vector<const char*> *FilterBlockReader::filter_datas = NULL;$/;"	m	class:leveldb::FilterBlockReader	file:
filter_key	table/filter_block.cc	/^Slice FilterBlockReader::filter_key;$/;"	m	class:leveldb::FilterBlockReader	file:
getCurrFpr	table/filter_block.cc	/^double FilterBlockReader::getCurrFpr() {$/;"	f	class:leveldb::FilterBlockReader
getOffsets	table/filter_block.cc	/^std::string* FilterBlockBuilder::getOffsets(int which) {$/;"	f	class:leveldb::FilterBlockBuilder
handle_error_en	table/filter_block.cc	14;"	d	file:
kFilterBase	table/filter_block.cc	/^static const size_t kFilterBase = 1 << kFilterBaseLg;$/;"	m	namespace:leveldb	file:
kFilterBaseLg	table/filter_block.cc	/^static const size_t kFilterBaseLg = 16;  \/\/try every 64KB of data$/;"	m	namespace:leveldb	file:
leveldb	table/filter_block.cc	/^namespace leveldb {$/;"	n	file:
matches	table/filter_block.cc	/^bool FilterBlockReader::matches[8];$/;"	m	class:leveldb::FilterBlockReader	file:
pids_	table/filter_block.cc	/^pthread_t FilterBlockReader::pids_[8];$/;"	m	class:leveldb::FilterBlockReader	file:
start_matches	table/filter_block.cc	/^std::atomic<bool> FilterBlockReader::start_matches[8];$/;"	m	class:leveldb::FilterBlockReader	file:
~FilterBlockReader	table/filter_block.cc	/^FilterBlockReader::~FilterBlockReader() {$/;"	f	class:leveldb::FilterBlockReader
FilterBlockBuilder	table/filter_block.h	/^class FilterBlockBuilder {$/;"	c	namespace:leveldb
FilterBlockReader	table/filter_block.h	/^class FilterBlockReader {$/;"	c	namespace:leveldb
STORAGE_LEVELDB_TABLE_FILTER_BLOCK_H_	table/filter_block.h	10;"	d
base_lg_	table/filter_block.h	/^  size_t base_lg_;      \/\/ Encoding parameter (see kFilterBaseLg in .cc file)$/;"	m	class:leveldb::FilterBlockReader
curr_num_of_filters_	table/filter_block.h	/^  int curr_num_of_filters_;$/;"	m	class:leveldb::FilterBlockReader
curr_num_of_filters_regions_	table/filter_block.h	/^  int *curr_num_of_filters_regions_;$/;"	m	class:leveldb::FilterBlockReader
datas_	table/filter_block.h	/^  std::vector<std::vector<const char*>> datas_;    \/\/ Pointer to filter data (at block-start)$/;"	m	class:leveldb::FilterBlockReader
end_thread	table/filter_block.h	/^  static bool end_thread;$/;"	m	class:leveldb::FilterBlockReader
filter_datas	table/filter_block.h	/^  static std::vector<const char*> *filter_datas;$/;"	m	class:leveldb::FilterBlockReader
filter_index	table/filter_block.h	/^  static int filter_index;$/;"	m	class:leveldb::FilterBlockReader
filter_key	table/filter_block.h	/^  static Slice filter_key;$/;"	m	class:leveldb::FilterBlockReader
filter_offsets	table/filter_block.h	/^  std::vector<std::vector<uint32_t>> *filter_offsets;$/;"	m	class:leveldb::FilterBlockReader
filter_offsets_	table/filter_block.h	/^  std::vector<uint32_t> filter_offsets_;$/;"	m	class:leveldb::FilterBlockReader
filter_policy	table/filter_block.h	/^  static const FilterPolicy *filter_policy;$/;"	m	class:leveldb::FilterBlockReader
filters_offsets_	table/filter_block.h	/^  std::list<std::vector<uint32_t>> filters_offsets_;$/;"	m	class:leveldb::FilterBlockBuilder
getCurrFiltersNum	table/filter_block.h	/^  inline int getCurrFiltersNum(int regionId){$/;"	f	class:leveldb::FilterBlockReader
keys_	table/filter_block.h	/^  std::string keys_;              \/\/ Flattened key contents$/;"	m	class:leveldb::FilterBlockBuilder
leveldb	table/filter_block.h	/^namespace leveldb {$/;"	n
matches	table/filter_block.h	/^  static bool matches[8];$/;"	m	class:leveldb::FilterBlockReader
max_num_of_filters_	table/filter_block.h	/^  int max_num_of_filters_;$/;"	m	class:leveldb::FilterBlockReader
num_	table/filter_block.h	/^  size_t num_;          \/\/ Number of entries in offset array$/;"	m	class:leveldb::FilterBlockReader
num_regions	table/filter_block.h	/^  int num_regions;$/;"	m	class:leveldb::FilterBlockReader
pids_	table/filter_block.h	/^  static pthread_t pids_[8];$/;"	m	class:leveldb::FilterBlockReader
policy_	table/filter_block.h	/^  const FilterPolicy* policy_;$/;"	m	class:leveldb::FilterBlockBuilder
policy_	table/filter_block.h	/^  const FilterPolicy* policy_;$/;"	m	class:leveldb::FilterBlockReader
pthread_created	table/filter_block.h	/^  static bool pthread_created;$/;"	m	class:leveldb::FilterBlockReader
regionFilters	table/filter_block.h	/^  int regionFilters;$/;"	m	class:leveldb::FilterBlockReader
results_	table/filter_block.h	/^  std::list<std::string> results_;$/;"	m	class:leveldb::FilterBlockBuilder
start_	table/filter_block.h	/^  std::vector<size_t> start_;     \/\/ Starting index in keys_ of each key$/;"	m	class:leveldb::FilterBlockBuilder
start_matches	table/filter_block.h	/^  static std::atomic<bool> start_matches[8];$/;"	m	class:leveldb::FilterBlockReader
tmp_keys_	table/filter_block.h	/^  std::vector<Slice> tmp_keys_;   \/\/ policy_->CreateFilter() argument$/;"	m	class:leveldb::FilterBlockBuilder
CreateFilter	table/filter_block_test.cc	/^  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {$/;"	f	class:leveldb::TestHashFilter
FilterBlockTest	table/filter_block_test.cc	/^class FilterBlockTest {$/;"	c	namespace:leveldb	file:
KeyMayMatch	table/filter_block_test.cc	/^  virtual bool KeyMayMatch(const Slice& key, const Slice& filter) const {$/;"	f	class:leveldb::TestHashFilter
Name	table/filter_block_test.cc	/^  virtual const char* Name() const {$/;"	f	class:leveldb::TestHashFilter
TestHashFilter	table/filter_block_test.cc	/^class TestHashFilter : public FilterPolicy {$/;"	c	namespace:leveldb	file:
leveldb	table/filter_block_test.cc	/^namespace leveldb {$/;"	n	file:
main	table/filter_block_test.cc	/^int main(int argc, char** argv) {$/;"	f
policy_	table/filter_block_test.cc	/^  TestHashFilter policy_;$/;"	m	class:leveldb::FilterBlockTest	file:
DecodeFrom	table/format.cc	/^Status BlockHandle::DecodeFrom(Slice* input) {$/;"	f	class:leveldb::BlockHandle
DecodeFrom	table/format.cc	/^Status Footer::DecodeFrom(Slice* input) {$/;"	f	class:leveldb::Footer
EncodeTo	table/format.cc	/^void BlockHandle::EncodeTo(std::string* dst) const {$/;"	f	class:leveldb::BlockHandle
EncodeTo	table/format.cc	/^void Footer::EncodeTo(std::string* dst) const {$/;"	f	class:leveldb::Footer
ReadBlock	table/format.cc	/^Status ReadBlock(RandomAccessFile* file,$/;"	f	namespace:leveldb
ReadBlocks	table/format.cc	/^Status ReadBlocks(RandomAccessFile* file,$/;"	f	namespace:leveldb
leveldb	table/format.cc	/^namespace leveldb {$/;"	n	file:
BlockContents	table/format.h	/^struct BlockContents {$/;"	s	namespace:leveldb
BlockHandle	table/format.h	/^class BlockHandle {$/;"	c	namespace:leveldb
BlockHandle	table/format.h	/^inline BlockHandle::BlockHandle()$/;"	f	class:leveldb::BlockHandle
Footer	table/format.h	/^  Footer() { }$/;"	f	class:leveldb::Footer
Footer	table/format.h	/^class Footer {$/;"	c	namespace:leveldb
STORAGE_LEVELDB_TABLE_FORMAT_H_	table/format.h	6;"	d
cachable	table/format.h	/^  bool cachable;        \/\/ True iff data can be cached$/;"	m	struct:leveldb::BlockContents
data	table/format.h	/^  Slice data;           \/\/ Actual contents of data$/;"	m	struct:leveldb::BlockContents
heap_allocated	table/format.h	/^  bool heap_allocated;  \/\/ True iff caller should delete[] data.data()$/;"	m	struct:leveldb::BlockContents
index_handle	table/format.h	/^  const BlockHandle& index_handle() const {$/;"	f	class:leveldb::Footer
index_handle_	table/format.h	/^  BlockHandle index_handle_;$/;"	m	class:leveldb::Footer
kBlockTrailerSize	table/format.h	/^static const size_t kBlockTrailerSize = 5;$/;"	m	namespace:leveldb
kEncodedLength	table/format.h	/^    kEncodedLength = 2*BlockHandle::kMaxEncodedLength + 8$/;"	e	enum:leveldb::Footer::__anon27
kMaxEncodedLength	table/format.h	/^  enum { kMaxEncodedLength = 10 + 10 };$/;"	e	enum:leveldb::BlockHandle::__anon26
kTableMagicNumber	table/format.h	/^static const uint64_t kTableMagicNumber = 0xdb4775248b80fb57ull;$/;"	m	namespace:leveldb
leveldb	table/format.h	/^namespace leveldb {$/;"	n
metaindex_handle	table/format.h	/^  const BlockHandle& metaindex_handle() const { return metaindex_handle_; }$/;"	f	class:leveldb::Footer
metaindex_handle_	table/format.h	/^  BlockHandle metaindex_handle_;$/;"	m	class:leveldb::Footer
offset	table/format.h	/^  uint64_t offset() const { return offset_; }$/;"	f	class:leveldb::BlockHandle
offset_	table/format.h	/^  uint64_t offset_;$/;"	m	class:leveldb::BlockHandle
set_index_handle	table/format.h	/^  void set_index_handle(const BlockHandle& h) {$/;"	f	class:leveldb::Footer
set_metaindex_handle	table/format.h	/^  void set_metaindex_handle(const BlockHandle& h) { metaindex_handle_ = h; }$/;"	f	class:leveldb::Footer
set_offset	table/format.h	/^  void set_offset(uint64_t offset) { offset_ = offset; }$/;"	f	class:leveldb::BlockHandle
set_size	table/format.h	/^  void set_size(uint64_t size) { size_ = size; }$/;"	f	class:leveldb::BlockHandle
size	table/format.h	/^  uint64_t size() const { return size_; }$/;"	f	class:leveldb::BlockHandle
size_	table/format.h	/^  uint64_t size_;$/;"	m	class:leveldb::BlockHandle
EmptyIterator	table/iterator.cc	/^  EmptyIterator(const Status& s) : status_(s) { }$/;"	f	class:leveldb::__anon21::EmptyIterator
EmptyIterator	table/iterator.cc	/^class EmptyIterator : public Iterator {$/;"	c	namespace:leveldb::__anon21	file:
Iterator	table/iterator.cc	/^Iterator::Iterator() {$/;"	f	class:leveldb::Iterator
NewEmptyIterator	table/iterator.cc	/^Iterator* NewEmptyIterator() {$/;"	f	namespace:leveldb
NewErrorIterator	table/iterator.cc	/^Iterator* NewErrorIterator(const Status& status) {$/;"	f	namespace:leveldb
Next	table/iterator.cc	/^  virtual void Next() { assert(false); }$/;"	f	class:leveldb::__anon21::EmptyIterator
Prev	table/iterator.cc	/^  virtual void Prev() { assert(false); }$/;"	f	class:leveldb::__anon21::EmptyIterator
RegisterCleanup	table/iterator.cc	/^void Iterator::RegisterCleanup(CleanupFunction func, void* arg1, void* arg2) {$/;"	f	class:leveldb::Iterator
Seek	table/iterator.cc	/^  virtual void Seek(const Slice& target) { }$/;"	f	class:leveldb::__anon21::EmptyIterator
SeekToFirst	table/iterator.cc	/^  virtual void SeekToFirst() { }$/;"	f	class:leveldb::__anon21::EmptyIterator
SeekToLast	table/iterator.cc	/^  virtual void SeekToLast() { }$/;"	f	class:leveldb::__anon21::EmptyIterator
Valid	table/iterator.cc	/^  virtual bool Valid() const { return false; }$/;"	f	class:leveldb::__anon21::EmptyIterator
key	table/iterator.cc	/^  Slice key() const { assert(false); return Slice(); }$/;"	f	class:leveldb::__anon21::EmptyIterator
leveldb	table/iterator.cc	/^namespace leveldb {$/;"	n	file:
status	table/iterator.cc	/^  virtual Status status() const { return status_; }$/;"	f	class:leveldb::__anon21::EmptyIterator
status_	table/iterator.cc	/^  Status status_;$/;"	m	class:leveldb::__anon21::EmptyIterator	file:
value	table/iterator.cc	/^  Slice value() const { assert(false); return Slice(); }$/;"	f	class:leveldb::__anon21::EmptyIterator
~Iterator	table/iterator.cc	/^Iterator::~Iterator() {$/;"	f	class:leveldb::Iterator
IteratorWrapper	table/iterator_wrapper.h	/^  IteratorWrapper(): iter_(NULL), valid_(false) { }$/;"	f	class:leveldb::IteratorWrapper
IteratorWrapper	table/iterator_wrapper.h	/^  explicit IteratorWrapper(Iterator* iter): iter_(NULL) {$/;"	f	class:leveldb::IteratorWrapper
IteratorWrapper	table/iterator_wrapper.h	/^class IteratorWrapper {$/;"	c	namespace:leveldb
Next	table/iterator_wrapper.h	/^  void Next()               { assert(iter_); iter_->Next();        Update(); }$/;"	f	class:leveldb::IteratorWrapper
Prev	table/iterator_wrapper.h	/^  void Prev()               { assert(iter_); iter_->Prev();        Update(); }$/;"	f	class:leveldb::IteratorWrapper
STORAGE_LEVELDB_TABLE_ITERATOR_WRAPPER_H_	table/iterator_wrapper.h	6;"	d
Seek	table/iterator_wrapper.h	/^  void Seek(const Slice& k) { assert(iter_); iter_->Seek(k);       Update(); }$/;"	f	class:leveldb::IteratorWrapper
SeekToFirst	table/iterator_wrapper.h	/^  void SeekToFirst()        { assert(iter_); iter_->SeekToFirst(); Update(); }$/;"	f	class:leveldb::IteratorWrapper
SeekToLast	table/iterator_wrapper.h	/^  void SeekToLast()         { assert(iter_); iter_->SeekToLast();  Update(); }$/;"	f	class:leveldb::IteratorWrapper
Set	table/iterator_wrapper.h	/^  void Set(Iterator* iter) {$/;"	f	class:leveldb::IteratorWrapper
Update	table/iterator_wrapper.h	/^  void Update() {$/;"	f	class:leveldb::IteratorWrapper
Valid	table/iterator_wrapper.h	/^  bool Valid() const        { return valid_; }$/;"	f	class:leveldb::IteratorWrapper
iter	table/iterator_wrapper.h	/^  Iterator* iter() const { return iter_; }$/;"	f	class:leveldb::IteratorWrapper
iter_	table/iterator_wrapper.h	/^  Iterator* iter_;$/;"	m	class:leveldb::IteratorWrapper
key	table/iterator_wrapper.h	/^  Slice key() const         { assert(Valid()); return key_; }$/;"	f	class:leveldb::IteratorWrapper
key_	table/iterator_wrapper.h	/^  Slice key_;$/;"	m	class:leveldb::IteratorWrapper
leveldb	table/iterator_wrapper.h	/^namespace leveldb {$/;"	n
status	table/iterator_wrapper.h	/^  Status status() const     { assert(iter_); return iter_->status(); }$/;"	f	class:leveldb::IteratorWrapper
valid_	table/iterator_wrapper.h	/^  bool valid_;$/;"	m	class:leveldb::IteratorWrapper
value	table/iterator_wrapper.h	/^  Slice value() const       { assert(Valid()); return iter_->value(); }$/;"	f	class:leveldb::IteratorWrapper
~IteratorWrapper	table/iterator_wrapper.h	/^  ~IteratorWrapper() { delete iter_; }$/;"	f	class:leveldb::IteratorWrapper
Direction	table/merger.cc	/^  enum Direction {$/;"	g	class:leveldb::__anon22::MergingIterator	file:
FindLargest	table/merger.cc	/^void MergingIterator::FindLargest() {$/;"	f	class:leveldb::__anon22::MergingIterator
FindSmallest	table/merger.cc	/^void MergingIterator::FindSmallest() {$/;"	f	class:leveldb::__anon22::MergingIterator
MergingIterator	table/merger.cc	/^  MergingIterator(const Comparator* comparator, Iterator** children, int n)$/;"	f	class:leveldb::__anon22::MergingIterator
MergingIterator	table/merger.cc	/^class MergingIterator : public Iterator {$/;"	c	namespace:leveldb::__anon22	file:
NewMergingIterator	table/merger.cc	/^Iterator* NewMergingIterator(const Comparator* cmp, Iterator** list, int n) {$/;"	f	namespace:leveldb
Next	table/merger.cc	/^  virtual void Next() {$/;"	f	class:leveldb::__anon22::MergingIterator
Prev	table/merger.cc	/^  virtual void Prev() {$/;"	f	class:leveldb::__anon22::MergingIterator
Seek	table/merger.cc	/^  virtual void Seek(const Slice& target) {$/;"	f	class:leveldb::__anon22::MergingIterator
SeekToFirst	table/merger.cc	/^  virtual void SeekToFirst() {$/;"	f	class:leveldb::__anon22::MergingIterator
SeekToLast	table/merger.cc	/^  virtual void SeekToLast() {$/;"	f	class:leveldb::__anon22::MergingIterator
Valid	table/merger.cc	/^  virtual bool Valid() const {$/;"	f	class:leveldb::__anon22::MergingIterator
children_	table/merger.cc	/^  IteratorWrapper* children_;$/;"	m	class:leveldb::__anon22::MergingIterator	file:
comparator_	table/merger.cc	/^  const Comparator* comparator_;$/;"	m	class:leveldb::__anon22::MergingIterator	file:
current_	table/merger.cc	/^  IteratorWrapper* current_;$/;"	m	class:leveldb::__anon22::MergingIterator	file:
direction_	table/merger.cc	/^  Direction direction_;$/;"	m	class:leveldb::__anon22::MergingIterator	file:
kForward	table/merger.cc	/^    kForward,$/;"	e	enum:leveldb::__anon22::MergingIterator::Direction	file:
kReverse	table/merger.cc	/^    kReverse$/;"	e	enum:leveldb::__anon22::MergingIterator::Direction	file:
key	table/merger.cc	/^  virtual Slice key() const {$/;"	f	class:leveldb::__anon22::MergingIterator
leveldb	table/merger.cc	/^namespace leveldb {$/;"	n	file:
n_	table/merger.cc	/^  int n_;$/;"	m	class:leveldb::__anon22::MergingIterator	file:
status	table/merger.cc	/^  virtual Status status() const {$/;"	f	class:leveldb::__anon22::MergingIterator
value	table/merger.cc	/^  virtual Slice value() const {$/;"	f	class:leveldb::__anon22::MergingIterator
~MergingIterator	table/merger.cc	/^  virtual ~MergingIterator() {$/;"	f	class:leveldb::__anon22::MergingIterator
STORAGE_LEVELDB_TABLE_MERGER_H_	table/merger.h	6;"	d
leveldb	table/merger.h	/^namespace leveldb {$/;"	n
AddFilters	table/table.cc	/^    size_t Table::AddFilters(int n, int regionId)$/;"	f	class:leveldb::Table
AddFilters	table/table.cc	/^    size_t* Table::AddFilters(int n, int regionId_start, int regionId_end)$/;"	f	class:leveldb::Table
AdjustFilters	table/table.cc	/^    size_t Table::AdjustFilters(int n, int regionId)$/;"	f	class:leveldb::Table
AdjustFilters	table/table.cc	/^    size_t* Table::AdjustFilters(int n, int regionId_start, int regionId_end) {$/;"	f	class:leveldb::Table
ApproximateOffsetOf	table/table.cc	/^    uint64_t Table::ApproximateOffsetOf(const Slice &key) const$/;"	f	class:leveldb::Table
BlockReader	table/table.cc	/^    Iterator *Table::BlockReader(void *arg,$/;"	f	class:leveldb::Table
DeleteBlock	table/table.cc	/^    static void DeleteBlock(void *arg, void *ignored)$/;"	f	namespace:leveldb
DeleteCachedBlock	table/table.cc	/^    static void DeleteCachedBlock(const Slice &key, void *value)$/;"	f	namespace:leveldb
InternalGet	table/table.cc	/^    Status Table::InternalGet(const ReadOptions &options, const Slice &k,$/;"	f	class:leveldb::Table
LRU_Fre_Count	table/table.cc	/^    uint64_t Table::LRU_Fre_Count = 0;$/;"	m	class:leveldb::Table	file:
NewIterator	table/table.cc	/^    Iterator *Table::NewIterator(const ReadOptions &options) const$/;"	f	class:leveldb::Table
Open	table/table.cc	/^    Status Table::Open(const Options &options,$/;"	f	class:leveldb::Table
ReadFilter	table/table.cc	/^    size_t Table::ReadFilter(const Slice &filter_handle_value, int regionId)$/;"	f	class:leveldb::Table
ReadFilter	table/table.cc	/^    void Table::ReadFilter(const Slice &filter_handle_value, int regionId_start, int regionId_end, size_t *delta)$/;"	f	class:leveldb::Table
ReadFilters	table/table.cc	/^    void Table::ReadFilters(std::vector< Slice > &filter_handle_values, size_t * &charge, int n, TableMetaData *tableMetaData)$/;"	f	class:leveldb::Table
ReadMeta	table/table.cc	/^    void Table::ReadMeta(const Footer &footer, size_t * &charge, int add_filter_num, TableMetaData *tableMetaData)$/;"	f	class:leveldb::Table
ReleaseBlock	table/table.cc	/^    static void ReleaseBlock(void *arg, void *h)$/;"	f	namespace:leveldb
RemoveFilters	table/table.cc	/^    size_t Table::RemoveFilters(int n, int regionId)$/;"	f	class:leveldb::Table
Rep	table/table.cc	/^    struct Table::Rep$/;"	s	class:leveldb::Table	file:
base_lg_	table/table.cc	/^        size_t base_lg_;$/;"	m	struct:leveldb::Table::Rep	file:
cache_id	table/table.cc	/^        uint64_t cache_id;$/;"	m	struct:leveldb::Table::Rep	file:
file	table/table.cc	/^        RandomAccessFile *file;$/;"	m	struct:leveldb::Table::Rep	file:
filter	table/table.cc	/^        FilterBlockReader *filter;$/;"	m	struct:leveldb::Table::Rep	file:
filter_datas	table/table.cc	/^        std::vector<std::vector<Slice>> filter_datas; \/\/ be careful about vector memory overhead$/;"	m	struct:leveldb::Table::Rep	file:
filter_handles	table/table.cc	/^        std::vector<Slice> filter_handles;    \/\/use string instead of slice$/;"	m	struct:leveldb::Table::Rep	file:
getCurrFilterNum	table/table.cc	/^    int Table::getCurrFilterNum(int regionId)$/;"	f	class:leveldb::Table
getCurrFiltersSize	table/table.cc	/^    size_t Table::getCurrFiltersSize(int regionId)$/;"	f	class:leveldb::Table
getRegionKeyRanges	table/table.cc	/^    void Table::getRegionKeyRanges(std::vector<Slice> &region_keys) {$/;"	f	class:leveldb::Table
getRegionKeyRangesByStr	table/table.cc	/^    void Table::getRegionKeyRangesByStr(const Options *options, Slice &index_content, std::vector<Slice> &region_keys) {$/;"	f	class:leveldb::Table
getRegionNum	table/table.cc	/^    int Table::getRegionNum()$/;"	f	class:leveldb::Table
has_access	table/table.cc	/^        std::vector<bool> has_access;$/;"	m	struct:leveldb::Table::Rep	file:
index_block	table/table.cc	/^        Block *index_block;$/;"	m	struct:leveldb::Table::Rep	file:
isAccess	table/table.cc	/^    bool Table::isAccess(int regionId) {$/;"	f	class:leveldb::Table
leveldb	table/table.cc	/^namespace leveldb$/;"	n	file:
meta	table/table.cc	/^        Block *meta = NULL;$/;"	m	struct:leveldb::Table::Rep	file:
metaindex_handle	table/table.cc	/^        BlockHandle metaindex_handle;  \/\/ Handle to metaindex_block: saved from footer$/;"	m	struct:leveldb::Table::Rep	file:
mutex_	table/table.cc	/^        SpinMutex mutex_;$/;"	m	struct:leveldb::Table::Rep	file:
offsets_	table/table.cc	/^        std::vector<std::vector<uint32_t>> offsets_;$/;"	m	struct:leveldb::Table::Rep	file:
options	table/table.cc	/^        Options options;$/;"	m	struct:leveldb::Table::Rep	file:
setAccess	table/table.cc	/^    void Table::setAccess(int regionId) {$/;"	f	class:leveldb::Table
status	table/table.cc	/^        Status status;$/;"	m	struct:leveldb::Table::Rep	file:
~Rep	table/table.cc	/^        ~Rep()$/;"	f	struct:leveldb::Table::Rep
~Table	table/table.cc	/^    Table::~Table()$/;"	f	class:leveldb::Table
Abandon	table/table_builder.cc	/^void TableBuilder::Abandon() {$/;"	f	class:leveldb::TableBuilder
Add	table/table_builder.cc	/^void TableBuilder::Add(const Slice& key, const Slice& value) {$/;"	f	class:leveldb::TableBuilder
ChangeOptions	table/table_builder.cc	/^Status TableBuilder::ChangeOptions(const Options& options) {$/;"	f	class:leveldb::TableBuilder
FileSize	table/table_builder.cc	/^uint64_t TableBuilder::FileSize() const {$/;"	f	class:leveldb::TableBuilder
Finish	table/table_builder.cc	/^Status TableBuilder::Finish() {$/;"	f	class:leveldb::TableBuilder
Flush	table/table_builder.cc	/^void TableBuilder::Flush() {$/;"	f	class:leveldb::TableBuilder
NumEntries	table/table_builder.cc	/^uint64_t TableBuilder::NumEntries() const {$/;"	f	class:leveldb::TableBuilder
Rep	table/table_builder.cc	/^  Rep(const Options& opt, WritableFile* f)$/;"	f	struct:leveldb::TableBuilder::Rep
Rep	table/table_builder.cc	/^struct TableBuilder::Rep {$/;"	s	class:leveldb::TableBuilder	file:
TableBuilder	table/table_builder.cc	/^TableBuilder::TableBuilder(const Options& options, WritableFile* file)$/;"	f	class:leveldb::TableBuilder
WriteBlock	table/table_builder.cc	/^void TableBuilder::WriteBlock(BlockBuilder* block, BlockHandle* handle) {$/;"	f	class:leveldb::TableBuilder
WriteRawBlock	table/table_builder.cc	/^void TableBuilder::WriteRawBlock(const Slice& block_contents,$/;"	f	class:leveldb::TableBuilder
closed	table/table_builder.cc	/^  bool closed;          \/\/ Either Finish() or Abandon() has been called.$/;"	m	struct:leveldb::TableBuilder::Rep	file:
compressed_output	table/table_builder.cc	/^  std::string compressed_output;$/;"	m	struct:leveldb::TableBuilder::Rep	file:
data_block	table/table_builder.cc	/^  BlockBuilder data_block;$/;"	m	struct:leveldb::TableBuilder::Rep	file:
file	table/table_builder.cc	/^  WritableFile* file;$/;"	m	struct:leveldb::TableBuilder::Rep	file:
filter_block	table/table_builder.cc	/^  FilterBlockBuilder* filter_block;$/;"	m	struct:leveldb::TableBuilder::Rep	file:
index_block	table/table_builder.cc	/^  BlockBuilder index_block;$/;"	m	struct:leveldb::TableBuilder::Rep	file:
index_block_options	table/table_builder.cc	/^  Options index_block_options;$/;"	m	struct:leveldb::TableBuilder::Rep	file:
last_key	table/table_builder.cc	/^  std::string last_key;$/;"	m	struct:leveldb::TableBuilder::Rep	file:
leveldb	table/table_builder.cc	/^namespace leveldb {$/;"	n	file:
num_entries	table/table_builder.cc	/^  int64_t num_entries;$/;"	m	struct:leveldb::TableBuilder::Rep	file:
offset	table/table_builder.cc	/^  uint64_t offset;$/;"	m	struct:leveldb::TableBuilder::Rep	file:
options	table/table_builder.cc	/^  Options options;$/;"	m	struct:leveldb::TableBuilder::Rep	file:
pending_handle	table/table_builder.cc	/^  BlockHandle pending_handle;  \/\/ Handle to add to index block$/;"	m	struct:leveldb::TableBuilder::Rep	file:
pending_index_entry	table/table_builder.cc	/^  bool pending_index_entry;$/;"	m	struct:leveldb::TableBuilder::Rep	file:
status	table/table_builder.cc	/^  Status status;$/;"	m	struct:leveldb::TableBuilder::Rep	file:
status	table/table_builder.cc	/^Status TableBuilder::status() const {$/;"	f	class:leveldb::TableBuilder
~TableBuilder	table/table_builder.cc	/^TableBuilder::~TableBuilder() {$/;"	f	class:leveldb::TableBuilder
Add	table/table_test.cc	/^  void Add(const std::string& key, const Slice& value) {$/;"	f	class:leveldb::Constructor
Add	table/table_test.cc	/^  void Add(const std::string& key, const std::string& value) {$/;"	f	class:leveldb::Harness
Append	table/table_test.cc	/^  virtual Status Append(const Slice& data) {$/;"	f	class:leveldb::StringSink
ApproximateOffsetOf	table/table_test.cc	/^  uint64_t ApproximateOffsetOf(const Slice& key) const {$/;"	f	class:leveldb::TableConstructor
BLOCK_TEST	table/table_test.cc	/^  BLOCK_TEST,$/;"	e	enum:leveldb::TestType	file:
Between	table/table_test.cc	/^static bool Between(uint64_t val, uint64_t low, uint64_t high) {$/;"	f	namespace:leveldb
BlockConstructor	table/table_test.cc	/^  explicit BlockConstructor(const Comparator* cmp)$/;"	f	class:leveldb::BlockConstructor
BlockConstructor	table/table_test.cc	/^class BlockConstructor: public Constructor {$/;"	c	namespace:leveldb	file:
Close	table/table_test.cc	/^  virtual Status Close() { return Status::OK(); }$/;"	f	class:leveldb::StringSink
Compare	table/table_test.cc	/^  virtual int Compare(const Slice& a, const Slice& b) const {$/;"	f	class:leveldb::__anon23::ReverseKeyComparator
Constructor	table/table_test.cc	/^  explicit Constructor(const Comparator* cmp) : data_(STLLessThan(cmp)) { }$/;"	f	class:leveldb::Constructor
Constructor	table/table_test.cc	/^class Constructor {$/;"	c	namespace:leveldb	file:
DBConstructor	table/table_test.cc	/^  explicit DBConstructor(const Comparator* cmp)$/;"	f	class:leveldb::DBConstructor
DBConstructor	table/table_test.cc	/^class DBConstructor: public Constructor {$/;"	c	namespace:leveldb	file:
DB_TEST	table/table_test.cc	/^  DB_TEST$/;"	e	enum:leveldb::TestType	file:
FindShortSuccessor	table/table_test.cc	/^  virtual void FindShortSuccessor(std::string* key) const {$/;"	f	class:leveldb::__anon23::ReverseKeyComparator
FindShortestSeparator	table/table_test.cc	/^  virtual void FindShortestSeparator($/;"	f	class:leveldb::__anon23::ReverseKeyComparator
Finish	table/table_test.cc	/^  void Finish(const Options& options,$/;"	f	class:leveldb::Constructor
FinishImpl	table/table_test.cc	/^  virtual Status FinishImpl(const Options& options, const KVMap& data) {$/;"	f	class:leveldb::BlockConstructor
FinishImpl	table/table_test.cc	/^  virtual Status FinishImpl(const Options& options, const KVMap& data) {$/;"	f	class:leveldb::DBConstructor
FinishImpl	table/table_test.cc	/^  virtual Status FinishImpl(const Options& options, const KVMap& data) {$/;"	f	class:leveldb::MemTableConstructor
FinishImpl	table/table_test.cc	/^  virtual Status FinishImpl(const Options& options, const KVMap& data) {$/;"	f	class:leveldb::TableConstructor
Flush	table/table_test.cc	/^  virtual Status Flush() { return Status::OK(); }$/;"	f	class:leveldb::StringSink
Harness	table/table_test.cc	/^  Harness() : constructor_(NULL) { }$/;"	f	class:leveldb::Harness
Harness	table/table_test.cc	/^class Harness {$/;"	c	namespace:leveldb	file:
Increment	table/table_test.cc	/^static void Increment(const Comparator* cmp, std::string* key) {$/;"	f	namespace:leveldb
Init	table/table_test.cc	/^  void Init(const TestArgs& args) {$/;"	f	class:leveldb::Harness
KVMap	table/table_test.cc	/^typedef std::map<std::string, std::string, STLLessThan> KVMap;$/;"	t	namespace:leveldb	file:
KeyConvertingIterator	table/table_test.cc	/^  explicit KeyConvertingIterator(Iterator* iter) : iter_(iter) { }$/;"	f	class:leveldb::KeyConvertingIterator
KeyConvertingIterator	table/table_test.cc	/^class KeyConvertingIterator: public Iterator {$/;"	c	namespace:leveldb	file:
MEMTABLE_TEST	table/table_test.cc	/^  MEMTABLE_TEST,$/;"	e	enum:leveldb::TestType	file:
MemTableConstructor	table/table_test.cc	/^  explicit MemTableConstructor(const Comparator* cmp)$/;"	f	class:leveldb::MemTableConstructor
MemTableConstructor	table/table_test.cc	/^class MemTableConstructor: public Constructor {$/;"	c	namespace:leveldb	file:
MemTableTest	table/table_test.cc	/^class MemTableTest { };$/;"	c	namespace:leveldb	file:
Name	table/table_test.cc	/^  virtual const char* Name() const {$/;"	f	class:leveldb::__anon23::ReverseKeyComparator
NewDB	table/table_test.cc	/^  void NewDB() {$/;"	f	class:leveldb::DBConstructor	file:
NewIterator	table/table_test.cc	/^  virtual Iterator* NewIterator() const {$/;"	f	class:leveldb::BlockConstructor
NewIterator	table/table_test.cc	/^  virtual Iterator* NewIterator() const {$/;"	f	class:leveldb::DBConstructor
NewIterator	table/table_test.cc	/^  virtual Iterator* NewIterator() const {$/;"	f	class:leveldb::MemTableConstructor
NewIterator	table/table_test.cc	/^  virtual Iterator* NewIterator() const {$/;"	f	class:leveldb::TableConstructor
Next	table/table_test.cc	/^  virtual void Next() { iter_->Next(); }$/;"	f	class:leveldb::KeyConvertingIterator
PickRandomKey	table/table_test.cc	/^  std::string PickRandomKey(Random* rnd, const std::vector<std::string>& keys) {$/;"	f	class:leveldb::Harness
Prev	table/table_test.cc	/^  virtual void Prev() { iter_->Prev(); }$/;"	f	class:leveldb::KeyConvertingIterator
Read	table/table_test.cc	/^  virtual Status Read(uint64_t offset, size_t n, Slice* result,$/;"	f	class:leveldb::StringSource
Reset	table/table_test.cc	/^  void Reset() {$/;"	f	class:leveldb::TableConstructor	file:
Reverse	table/table_test.cc	/^static std::string Reverse(const Slice& key) {$/;"	f	namespace:leveldb
ReverseKeyComparator	table/table_test.cc	/^class ReverseKeyComparator : public Comparator {$/;"	c	namespace:leveldb::__anon23	file:
STLLessThan	table/table_test.cc	/^  STLLessThan() : cmp(BytewiseComparator()) { }$/;"	f	struct:leveldb::__anon24::STLLessThan
STLLessThan	table/table_test.cc	/^  STLLessThan(const Comparator* c) : cmp(c) { }$/;"	f	struct:leveldb::__anon24::STLLessThan
STLLessThan	table/table_test.cc	/^struct STLLessThan {$/;"	s	namespace:leveldb::__anon24	file:
Seek	table/table_test.cc	/^  virtual void Seek(const Slice& target) {$/;"	f	class:leveldb::KeyConvertingIterator
SeekToFirst	table/table_test.cc	/^  virtual void SeekToFirst() { iter_->SeekToFirst(); }$/;"	f	class:leveldb::KeyConvertingIterator
SeekToLast	table/table_test.cc	/^  virtual void SeekToLast() { iter_->SeekToLast(); }$/;"	f	class:leveldb::KeyConvertingIterator
Size	table/table_test.cc	/^  uint64_t Size() const { return contents_.size(); }$/;"	f	class:leveldb::StringSource
SnappyCompressionSupported	table/table_test.cc	/^static bool SnappyCompressionSupported() {$/;"	f	namespace:leveldb
StringSink	table/table_test.cc	/^class StringSink: public WritableFile {$/;"	c	namespace:leveldb	file:
StringSource	table/table_test.cc	/^  StringSource(const Slice& contents)$/;"	f	class:leveldb::StringSource
StringSource	table/table_test.cc	/^class StringSource: public RandomAccessFile {$/;"	c	namespace:leveldb	file:
Sync	table/table_test.cc	/^  virtual Status Sync() { return Status::OK(); }$/;"	f	class:leveldb::StringSink
TABLE_TEST	table/table_test.cc	/^  TABLE_TEST,$/;"	e	enum:leveldb::TestType	file:
TEST	table/table_test.cc	/^TEST(Harness, Empty) {$/;"	f	namespace:leveldb
TEST	table/table_test.cc	/^TEST(Harness, Randomized) {$/;"	f	namespace:leveldb
TEST	table/table_test.cc	/^TEST(Harness, RandomizedLongDB) {$/;"	f	namespace:leveldb
TEST	table/table_test.cc	/^TEST(Harness, SimpleEmptyKey) {$/;"	f	namespace:leveldb
TEST	table/table_test.cc	/^TEST(Harness, SimpleMulti) {$/;"	f	namespace:leveldb
TEST	table/table_test.cc	/^TEST(Harness, SimpleSingle) {$/;"	f	namespace:leveldb
TEST	table/table_test.cc	/^TEST(Harness, SimpleSpecialKey) {$/;"	f	namespace:leveldb
TEST	table/table_test.cc	/^TEST(Harness, ZeroRestartPointsInBlock) {$/;"	f	namespace:leveldb
TEST	table/table_test.cc	/^TEST(MemTableTest, Simple) {$/;"	f	namespace:leveldb
TEST	table/table_test.cc	/^TEST(TableTest, ApproximateOffsetOfCompressed) {$/;"	f	namespace:leveldb
TEST	table/table_test.cc	/^TEST(TableTest, ApproximateOffsetOfPlain) {$/;"	f	namespace:leveldb
TableConstructor	table/table_test.cc	/^  TableConstructor(const Comparator* cmp)$/;"	f	class:leveldb::TableConstructor
TableConstructor	table/table_test.cc	/^class TableConstructor: public Constructor {$/;"	c	namespace:leveldb	file:
TableTest	table/table_test.cc	/^class TableTest { };$/;"	c	namespace:leveldb	file:
Test	table/table_test.cc	/^  void Test(Random* rnd) {$/;"	f	class:leveldb::Harness
TestArgs	table/table_test.cc	/^struct TestArgs {$/;"	s	namespace:leveldb	file:
TestBackwardScan	table/table_test.cc	/^  void TestBackwardScan(const std::vector<std::string>& keys,$/;"	f	class:leveldb::Harness
TestForwardScan	table/table_test.cc	/^  void TestForwardScan(const std::vector<std::string>& keys,$/;"	f	class:leveldb::Harness
TestRandomAccess	table/table_test.cc	/^  void TestRandomAccess(Random* rnd,$/;"	f	class:leveldb::Harness
TestType	table/table_test.cc	/^enum TestType {$/;"	g	namespace:leveldb	file:
ToString	table/table_test.cc	/^  std::string ToString(const Iterator* it) {$/;"	f	class:leveldb::Harness
ToString	table/table_test.cc	/^  std::string ToString(const KVMap& data, const KVMap::const_iterator& it) {$/;"	f	class:leveldb::Harness
ToString	table/table_test.cc	/^  std::string ToString(const KVMap& data,$/;"	f	class:leveldb::Harness
Valid	table/table_test.cc	/^  virtual bool Valid() const { return iter_->Valid(); }$/;"	f	class:leveldb::KeyConvertingIterator
block_	table/table_test.cc	/^  Block* block_;$/;"	m	class:leveldb::BlockConstructor	file:
cmp	table/table_test.cc	/^  const Comparator* cmp;$/;"	m	struct:leveldb::__anon24::STLLessThan	file:
comparator_	table/table_test.cc	/^  const Comparator* comparator_;$/;"	m	class:leveldb::BlockConstructor	file:
comparator_	table/table_test.cc	/^  const Comparator* comparator_;$/;"	m	class:leveldb::DBConstructor	file:
constructor_	table/table_test.cc	/^  Constructor* constructor_;$/;"	m	class:leveldb::Harness	file:
contents	table/table_test.cc	/^  const std::string& contents() const { return contents_; }$/;"	f	class:leveldb::StringSink
contents_	table/table_test.cc	/^  std::string contents_;$/;"	m	class:leveldb::StringSink	file:
contents_	table/table_test.cc	/^  std::string contents_;$/;"	m	class:leveldb::StringSource	file:
data	table/table_test.cc	/^  virtual const KVMap& data() { return data_; }$/;"	f	class:leveldb::Constructor
data_	table/table_test.cc	/^  KVMap data_;$/;"	m	class:leveldb::Constructor	file:
data_	table/table_test.cc	/^  std::string data_;$/;"	m	class:leveldb::BlockConstructor	file:
db	table/table_test.cc	/^  DB* db() const { return constructor_->db(); }$/;"	f	class:leveldb::Harness
db	table/table_test.cc	/^  virtual DB* db() const { return NULL; }  \/\/ Overridden in DBConstructor$/;"	f	class:leveldb::Constructor
db	table/table_test.cc	/^  virtual DB* db() const { return db_; }$/;"	f	class:leveldb::DBConstructor
db_	table/table_test.cc	/^  DB* db_;$/;"	m	class:leveldb::DBConstructor	file:
internal_comparator_	table/table_test.cc	/^  InternalKeyComparator internal_comparator_;$/;"	m	class:leveldb::MemTableConstructor	file:
iter_	table/table_test.cc	/^  Iterator* iter_;$/;"	m	class:leveldb::KeyConvertingIterator	file:
kNumTestArgs	table/table_test.cc	/^static const int kNumTestArgs = sizeof(kTestArgList) \/ sizeof(kTestArgList[0]);$/;"	m	namespace:leveldb	file:
kTestArgList	table/table_test.cc	/^static const TestArgs kTestArgList[] = {$/;"	m	namespace:leveldb	file:
key	table/table_test.cc	/^  virtual Slice key() const {$/;"	f	class:leveldb::KeyConvertingIterator
leveldb	table/table_test.cc	/^namespace leveldb {$/;"	n	file:
main	table/table_test.cc	/^int main(int argc, char** argv) {$/;"	f
memtable_	table/table_test.cc	/^  MemTable* memtable_;$/;"	m	class:leveldb::MemTableConstructor	file:
operator ()	table/table_test.cc	/^  bool operator()(const std::string& a, const std::string& b) const {$/;"	f	struct:leveldb::__anon24::STLLessThan
options_	table/table_test.cc	/^  Options options_;$/;"	m	class:leveldb::Harness	file:
restart_interval	table/table_test.cc	/^  int restart_interval;$/;"	m	struct:leveldb::TestArgs	file:
reverse_compare	table/table_test.cc	/^  bool reverse_compare;$/;"	m	struct:leveldb::TestArgs	file:
reverse_key_comparator	table/table_test.cc	/^static ReverseKeyComparator reverse_key_comparator;$/;"	m	namespace:leveldb	file:
source_	table/table_test.cc	/^  StringSource* source_;$/;"	m	class:leveldb::TableConstructor	file:
status	table/table_test.cc	/^  virtual Status status() const {$/;"	f	class:leveldb::KeyConvertingIterator
status_	table/table_test.cc	/^  mutable Status status_;$/;"	m	class:leveldb::KeyConvertingIterator	file:
table_	table/table_test.cc	/^  Table* table_;$/;"	m	class:leveldb::TableConstructor	file:
type	table/table_test.cc	/^  TestType type;$/;"	m	struct:leveldb::TestArgs	file:
value	table/table_test.cc	/^  virtual Slice value() const { return iter_->value(); }$/;"	f	class:leveldb::KeyConvertingIterator
~BlockConstructor	table/table_test.cc	/^  ~BlockConstructor() {$/;"	f	class:leveldb::BlockConstructor
~Constructor	table/table_test.cc	/^  virtual ~Constructor() { }$/;"	f	class:leveldb::Constructor
~DBConstructor	table/table_test.cc	/^  ~DBConstructor() {$/;"	f	class:leveldb::DBConstructor
~Harness	table/table_test.cc	/^  ~Harness() {$/;"	f	class:leveldb::Harness
~KeyConvertingIterator	table/table_test.cc	/^  virtual ~KeyConvertingIterator() { delete iter_; }$/;"	f	class:leveldb::KeyConvertingIterator
~MemTableConstructor	table/table_test.cc	/^  ~MemTableConstructor() {$/;"	f	class:leveldb::MemTableConstructor
~StringSink	table/table_test.cc	/^  ~StringSink() { }$/;"	f	class:leveldb::StringSink
~StringSource	table/table_test.cc	/^  virtual ~StringSource() { }$/;"	f	class:leveldb::StringSource
~TableConstructor	table/table_test.cc	/^  ~TableConstructor() {$/;"	f	class:leveldb::TableConstructor
BlockFunction	table/two_level_iterator.cc	/^typedef Iterator* (*BlockFunction)(void*, const ReadOptions&, const Slice&);$/;"	t	namespace:leveldb::__anon25	file:
InitDataBlock	table/two_level_iterator.cc	/^void TwoLevelIterator::InitDataBlock() {$/;"	f	class:leveldb::__anon25::TwoLevelIterator
NewTwoLevelIterator	table/two_level_iterator.cc	/^Iterator* NewTwoLevelIterator($/;"	f	namespace:leveldb
Next	table/two_level_iterator.cc	/^void TwoLevelIterator::Next() {$/;"	f	class:leveldb::__anon25::TwoLevelIterator
Prev	table/two_level_iterator.cc	/^void TwoLevelIterator::Prev() {$/;"	f	class:leveldb::__anon25::TwoLevelIterator
SaveError	table/two_level_iterator.cc	/^  void SaveError(const Status& s) {$/;"	f	class:leveldb::__anon25::TwoLevelIterator	file:
Seek	table/two_level_iterator.cc	/^void TwoLevelIterator::Seek(const Slice& target) {$/;"	f	class:leveldb::__anon25::TwoLevelIterator
SeekToFirst	table/two_level_iterator.cc	/^void TwoLevelIterator::SeekToFirst() {$/;"	f	class:leveldb::__anon25::TwoLevelIterator
SeekToLast	table/two_level_iterator.cc	/^void TwoLevelIterator::SeekToLast() {$/;"	f	class:leveldb::__anon25::TwoLevelIterator
SetDataIterator	table/two_level_iterator.cc	/^void TwoLevelIterator::SetDataIterator(Iterator* data_iter) {$/;"	f	class:leveldb::__anon25::TwoLevelIterator
SkipEmptyDataBlocksBackward	table/two_level_iterator.cc	/^void TwoLevelIterator::SkipEmptyDataBlocksBackward() {$/;"	f	class:leveldb::__anon25::TwoLevelIterator
SkipEmptyDataBlocksForward	table/two_level_iterator.cc	/^void TwoLevelIterator::SkipEmptyDataBlocksForward() {$/;"	f	class:leveldb::__anon25::TwoLevelIterator
TwoLevelIterator	table/two_level_iterator.cc	/^TwoLevelIterator::TwoLevelIterator($/;"	f	class:leveldb::__anon25::TwoLevelIterator
TwoLevelIterator	table/two_level_iterator.cc	/^class TwoLevelIterator: public Iterator {$/;"	c	namespace:leveldb::__anon25	file:
Valid	table/two_level_iterator.cc	/^  virtual bool Valid() const {$/;"	f	class:leveldb::__anon25::TwoLevelIterator
arg_	table/two_level_iterator.cc	/^  void* arg_;$/;"	m	class:leveldb::__anon25::TwoLevelIterator	file:
block_function_	table/two_level_iterator.cc	/^  BlockFunction block_function_;$/;"	m	class:leveldb::__anon25::TwoLevelIterator	file:
data_block_handle_	table/two_level_iterator.cc	/^  std::string data_block_handle_;$/;"	m	class:leveldb::__anon25::TwoLevelIterator	file:
data_iter_	table/two_level_iterator.cc	/^  IteratorWrapper data_iter_; \/\/ May be NULL$/;"	m	class:leveldb::__anon25::TwoLevelIterator	file:
index_iter_	table/two_level_iterator.cc	/^  IteratorWrapper index_iter_;$/;"	m	class:leveldb::__anon25::TwoLevelIterator	file:
key	table/two_level_iterator.cc	/^  virtual Slice key() const {$/;"	f	class:leveldb::__anon25::TwoLevelIterator
leveldb	table/two_level_iterator.cc	/^namespace leveldb {$/;"	n	file:
options_	table/two_level_iterator.cc	/^  const ReadOptions options_;$/;"	m	class:leveldb::__anon25::TwoLevelIterator	file:
status	table/two_level_iterator.cc	/^  virtual Status status() const {$/;"	f	class:leveldb::__anon25::TwoLevelIterator
status_	table/two_level_iterator.cc	/^  Status status_;$/;"	m	class:leveldb::__anon25::TwoLevelIterator	file:
value	table/two_level_iterator.cc	/^  virtual Slice value() const {$/;"	f	class:leveldb::__anon25::TwoLevelIterator
~TwoLevelIterator	table/two_level_iterator.cc	/^TwoLevelIterator::~TwoLevelIterator() {$/;"	f	class:leveldb::__anon25::TwoLevelIterator
STORAGE_LEVELDB_TABLE_TWO_LEVEL_ITERATOR_H_	table/two_level_iterator.h	6;"	d
leveldb	table/two_level_iterator.h	/^namespace leveldb {$/;"	n
AllocateAligned	util/arena.cc	/^char* Arena::AllocateAligned(size_t bytes) {$/;"	f	class:leveldb::Arena
AllocateFallback	util/arena.cc	/^char* Arena::AllocateFallback(size_t bytes) {$/;"	f	class:leveldb::Arena
AllocateNewBlock	util/arena.cc	/^char* Arena::AllocateNewBlock(size_t block_bytes) {$/;"	f	class:leveldb::Arena
Arena	util/arena.cc	/^Arena::Arena() : memory_usage_(0) {$/;"	f	class:leveldb::Arena
kBlockSize	util/arena.cc	/^static const int kBlockSize = 4096;$/;"	m	namespace:leveldb	file:
leveldb	util/arena.cc	/^namespace leveldb {$/;"	n	file:
~Arena	util/arena.cc	/^Arena::~Arena() {$/;"	f	class:leveldb::Arena
Allocate	util/arena.h	/^inline char* Arena::Allocate(size_t bytes) {$/;"	f	class:leveldb::Arena
Arena	util/arena.h	/^class Arena {$/;"	c	namespace:leveldb
MemoryUsage	util/arena.h	/^  size_t MemoryUsage() const {$/;"	f	class:leveldb::Arena
STORAGE_LEVELDB_UTIL_ARENA_H_	util/arena.h	6;"	d
alloc_bytes_remaining_	util/arena.h	/^  size_t alloc_bytes_remaining_;$/;"	m	class:leveldb::Arena
alloc_ptr_	util/arena.h	/^  char* alloc_ptr_;$/;"	m	class:leveldb::Arena
blocks_	util/arena.h	/^  std::vector<char*> blocks_;$/;"	m	class:leveldb::Arena
leveldb	util/arena.h	/^namespace leveldb {$/;"	n
memory_usage_	util/arena.h	/^  port::AtomicPointer memory_usage_;$/;"	m	class:leveldb::Arena
ArenaTest	util/arena_test.cc	/^class ArenaTest { };$/;"	c	namespace:leveldb	file:
TEST	util/arena_test.cc	/^TEST(ArenaTest, Empty) {$/;"	f	namespace:leveldb
TEST	util/arena_test.cc	/^TEST(ArenaTest, Simple) {$/;"	f	namespace:leveldb
leveldb	util/arena_test.cc	/^namespace leveldb {$/;"	n	file:
main	util/arena_test.cc	/^int main(int argc, char** argv) {$/;"	f
BloomFilterPolicy	util/bloom.cc	/^  explicit BloomFilterPolicy(int bits_per_key)$/;"	f	class:leveldb::__anon34::BloomFilterPolicy
BloomFilterPolicy	util/bloom.cc	/^class BloomFilterPolicy : public FilterPolicy {$/;"	c	namespace:leveldb::__anon34	file:
BloomHash	util/bloom.cc	/^static uint32_t BloomHash(const Slice& key) {$/;"	f	namespace:leveldb::__anon34
CreateFilter	util/bloom.cc	/^  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {$/;"	f	class:leveldb::__anon34::BloomFilterPolicy
KeyMayMatch	util/bloom.cc	/^  virtual bool KeyMayMatch(const Slice& key, const Slice& bloom_filter) const {$/;"	f	class:leveldb::__anon34::BloomFilterPolicy
Name	util/bloom.cc	/^  virtual const char* Name() const {$/;"	f	class:leveldb::__anon34::BloomFilterPolicy
bits_per_key_	util/bloom.cc	/^  size_t bits_per_key_;$/;"	m	class:leveldb::__anon34::BloomFilterPolicy	file:
k_	util/bloom.cc	/^  size_t k_;$/;"	m	class:leveldb::__anon34::BloomFilterPolicy	file:
leveldb	util/bloom.cc	/^namespace leveldb {$/;"	n	file:
Add	util/bloom_test.cc	/^  void Add(const Slice& s) {$/;"	f	class:leveldb::BloomTest
BloomTest	util/bloom_test.cc	/^  BloomTest() : policy_(NewBloomFilterPolicy(bits_per_key_per_filter,8)),filters_(NULL) { Reset(); }$/;"	f	class:leveldb::BloomTest
BloomTest	util/bloom_test.cc	/^class BloomTest {$/;"	c	namespace:leveldb	file:
Build	util/bloom_test.cc	/^  void Build() {$/;"	f	class:leveldb::BloomTest
DumpFilter	util/bloom_test.cc	/^  void DumpFilter() {$/;"	f	class:leveldb::BloomTest
FalsePositiveRate	util/bloom_test.cc	/^  double FalsePositiveRate() {$/;"	f	class:leveldb::BloomTest
FilterSize	util/bloom_test.cc	/^  size_t FilterSize() const {$/;"	f	class:leveldb::BloomTest
Key	util/bloom_test.cc	/^static Slice Key(int i, char* buffer) {$/;"	f	namespace:leveldb
Matches	util/bloom_test.cc	/^  bool Matches(const Slice& s) {$/;"	f	class:leveldb::BloomTest
NextLength	util/bloom_test.cc	/^static int NextLength(int length) {$/;"	f	namespace:leveldb
Reset	util/bloom_test.cc	/^  void Reset() {$/;"	f	class:leveldb::BloomTest
TEST	util/bloom_test.cc	/^TEST(BloomTest, EmptyFilter) {$/;"	f	namespace:leveldb
TEST	util/bloom_test.cc	/^TEST(BloomTest, Small) {$/;"	f	namespace:leveldb
TEST	util/bloom_test.cc	/^TEST(BloomTest, VaryingLengths) {$/;"	f	namespace:leveldb
bits_per_key_per_filter	util/bloom_test.cc	/^int bits_per_key_per_filter[]={2,2,2,2,2,2,2,0};$/;"	m	namespace:leveldb	file:
filter_len	util/bloom_test.cc	/^const int filter_len = sizeof(bits_per_key_per_filter)\/sizeof(int) - 1;$/;"	m	namespace:leveldb	file:
filters_	util/bloom_test.cc	/^  std::list<std::string> *filters_;$/;"	m	class:leveldb::BloomTest	file:
kVerbose	util/bloom_test.cc	/^static const int kVerbose = 1;$/;"	m	namespace:leveldb	file:
keys_	util/bloom_test.cc	/^  std::vector<std::string> keys_;$/;"	m	class:leveldb::BloomTest	file:
leveldb	util/bloom_test.cc	/^namespace leveldb {$/;"	n	file:
main	util/bloom_test.cc	/^int main(int argc, char** argv) {$/;"	f
policy_	util/bloom_test.cc	/^  const FilterPolicy* policy_;$/;"	m	class:leveldb::BloomTest	file:
~BloomTest	util/bloom_test.cc	/^  ~BloomTest() {$/;"	f	class:leveldb::BloomTest
Erase	util/cache.cc	/^  virtual void Erase(const Slice& key) {$/;"	f	class:leveldb::__anon30::ShardedLRUCache
Erase	util/cache.cc	/^void LRUCache::Erase(const Slice& key, uint32_t hash) {$/;"	f	class:leveldb::__anon30::LRUCache
FindPointer	util/cache.cc	/^  LRUHandle** FindPointer(const Slice& key, uint32_t hash) {$/;"	f	class:leveldb::__anon30::HandleTable	file:
FinishErase	util/cache.cc	/^bool LRUCache::FinishErase(LRUHandle* e) {$/;"	f	class:leveldb::__anon30::LRUCache
HandleTable	util/cache.cc	/^  HandleTable() : length_(0), elems_(0), list_(NULL) { Resize(); }$/;"	f	class:leveldb::__anon30::HandleTable
HandleTable	util/cache.cc	/^class HandleTable {$/;"	c	namespace:leveldb::__anon30	file:
HashSlice	util/cache.cc	/^  static inline uint32_t HashSlice(const Slice& s) {$/;"	f	class:leveldb::__anon30::ShardedLRUCache	file:
Insert	util/cache.cc	/^  LRUHandle* Insert(LRUHandle* h) {$/;"	f	class:leveldb::__anon30::HandleTable
Insert	util/cache.cc	/^  virtual Handle* Insert(const Slice& key, void* value, size_t charge,$/;"	f	class:leveldb::__anon30::ShardedLRUCache
Insert	util/cache.cc	/^Cache::Handle* LRUCache::Insert($/;"	f	class:leveldb::__anon30::LRUCache
LRUCache	util/cache.cc	/^LRUCache::LRUCache()$/;"	f	class:leveldb::__anon30::LRUCache
LRUCache	util/cache.cc	/^class LRUCache {$/;"	c	namespace:leveldb::__anon30	file:
LRUHandle	util/cache.cc	/^struct LRUHandle {$/;"	s	namespace:leveldb::__anon30	file:
LRU_Append	util/cache.cc	/^void LRUCache::LRU_Append(LRUHandle* list, LRUHandle* e) {$/;"	f	class:leveldb::__anon30::LRUCache
LRU_Remove	util/cache.cc	/^void LRUCache::LRU_Remove(LRUHandle* e) {$/;"	f	class:leveldb::__anon30::LRUCache
Lookup	util/cache.cc	/^  LRUHandle* Lookup(const Slice& key, uint32_t hash) {$/;"	f	class:leveldb::__anon30::HandleTable
Lookup	util/cache.cc	/^  virtual Handle* Lookup(const Slice& key) {$/;"	f	class:leveldb::__anon30::ShardedLRUCache
Lookup	util/cache.cc	/^Cache::Handle* LRUCache::Lookup(const Slice& key, uint32_t hash) {$/;"	f	class:leveldb::__anon30::LRUCache
NewId	util/cache.cc	/^  virtual uint64_t NewId() {$/;"	f	class:leveldb::__anon30::ShardedLRUCache
NewLRUCache	util/cache.cc	/^Cache* NewLRUCache(size_t capacity) {$/;"	f	namespace:leveldb
Prune	util/cache.cc	/^  virtual void Prune() {$/;"	f	class:leveldb::__anon30::ShardedLRUCache
Prune	util/cache.cc	/^void LRUCache::Prune() {$/;"	f	class:leveldb::__anon30::LRUCache
Ref	util/cache.cc	/^void LRUCache::Ref(LRUHandle* e) {$/;"	f	class:leveldb::__anon30::LRUCache
Release	util/cache.cc	/^  virtual void Release(Handle* handle) {$/;"	f	class:leveldb::__anon30::ShardedLRUCache
Release	util/cache.cc	/^void LRUCache::Release(Cache::Handle* handle) {$/;"	f	class:leveldb::__anon30::LRUCache
Remove	util/cache.cc	/^  LRUHandle* Remove(const Slice& key, uint32_t hash) {$/;"	f	class:leveldb::__anon30::HandleTable
Resize	util/cache.cc	/^  void Resize() {$/;"	f	class:leveldb::__anon30::HandleTable	file:
SetCapacity	util/cache.cc	/^  void SetCapacity(size_t capacity) { capacity_ = capacity; }$/;"	f	class:leveldb::__anon30::LRUCache
Shard	util/cache.cc	/^  static uint32_t Shard(uint32_t hash) {$/;"	f	class:leveldb::__anon30::ShardedLRUCache	file:
ShardedLRUCache	util/cache.cc	/^  explicit ShardedLRUCache(size_t capacity)$/;"	f	class:leveldb::__anon30::ShardedLRUCache
ShardedLRUCache	util/cache.cc	/^class ShardedLRUCache : public Cache {$/;"	c	namespace:leveldb::__anon30	file:
TotalCharge	util/cache.cc	/^  size_t TotalCharge() const {$/;"	f	class:leveldb::__anon30::LRUCache
TotalCharge	util/cache.cc	/^  virtual size_t TotalCharge() const {$/;"	f	class:leveldb::__anon30::ShardedLRUCache
Unref	util/cache.cc	/^void LRUCache::Unref(LRUHandle* e) {$/;"	f	class:leveldb::__anon30::LRUCache
Value	util/cache.cc	/^  virtual void* Value(Handle* handle) {$/;"	f	class:leveldb::__anon30::ShardedLRUCache
capacity_	util/cache.cc	/^  size_t capacity_;$/;"	m	class:leveldb::__anon30::LRUCache	file:
charge	util/cache.cc	/^  size_t charge;      \/\/ TODO(opt): Only allow uint32_t?$/;"	m	struct:leveldb::__anon30::LRUHandle	file:
deleter	util/cache.cc	/^  void (*deleter)(const Slice&, void* value);$/;"	m	struct:leveldb::__anon30::LRUHandle	file:
elems_	util/cache.cc	/^  uint32_t elems_;$/;"	m	class:leveldb::__anon30::HandleTable	file:
hash	util/cache.cc	/^  uint32_t hash;      \/\/ Hash of key(); used for fast sharding and comparisons$/;"	m	struct:leveldb::__anon30::LRUHandle	file:
id_mutex_	util/cache.cc	/^  port::Mutex id_mutex_;$/;"	m	class:leveldb::__anon30::ShardedLRUCache	file:
in_cache	util/cache.cc	/^  bool in_cache;      \/\/ Whether entry is in the cache.$/;"	m	struct:leveldb::__anon30::LRUHandle	file:
in_use_	util/cache.cc	/^  LRUHandle in_use_;$/;"	m	class:leveldb::__anon30::LRUCache	file:
kNumShardBits	util/cache.cc	/^static const int kNumShardBits = 4;$/;"	m	namespace:leveldb::__anon30	file:
kNumShards	util/cache.cc	/^static const int kNumShards = 1 << kNumShardBits;$/;"	m	namespace:leveldb::__anon30	file:
key	util/cache.cc	/^  Slice key() const {$/;"	f	struct:leveldb::__anon30::LRUHandle
key_data	util/cache.cc	/^  char key_data[1];   \/\/ Beginning of key$/;"	m	struct:leveldb::__anon30::LRUHandle	file:
key_length	util/cache.cc	/^  size_t key_length;$/;"	m	struct:leveldb::__anon30::LRUHandle	file:
last_id_	util/cache.cc	/^  uint64_t last_id_;$/;"	m	class:leveldb::__anon30::ShardedLRUCache	file:
length_	util/cache.cc	/^  uint32_t length_;$/;"	m	class:leveldb::__anon30::HandleTable	file:
leveldb	util/cache.cc	/^namespace leveldb {$/;"	n	file:
list_	util/cache.cc	/^  LRUHandle** list_;$/;"	m	class:leveldb::__anon30::HandleTable	file:
lru_	util/cache.cc	/^  LRUHandle lru_;$/;"	m	class:leveldb::__anon30::LRUCache	file:
mutex_	util/cache.cc	/^  mutable port::Mutex mutex_;$/;"	m	class:leveldb::__anon30::LRUCache	file:
next	util/cache.cc	/^  LRUHandle* next;$/;"	m	struct:leveldb::__anon30::LRUHandle	file:
next_hash	util/cache.cc	/^  LRUHandle* next_hash;$/;"	m	struct:leveldb::__anon30::LRUHandle	file:
prev	util/cache.cc	/^  LRUHandle* prev;$/;"	m	struct:leveldb::__anon30::LRUHandle	file:
refs	util/cache.cc	/^  uint32_t refs;      \/\/ References, including cache reference, if present.$/;"	m	struct:leveldb::__anon30::LRUHandle	file:
shard_	util/cache.cc	/^  LRUCache shard_[kNumShards];$/;"	m	class:leveldb::__anon30::ShardedLRUCache	file:
table_	util/cache.cc	/^  HandleTable table_;$/;"	m	class:leveldb::__anon30::LRUCache	file:
usage_	util/cache.cc	/^  size_t usage_;$/;"	m	class:leveldb::__anon30::LRUCache	file:
value	util/cache.cc	/^  void* value;$/;"	m	struct:leveldb::__anon30::LRUHandle	file:
~Cache	util/cache.cc	/^Cache::~Cache() {$/;"	f	class:leveldb::Cache
~HandleTable	util/cache.cc	/^  ~HandleTable() { delete[] list_; }$/;"	f	class:leveldb::__anon30::HandleTable
~LRUCache	util/cache.cc	/^LRUCache::~LRUCache() {$/;"	f	class:leveldb::__anon30::LRUCache
~ShardedLRUCache	util/cache.cc	/^  virtual ~ShardedLRUCache() { }$/;"	f	class:leveldb::__anon30::ShardedLRUCache
CacheTest	util/cache_test.cc	/^  CacheTest() : cache_(NewLRUCache(kCacheSize)) {$/;"	f	class:leveldb::CacheTest
CacheTest	util/cache_test.cc	/^class CacheTest {$/;"	c	namespace:leveldb	file:
DecodeKey	util/cache_test.cc	/^static int DecodeKey(const Slice& k) {$/;"	f	namespace:leveldb
DecodeValue	util/cache_test.cc	/^static int DecodeValue(void* v) { return reinterpret_cast<uintptr_t>(v); }$/;"	f	namespace:leveldb
Deleter	util/cache_test.cc	/^  static void Deleter(const Slice& key, void* v) {$/;"	f	class:leveldb::CacheTest
EncodeKey	util/cache_test.cc	/^static std::string EncodeKey(int k) {$/;"	f	namespace:leveldb
EncodeValue	util/cache_test.cc	/^static void* EncodeValue(uintptr_t v) { return reinterpret_cast<void*>(v); }$/;"	f	namespace:leveldb
Erase	util/cache_test.cc	/^  void Erase(int key) {$/;"	f	class:leveldb::CacheTest
Insert	util/cache_test.cc	/^  void Insert(int key, int value, int charge = 1) {$/;"	f	class:leveldb::CacheTest
InsertAndReturnHandle	util/cache_test.cc	/^  Cache::Handle* InsertAndReturnHandle(int key, int value, int charge = 1) {$/;"	f	class:leveldb::CacheTest
Lookup	util/cache_test.cc	/^  int Lookup(int key) {$/;"	f	class:leveldb::CacheTest
TEST	util/cache_test.cc	/^TEST(CacheTest, EntriesArePinned) {$/;"	f	namespace:leveldb
TEST	util/cache_test.cc	/^TEST(CacheTest, Erase) {$/;"	f	namespace:leveldb
TEST	util/cache_test.cc	/^TEST(CacheTest, EvictionPolicy) {$/;"	f	namespace:leveldb
TEST	util/cache_test.cc	/^TEST(CacheTest, HeavyEntries) {$/;"	f	namespace:leveldb
TEST	util/cache_test.cc	/^TEST(CacheTest, HitAndMiss) {$/;"	f	namespace:leveldb
TEST	util/cache_test.cc	/^TEST(CacheTest, NewId) {$/;"	f	namespace:leveldb
TEST	util/cache_test.cc	/^TEST(CacheTest, Prune) {$/;"	f	namespace:leveldb
TEST	util/cache_test.cc	/^TEST(CacheTest, UseExceedsCacheSize) {$/;"	f	namespace:leveldb
cache_	util/cache_test.cc	/^  Cache* cache_;$/;"	m	class:leveldb::CacheTest	file:
current_	util/cache_test.cc	/^  static CacheTest* current_;$/;"	m	class:leveldb::CacheTest	file:
current_	util/cache_test.cc	/^CacheTest* CacheTest::current_;$/;"	m	class:leveldb::CacheTest	file:
deleted_keys_	util/cache_test.cc	/^  std::vector<int> deleted_keys_;$/;"	m	class:leveldb::CacheTest	file:
deleted_values_	util/cache_test.cc	/^  std::vector<int> deleted_values_;$/;"	m	class:leveldb::CacheTest	file:
kCacheSize	util/cache_test.cc	/^  static const int kCacheSize = 1000;$/;"	m	class:leveldb::CacheTest	file:
leveldb	util/cache_test.cc	/^namespace leveldb {$/;"	n	file:
main	util/cache_test.cc	/^int main(int argc, char** argv) {$/;"	f
~CacheTest	util/cache_test.cc	/^  ~CacheTest() {$/;"	f	class:leveldb::CacheTest
EncodeFixed32	util/coding.cc	/^void EncodeFixed32(char* buf, uint32_t value) {$/;"	f	namespace:leveldb
EncodeFixed64	util/coding.cc	/^void EncodeFixed64(char* buf, uint64_t value) {$/;"	f	namespace:leveldb
EncodeVarint32	util/coding.cc	/^char* EncodeVarint32(char* dst, uint32_t v) {$/;"	f	namespace:leveldb
EncodeVarint64	util/coding.cc	/^char* EncodeVarint64(char* dst, uint64_t v) {$/;"	f	namespace:leveldb
GetLengthPrefixedSlice	util/coding.cc	/^bool GetLengthPrefixedSlice(Slice* input, Slice* result) {$/;"	f	namespace:leveldb
GetLengthPrefixedSlice	util/coding.cc	/^const char* GetLengthPrefixedSlice(const char* p, const char* limit,$/;"	f	namespace:leveldb
GetVarint32	util/coding.cc	/^bool GetVarint32(Slice* input, uint32_t* value) {$/;"	f	namespace:leveldb
GetVarint32PtrFallback	util/coding.cc	/^const char* GetVarint32PtrFallback(const char* p,$/;"	f	namespace:leveldb
GetVarint64	util/coding.cc	/^bool GetVarint64(Slice* input, uint64_t* value) {$/;"	f	namespace:leveldb
GetVarint64Ptr	util/coding.cc	/^const char* GetVarint64Ptr(const char* p, const char* limit, uint64_t* value) {$/;"	f	namespace:leveldb
PutFixed32	util/coding.cc	/^void PutFixed32(std::string* dst, uint32_t value) {$/;"	f	namespace:leveldb
PutFixed64	util/coding.cc	/^void PutFixed64(std::string* dst, uint64_t value) {$/;"	f	namespace:leveldb
PutLengthPrefixedSlice	util/coding.cc	/^void PutLengthPrefixedSlice(std::string* dst, const Slice& value) {$/;"	f	namespace:leveldb
PutVarint32	util/coding.cc	/^void PutVarint32(std::string* dst, uint32_t v) {$/;"	f	namespace:leveldb
PutVarint64	util/coding.cc	/^void PutVarint64(std::string* dst, uint64_t v) {$/;"	f	namespace:leveldb
VarintLength	util/coding.cc	/^int VarintLength(uint64_t v) {$/;"	f	namespace:leveldb
leveldb	util/coding.cc	/^namespace leveldb {$/;"	n	file:
DecodeFixed32	util/coding.h	/^inline uint32_t DecodeFixed32(const char* ptr) {$/;"	f	namespace:leveldb
DecodeFixed64	util/coding.h	/^inline uint64_t DecodeFixed64(const char* ptr) {$/;"	f	namespace:leveldb
GetVarint32Ptr	util/coding.h	/^inline const char* GetVarint32Ptr(const char* p,$/;"	f	namespace:leveldb
STORAGE_LEVELDB_UTIL_CODING_H_	util/coding.h	11;"	d
leveldb	util/coding.h	/^namespace leveldb {$/;"	n
Coding	util/coding_test.cc	/^class Coding { };$/;"	c	namespace:leveldb	file:
TEST	util/coding_test.cc	/^TEST(Coding, EncodingOutput) {$/;"	f	namespace:leveldb
TEST	util/coding_test.cc	/^TEST(Coding, Fixed32) {$/;"	f	namespace:leveldb
TEST	util/coding_test.cc	/^TEST(Coding, Fixed64) {$/;"	f	namespace:leveldb
TEST	util/coding_test.cc	/^TEST(Coding, Strings) {$/;"	f	namespace:leveldb
TEST	util/coding_test.cc	/^TEST(Coding, Varint32) {$/;"	f	namespace:leveldb
TEST	util/coding_test.cc	/^TEST(Coding, Varint32Overflow) {$/;"	f	namespace:leveldb
TEST	util/coding_test.cc	/^TEST(Coding, Varint32Truncation) {$/;"	f	namespace:leveldb
TEST	util/coding_test.cc	/^TEST(Coding, Varint64) {$/;"	f	namespace:leveldb
TEST	util/coding_test.cc	/^TEST(Coding, Varint64Overflow) {$/;"	f	namespace:leveldb
TEST	util/coding_test.cc	/^TEST(Coding, Varint64Truncation) {$/;"	f	namespace:leveldb
leveldb	util/coding_test.cc	/^namespace leveldb {$/;"	n	file:
main	util/coding_test.cc	/^int main(int argc, char** argv) {$/;"	f
BytewiseComparator	util/comparator.cc	/^const Comparator* BytewiseComparator() {$/;"	f	namespace:leveldb
BytewiseComparatorImpl	util/comparator.cc	/^  BytewiseComparatorImpl() { }$/;"	f	class:leveldb::__anon28::BytewiseComparatorImpl
BytewiseComparatorImpl	util/comparator.cc	/^class BytewiseComparatorImpl : public Comparator {$/;"	c	namespace:leveldb::__anon28	file:
Compare	util/comparator.cc	/^  virtual int Compare(const Slice& a, const Slice& b) const {$/;"	f	class:leveldb::__anon28::BytewiseComparatorImpl
FindShortSuccessor	util/comparator.cc	/^  virtual void FindShortSuccessor(std::string* key) const {$/;"	f	class:leveldb::__anon28::BytewiseComparatorImpl
FindShortSuccessorBeginWith	util/comparator.cc	/^  virtual void FindShortSuccessorBeginWith(std::string* key, size_t pos) const {$/;"	f	class:leveldb::__anon28::BytewiseComparatorImpl
FindShortestSeparator	util/comparator.cc	/^  virtual void FindShortestSeparator($/;"	f	class:leveldb::__anon28::BytewiseComparatorImpl
InitModule	util/comparator.cc	/^static void InitModule() {$/;"	f	namespace:leveldb
Name	util/comparator.cc	/^  virtual const char* Name() const {$/;"	f	class:leveldb::__anon28::BytewiseComparatorImpl
bytewise	util/comparator.cc	/^static const Comparator* bytewise;$/;"	m	namespace:leveldb	file:
leveldb	util/comparator.cc	/^namespace leveldb {$/;"	n	file:
once	util/comparator.cc	/^static port::OnceType once = LEVELDB_ONCE_INIT;$/;"	m	namespace:leveldb	file:
~Comparator	util/comparator.cc	/^Comparator::~Comparator() { }$/;"	f	class:leveldb::Comparator
CanAccelerateCRC32C	util/crc32c.cc	/^static bool CanAccelerateCRC32C() {$/;"	f	namespace:leveldb::crc32c
Extend	util/crc32c.cc	/^uint32_t Extend(uint32_t crc, const char* buf, size_t size) {$/;"	f	namespace:leveldb::crc32c
LE_LOAD32	util/crc32c.cc	/^static inline uint32_t LE_LOAD32(const uint8_t *p) {$/;"	f	namespace:leveldb::crc32c
STEP1	util/crc32c.cc	309;"	d	file:
STEP1	util/crc32c.cc	345;"	d	file:
STEP4	util/crc32c.cc	313;"	d	file:
STEP4	util/crc32c.cc	344;"	d	file:
crc32c	util/crc32c.cc	/^namespace crc32c {$/;"	n	namespace:leveldb	file:
leveldb	util/crc32c.cc	/^namespace leveldb {$/;"	n	file:
table0_	util/crc32c.cc	/^static const uint32_t table0_[256] = {$/;"	m	namespace:leveldb::crc32c	file:
table1_	util/crc32c.cc	/^static const uint32_t table1_[256] = {$/;"	m	namespace:leveldb::crc32c	file:
table2_	util/crc32c.cc	/^static const uint32_t table2_[256] = {$/;"	m	namespace:leveldb::crc32c	file:
table3_	util/crc32c.cc	/^static const uint32_t table3_[256] = {$/;"	m	namespace:leveldb::crc32c	file:
Mask	util/crc32c.h	/^inline uint32_t Mask(uint32_t crc) {$/;"	f	namespace:leveldb::crc32c
STORAGE_LEVELDB_UTIL_CRC32C_H_	util/crc32c.h	6;"	d
Unmask	util/crc32c.h	/^inline uint32_t Unmask(uint32_t masked_crc) {$/;"	f	namespace:leveldb::crc32c
Value	util/crc32c.h	/^inline uint32_t Value(const char* data, size_t n) {$/;"	f	namespace:leveldb::crc32c
crc32c	util/crc32c.h	/^namespace crc32c {$/;"	n	namespace:leveldb
kMaskDelta	util/crc32c.h	/^static const uint32_t kMaskDelta = 0xa282ead8ul;$/;"	m	namespace:leveldb::crc32c
leveldb	util/crc32c.h	/^namespace leveldb {$/;"	n
CRC	util/crc32c_test.cc	/^class CRC { };$/;"	c	namespace:leveldb::crc32c	file:
TEST	util/crc32c_test.cc	/^TEST(CRC, Extend) {$/;"	f	namespace:leveldb::crc32c
TEST	util/crc32c_test.cc	/^TEST(CRC, Mask) {$/;"	f	namespace:leveldb::crc32c
TEST	util/crc32c_test.cc	/^TEST(CRC, StandardResults) {$/;"	f	namespace:leveldb::crc32c
TEST	util/crc32c_test.cc	/^TEST(CRC, Values) {$/;"	f	namespace:leveldb::crc32c
crc32c	util/crc32c_test.cc	/^namespace crc32c {$/;"	n	namespace:leveldb	file:
leveldb	util/crc32c_test.cc	/^namespace leveldb {$/;"	n	file:
main	util/crc32c_test.cc	/^int main(int argc, char** argv) {$/;"	f
DoWriteStringToFile	util/env.cc	/^static Status DoWriteStringToFile(Env* env, const Slice& data,$/;"	f	namespace:leveldb
Log	util/env.cc	/^void Log(Logger* info_log, const char* format, ...) {$/;"	f	namespace:leveldb
NewAppendableFile	util/env.cc	/^Status Env::NewAppendableFile(const std::string& fname, WritableFile** result) {$/;"	f	class:leveldb::Env
ReadFileToString	util/env.cc	/^Status ReadFileToString(Env* env, const std::string& fname, std::string* data) {$/;"	f	namespace:leveldb
WriteStringToFile	util/env.cc	/^Status WriteStringToFile(Env* env, const Slice& data,$/;"	f	namespace:leveldb
WriteStringToFileSync	util/env.cc	/^Status WriteStringToFileSync(Env* env, const Slice& data,$/;"	f	namespace:leveldb
leveldb	util/env.cc	/^namespace leveldb {$/;"	n	file:
~Env	util/env.cc	/^Env::~Env() {$/;"	f	class:leveldb::Env
~EnvWrapper	util/env.cc	/^EnvWrapper::~EnvWrapper() {$/;"	f	class:leveldb::EnvWrapper
~FileLock	util/env.cc	/^FileLock::~FileLock() {$/;"	f	class:leveldb::FileLock
~Logger	util/env.cc	/^Logger::~Logger() {$/;"	f	class:leveldb::Logger
~RandomAccessFile	util/env.cc	/^RandomAccessFile::~RandomAccessFile() {$/;"	f	class:leveldb::RandomAccessFile
~SequentialFile	util/env.cc	/^SequentialFile::~SequentialFile() {$/;"	f	class:leveldb::SequentialFile
~WritableFile	util/env.cc	/^WritableFile::~WritableFile() {$/;"	f	class:leveldb::WritableFile
Acquire	util/env_posix.cc	/^  bool Acquire() {$/;"	f	class:leveldb::__anon31::Limiter
AlignedBuffer	util/env_posix.cc	/^    AlignedBuffer(size_t alignment)$/;"	f	class:leveldb::AlignedBuffer
AlignedBuffer	util/env_posix.cc	/^class AlignedBuffer{$/;"	c	namespace:leveldb	file:
Alignment	util/env_posix.cc	/^   void Alignment(size_t alignment) {$/;"	f	class:leveldb::AlignedBuffer
AllocateNewBuffer	util/env_posix.cc	/^   void AllocateNewBuffer(size_t requested_capacity, bool copy_data = false) {$/;"	f	class:leveldb::AlignedBuffer
Append	util/env_posix.cc	/^  virtual Status Append(const Slice& data) {$/;"	f	class:leveldb::__anon31::PosixWritableFile
BGItem	util/env_posix.cc	/^  struct BGItem { void* arg; void (*function)(void*); };$/;"	s	class:leveldb::__anon31::PosixEnv	file:
BGQueue	util/env_posix.cc	/^  typedef std::deque<BGItem> BGQueue;$/;"	t	class:leveldb::__anon31::PosixEnv	file:
BGThread	util/env_posix.cc	/^void PosixEnv::BGThread() {$/;"	f	class:leveldb::__anon31::PosixEnv
BGThreadWrapper	util/env_posix.cc	/^  static void* BGThreadWrapper(void* arg) {$/;"	f	class:leveldb::__anon31::PosixEnv	file:
Close	util/env_posix.cc	/^  virtual Status Close() {$/;"	f	class:leveldb::__anon31::PosixWritableFile
CreateDir	util/env_posix.cc	/^  virtual Status CreateDir(const std::string& name) {$/;"	f	class:leveldb::__anon31::PosixEnv
Default	util/env_posix.cc	/^Env* Env::Default() {$/;"	f	class:leveldb::Env
DeleteDir	util/env_posix.cc	/^  virtual Status DeleteDir(const std::string& name) {$/;"	f	class:leveldb::__anon31::PosixEnv
DeleteFile	util/env_posix.cc	/^  virtual Status DeleteFile(const std::string& fname) {$/;"	f	class:leveldb::__anon31::PosixEnv
FileExists	util/env_posix.cc	/^  virtual bool FileExists(const std::string& fname) {$/;"	f	class:leveldb::__anon31::PosixEnv
Flush	util/env_posix.cc	/^  virtual Status Flush() {$/;"	f	class:leveldb::__anon31::PosixWritableFile
FreeAlignedBuffers	util/env_posix.cc	/^  static void FreeAlignedBuffers(){$/;"	f	class:leveldb::AlignedBuffer
GetAlignedBuffer	util/env_posix.cc	/^  static inline AlignedBuffer* GetAlignedBuffer(){$/;"	f	class:leveldb::AlignedBuffer
GetAllowed	util/env_posix.cc	/^  intptr_t GetAllowed() const {$/;"	f	class:leveldb::__anon31::Limiter	file:
GetChildren	util/env_posix.cc	/^  virtual Status GetChildren(const std::string& dir,$/;"	f	class:leveldb::__anon31::PosixEnv
GetFileSize	util/env_posix.cc	/^  virtual Status GetFileSize(const std::string& fname, uint64_t* size) {$/;"	f	class:leveldb::__anon31::PosixEnv
GetTestDirectory	util/env_posix.cc	/^  virtual Status GetTestDirectory(std::string* result) {$/;"	f	class:leveldb::__anon31::PosixEnv
InitDefaultEnv	util/env_posix.cc	/^static void InitDefaultEnv() { default_env = new PosixEnv; }$/;"	f	namespace:leveldb
Insert	util/env_posix.cc	/^  bool Insert(const std::string& fname) {$/;"	f	class:leveldb::__anon31::PosixLockTable
Limiter	util/env_posix.cc	/^  Limiter(intptr_t n) {$/;"	f	class:leveldb::__anon31::Limiter
Limiter	util/env_posix.cc	/^class Limiter {$/;"	c	namespace:leveldb::__anon31	file:
LockFile	util/env_posix.cc	/^  virtual Status LockFile(const std::string& fname, FileLock** lock) {$/;"	f	class:leveldb::__anon31::PosixEnv
LockOrUnlock	util/env_posix.cc	/^static int LockOrUnlock(int fd, bool lock) {$/;"	f	namespace:leveldb::__anon31
MaxMmaps	util/env_posix.cc	/^static int MaxMmaps() {$/;"	f	namespace:leveldb::__anon31
MaxOpenFiles	util/env_posix.cc	/^static intptr_t MaxOpenFiles() {$/;"	f	namespace:leveldb::__anon31
NewAppendableFile	util/env_posix.cc	/^  virtual Status NewAppendableFile(const std::string& fname,$/;"	f	class:leveldb::__anon31::PosixEnv
NewBufferedRandomAccessFile	util/env_posix.cc	/^  virtual Status NewBufferedRandomAccessFile(const std::string& fname,$/;"	f	class:leveldb::__anon31::PosixEnv
NewLogger	util/env_posix.cc	/^  virtual Status NewLogger(const std::string& fname, Logger** result) {$/;"	f	class:leveldb::__anon31::PosixEnv
NewRandomAccessFile	util/env_posix.cc	/^  virtual Status NewRandomAccessFile(const std::string& fname,$/;"	f	class:leveldb::__anon31::PosixEnv
NewSequentialFile	util/env_posix.cc	/^  virtual Status NewSequentialFile(const std::string& fname,$/;"	f	class:leveldb::__anon31::PosixEnv
NewWritableFile	util/env_posix.cc	/^  virtual Status NewWritableFile(const std::string& fname,$/;"	f	class:leveldb::__anon31::PosixEnv
NowMicros	util/env_posix.cc	/^  virtual uint64_t NowMicros() {$/;"	f	class:leveldb::__anon31::PosixEnv
PosixBufferedRandomAccessFile	util/env_posix.cc	/^  PosixBufferedRandomAccessFile(const std::string& fname, int fd, Limiter* limiter)$/;"	f	class:leveldb::__anon31::PosixBufferedRandomAccessFile
PosixBufferedRandomAccessFile	util/env_posix.cc	/^class PosixBufferedRandomAccessFile:public RandomAccessFile{$/;"	c	namespace:leveldb::__anon31	file:
PosixEnv	util/env_posix.cc	/^PosixEnv::PosixEnv()$/;"	f	class:leveldb::__anon31::PosixEnv
PosixEnv	util/env_posix.cc	/^class PosixEnv : public Env {$/;"	c	namespace:leveldb::__anon31	file:
PosixError	util/env_posix.cc	/^static Status PosixError(const std::string& context, int err_number) {$/;"	f	namespace:leveldb::__anon31
PosixFileLock	util/env_posix.cc	/^class PosixFileLock : public FileLock {$/;"	c	namespace:leveldb::__anon31	file:
PosixLockTable	util/env_posix.cc	/^class PosixLockTable {$/;"	c	namespace:leveldb::__anon31	file:
PosixMmapReadableFile	util/env_posix.cc	/^  PosixMmapReadableFile(const std::string& fname, void* base, size_t length,$/;"	f	class:leveldb::__anon31::PosixMmapReadableFile
PosixMmapReadableFile	util/env_posix.cc	/^class PosixMmapReadableFile: public RandomAccessFile {$/;"	c	namespace:leveldb::__anon31	file:
PosixRandomAccessFile	util/env_posix.cc	/^  PosixRandomAccessFile(const std::string& fname, int fd, Limiter* limiter,bool direct_IO_flag=false)$/;"	f	class:leveldb::__anon31::PosixRandomAccessFile
PosixRandomAccessFile	util/env_posix.cc	/^class PosixRandomAccessFile: public RandomAccessFile {$/;"	c	namespace:leveldb::__anon31	file:
PosixSequentialFile	util/env_posix.cc	/^  PosixSequentialFile(const std::string& fname, FILE* f)$/;"	f	class:leveldb::__anon31::PosixSequentialFile
PosixSequentialFile	util/env_posix.cc	/^class PosixSequentialFile: public SequentialFile {$/;"	c	namespace:leveldb::__anon31	file:
PosixWritableFile	util/env_posix.cc	/^  PosixWritableFile(const std::string& fname, FILE* f)$/;"	f	class:leveldb::__anon31::PosixWritableFile
PosixWritableFile	util/env_posix.cc	/^class PosixWritableFile : public WritableFile {$/;"	c	namespace:leveldb::__anon31	file:
PthreadCall	util/env_posix.cc	/^  void PthreadCall(const char* label, int result) {$/;"	f	class:leveldb::__anon31::PosixEnv	file:
Read	util/env_posix.cc	/^  inline void Read(char *dest,size_t offset, size_t read_size){$/;"	f	class:leveldb::AlignedBuffer
Read	util/env_posix.cc	/^  virtual Status Read(size_t n, Slice* result, char* scratch) {$/;"	f	class:leveldb::__anon31::PosixSequentialFile
Read	util/env_posix.cc	/^  virtual Status Read(uint64_t offset, size_t n, Slice* result,$/;"	f	class:leveldb::__anon31::PosixBufferedRandomAccessFile
Read	util/env_posix.cc	/^  virtual Status Read(uint64_t offset, size_t n, Slice* result,$/;"	f	class:leveldb::__anon31::PosixMmapReadableFile
Read	util/env_posix.cc	/^  virtual Status Read(uint64_t offset, size_t n, Slice* result,$/;"	f	class:leveldb::__anon31::PosixRandomAccessFile
Reads	util/env_posix.cc	/^    virtual Status Reads(uint64_t offset, size_t n, Slice  results[],$/;"	f	class:leveldb::__anon31::PosixBufferedRandomAccessFile
Reads	util/env_posix.cc	/^   virtual Status Reads(uint64_t offset, size_t n, Slice  results[],$/;"	f	class:leveldb::__anon31::PosixRandomAccessFile
Release	util/env_posix.cc	/^  void Release() {$/;"	f	class:leveldb::__anon31::Limiter
Remove	util/env_posix.cc	/^  void Remove(const std::string& fname) {$/;"	f	class:leveldb::__anon31::PosixLockTable
RenameFile	util/env_posix.cc	/^  virtual Status RenameFile(const std::string& src, const std::string& target) {$/;"	f	class:leveldb::__anon31::PosixEnv
Roundup	util/env_posix.cc	/^inline size_t Roundup(size_t x, size_t y) {$/;"	f	namespace:leveldb
Schedule	util/env_posix.cc	/^void PosixEnv::Schedule(void (*function)(void*), void* arg) {$/;"	f	class:leveldb::__anon31::PosixEnv
SetAllowed	util/env_posix.cc	/^  void SetAllowed(intptr_t v) {$/;"	f	class:leveldb::__anon31::Limiter	file:
SetReadOnlyFDLimit	util/env_posix.cc	/^void EnvPosixTestHelper::SetReadOnlyFDLimit(int limit) {$/;"	f	class:leveldb::EnvPosixTestHelper
SetReadOnlyMMapLimit	util/env_posix.cc	/^void EnvPosixTestHelper::SetReadOnlyMMapLimit(int limit) {$/;"	f	class:leveldb::EnvPosixTestHelper
Skip	util/env_posix.cc	/^  virtual Status Skip(uint64_t n) {$/;"	f	class:leveldb::__anon31::PosixSequentialFile
SleepForMicroseconds	util/env_posix.cc	/^  virtual void SleepForMicroseconds(int micros) {$/;"	f	class:leveldb::__anon31::PosixEnv
StartThread	util/env_posix.cc	/^void PosixEnv::StartThread(void (*function)(void* arg), void* arg) {$/;"	f	class:leveldb::__anon31::PosixEnv
StartThreadState	util/env_posix.cc	/^struct StartThreadState {$/;"	s	namespace:leveldb::__anon31::__anon32	file:
StartThreadWrapper	util/env_posix.cc	/^static void* StartThreadWrapper(void* arg) {$/;"	f	namespace:leveldb::__anon31
Sync	util/env_posix.cc	/^  virtual Status Sync() {$/;"	f	class:leveldb::__anon31::PosixWritableFile
SyncDirIfManifest	util/env_posix.cc	/^  Status SyncDirIfManifest() {$/;"	f	class:leveldb::__anon31::PosixWritableFile
TruncateToPageBoundary	util/env_posix.cc	/^inline size_t TruncateToPageBoundary(size_t page_size, size_t s) {$/;"	f	namespace:leveldb
UngetAlignedBuffer	util/env_posix.cc	/^  static inline void UngetAlignedBuffer(AlignedBuffer *ab){$/;"	f	class:leveldb::AlignedBuffer
UnlockFile	util/env_posix.cc	/^  virtual Status UnlockFile(FileLock* lock) {$/;"	f	class:leveldb::__anon31::PosixEnv
abfs	util/env_posix.cc	/^  static std::vector<AlignedBuffer*> abfs;$/;"	m	class:leveldb::AlignedBuffer	file:
abfs	util/env_posix.cc	/^std::vector<AlignedBuffer*> AlignedBuffer::abfs;$/;"	m	class:leveldb::AlignedBuffer	file:
alignment_	util/env_posix.cc	/^    size_t alignment_;$/;"	m	class:leveldb::AlignedBuffer	file:
allowed_	util/env_posix.cc	/^  port::AtomicPointer allowed_;$/;"	m	class:leveldb::__anon31::Limiter	file:
arg	util/env_posix.cc	/^  struct BGItem { void* arg; void (*function)(void*); };$/;"	m	struct:leveldb::__anon31::PosixEnv::BGItem	file:
arg	util/env_posix.cc	/^  void* arg;$/;"	m	struct:leveldb::__anon31::__anon32::StartThreadState	file:
bgsignal_	util/env_posix.cc	/^  pthread_cond_t bgsignal_;$/;"	m	class:leveldb::__anon31::PosixEnv	file:
bgthread_	util/env_posix.cc	/^  pthread_t bgthread_;$/;"	m	class:leveldb::__anon31::PosixEnv	file:
buffer_mutex	util/env_posix.cc	/^  static SpinMutex buffer_mutex;$/;"	m	class:leveldb::AlignedBuffer	file:
buffer_mutex	util/env_posix.cc	/^SpinMutex AlignedBuffer::buffer_mutex;$/;"	m	class:leveldb::AlignedBuffer	file:
buffer_nums	util/env_posix.cc	/^  static const int buffer_nums;$/;"	m	class:leveldb::AlignedBuffer	file:
buffer_nums	util/env_posix.cc	/^const int AlignedBuffer::buffer_nums = 10;$/;"	m	class:leveldb::AlignedBuffer	file:
bufstart_	util/env_posix.cc	/^    char* bufstart_;$/;"	m	class:leveldb::AlignedBuffer	file:
capacity_	util/env_posix.cc	/^    size_t capacity_;$/;"	m	class:leveldb::AlignedBuffer	file:
cursize_	util/env_posix.cc	/^    size_t cursize_;$/;"	m	class:leveldb::AlignedBuffer	file:
default_env	util/env_posix.cc	/^static Env* default_env;$/;"	m	namespace:leveldb	file:
direct_IO_flag_	util/env_posix.cc	/^   bool direct_IO_flag_;$/;"	m	class:leveldb::__anon31::PosixRandomAccessFile	file:
fd_	util/env_posix.cc	/^  int fd_;$/;"	m	class:leveldb::__anon31::PosixBufferedRandomAccessFile	file:
fd_	util/env_posix.cc	/^  int fd_;$/;"	m	class:leveldb::__anon31::PosixFileLock	file:
fd_	util/env_posix.cc	/^  int fd_;$/;"	m	class:leveldb::__anon31::PosixRandomAccessFile	file:
fd_limit_	util/env_posix.cc	/^  Limiter fd_limit_;$/;"	m	class:leveldb::__anon31::PosixEnv	file:
file_	util/env_posix.cc	/^  FILE* file_;$/;"	m	class:leveldb::__anon31::PosixSequentialFile	file:
file_	util/env_posix.cc	/^  FILE* file_;$/;"	m	class:leveldb::__anon31::PosixWritableFile	file:
filename_	util/env_posix.cc	/^  std::string filename_;$/;"	m	class:leveldb::__anon31::PosixBufferedRandomAccessFile	file:
filename_	util/env_posix.cc	/^  std::string filename_;$/;"	m	class:leveldb::__anon31::PosixMmapReadableFile	file:
filename_	util/env_posix.cc	/^  std::string filename_;$/;"	m	class:leveldb::__anon31::PosixRandomAccessFile	file:
filename_	util/env_posix.cc	/^  std::string filename_;$/;"	m	class:leveldb::__anon31::PosixSequentialFile	file:
filename_	util/env_posix.cc	/^  std::string filename_;$/;"	m	class:leveldb::__anon31::PosixWritableFile	file:
function	util/env_posix.cc	/^  struct BGItem { void* arg; void (*function)(void*); };$/;"	m	struct:leveldb::__anon31::PosixEnv::BGItem	file:
gettid	util/env_posix.cc	/^  static uint64_t gettid() {$/;"	f	class:leveldb::__anon31::PosixEnv
initialized	util/env_posix.cc	/^  static std::atomic<bool> initialized;$/;"	m	class:leveldb::AlignedBuffer	file:
length_	util/env_posix.cc	/^  size_t length_;$/;"	m	class:leveldb::__anon31::PosixMmapReadableFile	file:
leveldb	util/env_posix.cc	/^namespace leveldb {$/;"	n	file:
limiter_	util/env_posix.cc	/^  Limiter* limiter_;$/;"	m	class:leveldb::__anon31::PosixBufferedRandomAccessFile	file:
limiter_	util/env_posix.cc	/^  Limiter* limiter_;$/;"	m	class:leveldb::__anon31::PosixMmapReadableFile	file:
limiter_	util/env_posix.cc	/^  Limiter* limiter_;$/;"	m	class:leveldb::__anon31::PosixRandomAccessFile	file:
locked_files_	util/env_posix.cc	/^  std::set<std::string> locked_files_;$/;"	m	class:leveldb::__anon31::PosixLockTable	file:
locks_	util/env_posix.cc	/^  PosixLockTable locks_;$/;"	m	class:leveldb::__anon31::PosixEnv	file:
mmap_limit	util/env_posix.cc	/^static int mmap_limit = -1;$/;"	m	namespace:leveldb::__anon31	file:
mmap_limit_	util/env_posix.cc	/^  Limiter mmap_limit_;$/;"	m	class:leveldb::__anon31::PosixEnv	file:
mmapped_region_	util/env_posix.cc	/^  void* mmapped_region_;$/;"	m	class:leveldb::__anon31::PosixMmapReadableFile	file:
mu_	util/env_posix.cc	/^  port::Mutex mu_;$/;"	m	class:leveldb::__anon31::Limiter	file:
mu_	util/env_posix.cc	/^  port::Mutex mu_;$/;"	m	class:leveldb::__anon31::PosixLockTable	file:
mu_	util/env_posix.cc	/^  pthread_mutex_t mu_;$/;"	m	class:leveldb::__anon31::PosixEnv	file:
name_	util/env_posix.cc	/^  std::string name_;$/;"	m	class:leveldb::__anon31::PosixFileLock	file:
newEnv	util/env_posix.cc	/^Env* newEnv() { return new PosixEnv;}$/;"	f	namespace:leveldb
once	util/env_posix.cc	/^static pthread_once_t once = PTHREAD_ONCE_INIT;$/;"	m	namespace:leveldb	file:
open_read_only_file_limit	util/env_posix.cc	/^static int open_read_only_file_limit = -1;$/;"	m	namespace:leveldb::__anon31	file:
queue_	util/env_posix.cc	/^  BGQueue queue_;$/;"	m	class:leveldb::__anon31::PosixEnv	file:
started_bgthread_	util/env_posix.cc	/^  bool started_bgthread_;$/;"	m	class:leveldb::__anon31::PosixEnv	file:
temporary_fd_	util/env_posix.cc	/^  bool temporary_fd_;  \/\/ If true, fd_ is -1 and we open on every read.$/;"	m	class:leveldb::__anon31::PosixBufferedRandomAccessFile	file:
temporary_fd_	util/env_posix.cc	/^  bool temporary_fd_;  \/\/ If true, fd_ is -1 and we open on every read.$/;"	m	class:leveldb::__anon31::PosixRandomAccessFile	file:
user_function	util/env_posix.cc	/^  void (*user_function)(void*);$/;"	m	struct:leveldb::__anon31::__anon32::StartThreadState	file:
~AlignedBuffer	util/env_posix.cc	/^   ~AlignedBuffer(){$/;"	f	class:leveldb::AlignedBuffer
~PosixBufferedRandomAccessFile	util/env_posix.cc	/^  virtual ~PosixBufferedRandomAccessFile() {$/;"	f	class:leveldb::__anon31::PosixBufferedRandomAccessFile
~PosixEnv	util/env_posix.cc	/^  virtual ~PosixEnv() {$/;"	f	class:leveldb::__anon31::PosixEnv
~PosixMmapReadableFile	util/env_posix.cc	/^  virtual ~PosixMmapReadableFile() {$/;"	f	class:leveldb::__anon31::PosixMmapReadableFile
~PosixRandomAccessFile	util/env_posix.cc	/^  virtual ~PosixRandomAccessFile() {$/;"	f	class:leveldb::__anon31::PosixRandomAccessFile
~PosixSequentialFile	util/env_posix.cc	/^  virtual ~PosixSequentialFile() { fclose(file_); }$/;"	f	class:leveldb::__anon31::PosixSequentialFile
~PosixWritableFile	util/env_posix.cc	/^  ~PosixWritableFile() {$/;"	f	class:leveldb::__anon31::PosixWritableFile
EnvPosixTest	util/env_posix_test.cc	/^  EnvPosixTest() : env_(Env::Default()) { }$/;"	f	class:leveldb::EnvPosixTest
EnvPosixTest	util/env_posix_test.cc	/^class EnvPosixTest {$/;"	c	namespace:leveldb	file:
SetFileLimits	util/env_posix_test.cc	/^  static void SetFileLimits(int read_only_file_limit, int mmap_limit) {$/;"	f	class:leveldb::EnvPosixTest
TEST	util/env_posix_test.cc	/^TEST(EnvPosixTest, TestOpenOnRead) {$/;"	f	namespace:leveldb
env_	util/env_posix_test.cc	/^  Env* env_;$/;"	m	class:leveldb::EnvPosixTest	file:
kDelayMicros	util/env_posix_test.cc	/^static const int kDelayMicros = 100000;$/;"	m	namespace:leveldb	file:
kMMapLimit	util/env_posix_test.cc	/^static const int kMMapLimit = 4;$/;"	m	namespace:leveldb	file:
kReadOnlyFileLimit	util/env_posix_test.cc	/^static const int kReadOnlyFileLimit = 4;$/;"	m	namespace:leveldb	file:
leveldb	util/env_posix_test.cc	/^namespace leveldb {$/;"	n	file:
main	util/env_posix_test.cc	/^int main(int argc, char** argv) {$/;"	f
EnvPosixTestHelper	util/env_posix_test_helper.h	/^class EnvPosixTestHelper {$/;"	c	namespace:leveldb
STORAGE_LEVELDB_UTIL_ENV_POSIX_TEST_HELPER_H_	util/env_posix_test_helper.h	6;"	d
leveldb	util/env_posix_test_helper.h	/^namespace leveldb {$/;"	n
EnvTest	util/env_test.cc	/^  EnvTest() : env_(Env::Default()) { }$/;"	f	class:leveldb::EnvTest
EnvTest	util/env_test.cc	/^class EnvTest {$/;"	c	namespace:leveldb	file:
SetBool	util/env_test.cc	/^static void SetBool(void* ptr) {$/;"	f	namespace:leveldb
State	util/env_test.cc	/^struct State {$/;"	s	namespace:leveldb	file:
TEST	util/env_test.cc	/^TEST(EnvTest, RunImmediately) {$/;"	f	namespace:leveldb
TEST	util/env_test.cc	/^TEST(EnvTest, RunMany) {$/;"	f	namespace:leveldb
TEST	util/env_test.cc	/^TEST(EnvTest, StartThread) {$/;"	f	namespace:leveldb
TEST	util/env_test.cc	/^TEST(EnvTest, TestOpenNonExistentFile) {$/;"	f	namespace:leveldb
ThreadBody	util/env_test.cc	/^static void ThreadBody(void* arg) {$/;"	f	namespace:leveldb
env_	util/env_test.cc	/^  Env* env_;$/;"	m	class:leveldb::EnvTest	file:
events_	util/env_test.cc	/^  std::string events_;$/;"	m	class:leveldb::EnvTest	file:
kDelayMicros	util/env_test.cc	/^static const int kDelayMicros = 100000;$/;"	m	namespace:leveldb	file:
kMMapLimit	util/env_test.cc	/^static const int kMMapLimit = 4;$/;"	m	namespace:leveldb	file:
kReadOnlyFileLimit	util/env_test.cc	/^static const int kReadOnlyFileLimit = 4;$/;"	m	namespace:leveldb	file:
leveldb	util/env_test.cc	/^namespace leveldb {$/;"	n	file:
main	util/env_test.cc	/^int main(int argc, char** argv) {$/;"	f
mu	util/env_test.cc	/^  port::Mutex mu;$/;"	m	struct:leveldb::State	file:
mu_	util/env_test.cc	/^  port::Mutex mu_;$/;"	m	class:leveldb::EnvTest	file:
num_running	util/env_test.cc	/^  int num_running;$/;"	m	struct:leveldb::State	file:
val	util/env_test.cc	/^  int val;$/;"	m	struct:leveldb::State	file:
leveldb	util/filter_policy.cc	/^namespace leveldb {$/;"	n	file:
~FilterPolicy	util/filter_policy.cc	/^FilterPolicy::~FilterPolicy() { }$/;"	f	class:leveldb::FilterPolicy
FALLTHROUGH_INTENDED	util/hash.cc	13;"	d	file:
Hash	util/hash.cc	/^uint32_t Hash(const char* data, size_t n, uint32_t seed) {$/;"	f	namespace:leveldb
leveldb	util/hash.cc	/^namespace leveldb {$/;"	n	file:
STORAGE_LEVELDB_UTIL_HASH_H_	util/hash.h	8;"	d
leveldb	util/hash.h	/^namespace leveldb {$/;"	n
HASH	util/hash_test.cc	/^class HASH { };$/;"	c	namespace:leveldb	file:
TEST	util/hash_test.cc	/^TEST(HASH, SignedUnsignedIssue) {$/;"	f	namespace:leveldb
leveldb	util/hash_test.cc	/^namespace leveldb {$/;"	n	file:
main	util/hash_test.cc	/^int main(int argc, char** argv) {$/;"	f
Add	util/histogram.cc	/^void Histogram::Add(double value) {$/;"	f	class:leveldb::Histogram
Average	util/histogram.cc	/^double Histogram::Average() const {$/;"	f	class:leveldb::Histogram
Clear	util/histogram.cc	/^void Histogram::Clear() {$/;"	f	class:leveldb::Histogram
Median	util/histogram.cc	/^double Histogram::Median() const {$/;"	f	class:leveldb::Histogram
Merge	util/histogram.cc	/^void Histogram::Merge(const Histogram& other) {$/;"	f	class:leveldb::Histogram
Percentile	util/histogram.cc	/^double Histogram::Percentile(double p) const {$/;"	f	class:leveldb::Histogram
StandardDeviation	util/histogram.cc	/^double Histogram::StandardDeviation() const {$/;"	f	class:leveldb::Histogram
ToString	util/histogram.cc	/^std::string Histogram::ToString() const {$/;"	f	class:leveldb::Histogram
kBucketLimit	util/histogram.cc	/^const double Histogram::kBucketLimit[kNumBuckets] = {$/;"	m	class:leveldb::Histogram	file:
leveldb	util/histogram.cc	/^namespace leveldb {$/;"	n	file:
Histogram	util/histogram.h	/^  Histogram() { }$/;"	f	class:leveldb::Histogram
Histogram	util/histogram.h	/^class Histogram {$/;"	c	namespace:leveldb
STORAGE_LEVELDB_UTIL_HISTOGRAM_H_	util/histogram.h	6;"	d
buckets_	util/histogram.h	/^  double buckets_[kNumBuckets];$/;"	m	class:leveldb::Histogram
kBucketLimit	util/histogram.h	/^  static const double kBucketLimit[kNumBuckets];$/;"	m	class:leveldb::Histogram
kNumBuckets	util/histogram.h	/^  enum { kNumBuckets = 154 };$/;"	e	enum:leveldb::Histogram::__anon29
leveldb	util/histogram.h	/^namespace leveldb {$/;"	n
max_	util/histogram.h	/^  double max_;$/;"	m	class:leveldb::Histogram
min_	util/histogram.h	/^  double min_;$/;"	m	class:leveldb::Histogram
num_	util/histogram.h	/^  double num_;$/;"	m	class:leveldb::Histogram
sum_	util/histogram.h	/^  double sum_;$/;"	m	class:leveldb::Histogram
sum_squares_	util/histogram.h	/^  double sum_squares_;$/;"	m	class:leveldb::Histogram
~Histogram	util/histogram.h	/^  ~Histogram() { }$/;"	f	class:leveldb::Histogram
AppendEscapedStringTo	util/logging.cc	/^void AppendEscapedStringTo(std::string* str, const Slice& value) {$/;"	f	namespace:leveldb
AppendNumberTo	util/logging.cc	/^void AppendNumberTo(std::string* str, uint64_t num) {$/;"	f	namespace:leveldb
ConsumeDecimalNumber	util/logging.cc	/^bool ConsumeDecimalNumber(Slice* in, uint64_t* val) {$/;"	f	namespace:leveldb
EscapeString	util/logging.cc	/^std::string EscapeString(const Slice& value) {$/;"	f	namespace:leveldb
NumberToString	util/logging.cc	/^std::string NumberToString(uint64_t num) {$/;"	f	namespace:leveldb
leveldb	util/logging.cc	/^namespace leveldb {$/;"	n	file:
STORAGE_LEVELDB_UTIL_LOGGING_H_	util/logging.h	9;"	d
leveldb	util/logging.h	/^namespace leveldb {$/;"	n
BloomHash	util/multi_bloom.cc	/^static uint32_t BloomHash(const Slice& key,int id) {$/;"	f	namespace:leveldb::__anon35
ChildBloomFilterPolicy	util/multi_bloom.cc	/^  explicit ChildBloomFilterPolicy(int bits_per_key,int id)$/;"	f	class:leveldb::__anon35::ChildBloomFilterPolicy
ChildBloomFilterPolicy	util/multi_bloom.cc	/^class ChildBloomFilterPolicy : public FilterPolicy {$/;"	c	namespace:leveldb::__anon35	file:
CreateFilter	util/multi_bloom.cc	/^	virtual void CreateFilter(const Slice * keys,int n, std::string *dst) const{$/;"	f	class:leveldb::__anon35::MultiFilter
CreateFilter	util/multi_bloom.cc	/^	virtual void CreateFilter(const Slice *keys,int n,std::list<std::string> &dsts) const {$/;"	f	class:leveldb::__anon35::MultiFilter
CreateFilter	util/multi_bloom.cc	/^  virtual void CreateFilter(const Slice *keys,int n,std::list<std::string> &dsts) const {$/;"	f	class:leveldb::__anon35::ChildBloomFilterPolicy
CreateFilter	util/multi_bloom.cc	/^  virtual void CreateFilter(const Slice* keys, int n, std::string* dst) const {$/;"	f	class:leveldb::__anon35::ChildBloomFilterPolicy
CreateFilterArg	util/multi_bloom.cc	/^struct CreateFilterArg{$/;"	s	namespace:leveldb::__anon35	file:
CreateFilter_T	util/multi_bloom.cc	/^	static void* CreateFilter_T(void *arg){$/;"	f	class:leveldb::__anon35::MultiFilter
KeyMayMatch	util/multi_bloom.cc	/^	virtual bool KeyMayMatch(const Slice& key, const Slice& bloom_filter) const{$/;"	f	class:leveldb::__anon35::MultiFilter
KeyMayMatch	util/multi_bloom.cc	/^	virtual bool KeyMayMatch(const Slice& key, const Slice& bloom_filter,int id) const{$/;"	f	class:leveldb::__anon35::MultiFilter
KeyMayMatch	util/multi_bloom.cc	/^  virtual bool KeyMayMatch(const Slice& key, const Slice& bloom_filter) const {$/;"	f	class:leveldb::__anon35::ChildBloomFilterPolicy
KeyMayMatchFilters	util/multi_bloom.cc	/^	virtual bool KeyMayMatchFilters(const Slice& key, const std::list<Slice> &filter_strs) const{$/;"	f	class:leveldb::__anon35::MultiFilter
KeyMayMatchFilters	util/multi_bloom.cc	/^  virtual bool KeyMayMatchFilters(const Slice& key, const std::list<leveldb::Slice>& filters) const {$/;"	f	class:leveldb::__anon35::ChildBloomFilterPolicy
MultiFilter	util/multi_bloom.cc	/^	explicit MultiFilter(int bits_per_key_per_filter[],int bits_per_key):bits_per_key_(bits_per_key){$/;"	f	class:leveldb::__anon35::MultiFilter
MultiFilter	util/multi_bloom.cc	/^class MultiFilter:public FilterPolicy{$/;"	c	namespace:leveldb::__anon35	file:
Name	util/multi_bloom.cc	/^	virtual const char* Name() const{$/;"	f	class:leveldb::__anon35::MultiFilter
Name	util/multi_bloom.cc	/^  virtual const char* Name() const {$/;"	f	class:leveldb::__anon35::ChildBloomFilterPolicy
NewBloomFilterPolicy	util/multi_bloom.cc	/^const FilterPolicy *NewBloomFilterPolicy(int *){$/;"	f	namespace:leveldb
NewBloomFilterPolicy	util/multi_bloom.cc	/^const FilterPolicy *NewBloomFilterPolicy(int){$/;"	f	namespace:leveldb
NewBloomFilterPolicy	util/multi_bloom.cc	/^const FilterPolicy* NewBloomFilterPolicy(int bits_per_key_per_filter[],int bits_per_key) {$/;"	f	namespace:leveldb
bits_per_key_	util/multi_bloom.cc	/^	size_t bits_per_key_;$/;"	m	class:leveldb::__anon35::MultiFilter	file:
bits_per_key_	util/multi_bloom.cc	/^  size_t bits_per_key_;$/;"	m	class:leveldb::__anon35::ChildBloomFilterPolicy	file:
cfas	util/multi_bloom.cc	/^	static CreateFilterArg *cfas;$/;"	m	class:leveldb::__anon35::MultiFilter	file:
ch	util/multi_bloom.cc	/^	  ChildBloomFilterPolicy *ch;$/;"	m	struct:leveldb::__anon35::CreateFilterArg	file:
curr_completed_filter_num_	util/multi_bloom.cc	/^	static std::atomic<int> curr_completed_filter_num_;$/;"	m	class:leveldb::__anon35::MultiFilter	file:
dst	util/multi_bloom.cc	/^	  std::string *dst;$/;"	m	struct:leveldb::__anon35::CreateFilterArg	file:
end_thread	util/multi_bloom.cc	/^	static bool end_thread;$/;"	m	class:leveldb::__anon35::MultiFilter	file:
filled_	util/multi_bloom.cc	/^        static std::atomic<bool> filled_[16];$/;"	m	class:leveldb::__anon35::MultiFilter	file:
filled_	util/multi_bloom.cc	/^std::atomic<bool>  MultiFilter::filled_[16];$/;"	m	class:leveldb::__anon35::MultiFilter	file:
filterNums	util/multi_bloom.cc	/^  virtual int filterNums() const{$/;"	f	class:leveldb::__anon35::ChildBloomFilterPolicy
filter_num_	util/multi_bloom.cc	/^	static int filter_num_;$/;"	m	class:leveldb::__anon35::MultiFilter	file:
filter_num_	util/multi_bloom.cc	/^int MultiFilter::filter_num_ = 0;$/;"	m	class:leveldb::__anon35::MultiFilter	file:
filters	util/multi_bloom.cc	/^	std::vector<ChildBloomFilterPolicy*> filters;$/;"	m	class:leveldb::__anon35::MultiFilter	file:
handle_error_en	util/multi_bloom.cc	19;"	d	file:
id_	util/multi_bloom.cc	/^  int id_; \/\/begin from 0$/;"	m	class:leveldb::__anon35::ChildBloomFilterPolicy	file:
k_	util/multi_bloom.cc	/^  size_t k_;$/;"	m	class:leveldb::__anon35::ChildBloomFilterPolicy	file:
keys_	util/multi_bloom.cc	/^	static const Slice *keys_;$/;"	m	class:leveldb::__anon35::MultiFilter	file:
leveldb	util/multi_bloom.cc	/^namespace leveldb {$/;"	n	file:
n_	util/multi_bloom.cc	/^	static int n_;$/;"	m	class:leveldb::__anon35::MultiFilter	file:
pids_	util/multi_bloom.cc	/^	static pthread_t pids_[16];$/;"	m	class:leveldb::__anon35::MultiFilter	file:
pids_	util/multi_bloom.cc	/^pthread_t MultiFilter::pids_[16];$/;"	m	class:leveldb::__anon35::MultiFilter	file:
~MultiFilter	util/multi_bloom.cc	/^	virtual ~MultiFilter(){$/;"	f	class:leveldb::__anon35::MultiFilter
AllocFilterNums	util/multi_queue.cc	/^        int MultiQueue::AllocFilterNums(int freq) {$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
BGShrinkUsage	util/multi_queue.cc	/^        void MultiQueue::BGShrinkUsage(void *mq)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
BackgroudShrinkUsage	util/multi_queue.cc	/^        void MultiQueue::BackgroudShrinkUsage()$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
Erase	util/multi_queue.cc	/^        void MultiQueue::Erase(const Slice &key)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
Erase	util/multi_queue.cc	/^        void MultiQueue::Erase(const Slice &key, uint32_t hash)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
FalsePositive	util/multi_queue.cc	/^        inline double MultiQueue::FalsePositive(LRUQueueHandle *e)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
FindPointer	util/multi_queue.cc	/^            LRUQueueHandle **FindPointer(const Slice &key, uint32_t hash)$/;"	f	class:leveldb::multiqueue_ns::HandleTable	file:
FinishErase	util/multi_queue.cc	/^        bool MultiQueue::FinishErase(LRUQueueHandle *e)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
ForceShrinking	util/multi_queue.cc	/^        void MultiQueue::ForceShrinking()$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
GetLRUFreCount	util/multi_queue.cc	/^        inline uint64_t MultiQueue::GetLRUFreCount() const$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
HandleTable	util/multi_queue.cc	/^            HandleTable() : length_(0), elems_(0), list_(NULL)$/;"	f	class:leveldb::multiqueue_ns::HandleTable
HandleTable	util/multi_queue.cc	/^        class HandleTable     \/\/ a list store LRUQueueHandle's address , don't care queue id$/;"	c	namespace:leveldb::multiqueue_ns	file:
HashSlice	util/multi_queue.cc	/^            static inline uint32_t HashSlice(const Slice &s)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
Insert	util/multi_queue.cc	/^            LRUQueueHandle *Insert(LRUQueueHandle *h)$/;"	f	class:leveldb::multiqueue_ns::HandleTable
Insert	util/multi_queue.cc	/^        Cache::Handle *MultiQueue::Insert(const Slice &key, uint32_t hash, void *value, size_t charge, void (*deleter)(const Slice &key, void *value), bool type)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
Insert	util/multi_queue.cc	/^        Cache::Handle *MultiQueue::Insert(const Slice &key, void *value, size_t charge, void (*deleter)(const Slice &key, void *value))$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
Insert	util/multi_queue.cc	/^        Cache::Handle *MultiQueue::Insert(const Slice &key, void *value, size_t charge, void (*deleter)(const Slice &key, void *value), bool type)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
IsCacheFull	util/multi_queue.cc	/^        inline bool MultiQueue::IsCacheFull() const$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
LRUQueueHandle	util/multi_queue.cc	/^        struct LRUQueueHandle$/;"	s	namespace:leveldb::multiqueue_ns	file:
LRU_Append	util/multi_queue.cc	/^        void MultiQueue::LRU_Append(LRUQueueHandle *list, LRUQueueHandle *e)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
LRU_Remove	util/multi_queue.cc	/^        void MultiQueue::LRU_Remove(LRUQueueHandle *e)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
LRU_Status	util/multi_queue.cc	/^        std::string MultiQueue::LRU_Status()$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
Lookup	util/multi_queue.cc	/^            LRUQueueHandle *Lookup(const Slice &key, uint32_t hash)$/;"	f	class:leveldb::multiqueue_ns::HandleTable
Lookup	util/multi_queue.cc	/^        Cache::Handle *MultiQueue::Lookup(const Slice &key)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
Lookup	util/multi_queue.cc	/^        Cache::Handle *MultiQueue::Lookup(const Slice &key, bool Get)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
Lookup	util/multi_queue.cc	/^        Cache::Handle *MultiQueue::Lookup(const Slice &key, uint32_t hash, bool Get)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
LookupFreCount	util/multi_queue.cc	/^        uint64_t MultiQueue::LookupFreCount(const Slice &key)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
MayBeShrinkUsage	util/multi_queue.cc	/^        void MultiQueue::MayBeShrinkUsage()$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
MultiQueue	util/multi_queue.cc	/^        MultiQueue::MultiQueue(size_t capacity, int lrus_num, int base_num, uint64_t life_time, double fr, double sr, double cr, int lg_b, double s_r): capacity_(capacity), lrus_num_(lrus_num), base_num_(base_num), life_time_(life_time), shrinking_(false)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
MultiQueue	util/multi_queue.cc	/^        class MultiQueue: public Cache$/;"	c	namespace:leveldb::multiqueue_ns	file:
NewId	util/multi_queue.cc	/^        uint64_t MultiQueue::NewId()$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
NewMultiQueue	util/multi_queue.cc	/^    Cache *NewMultiQueue(size_t capacity, int lrus_num, int base_num, uint64_t life_time, double force_shrink_ratio, double slow_shrink_ratio, double change_ratio, int lg_b, double s_r)$/;"	f	namespace:leveldb
Num_Queue	util/multi_queue.cc	/^        inline uint64_t MultiQueue::Num_Queue(int queue_id, uint64_t fre_count)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
Prune	util/multi_queue.cc	/^            void Prune() {} \/\/do nothing$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
RecomputeExp	util/multi_queue.cc	/^        void MultiQueue::RecomputeExp(LRUQueueHandle *e)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
RecomputeExpTable	util/multi_queue.cc	/^        void MultiQueue::RecomputeExpTable(LRUQueueHandle *e)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
Ref	util/multi_queue.cc	/^        void MultiQueue::Ref(LRUQueueHandle *e, bool addFreCount)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
Release	util/multi_queue.cc	/^        void MultiQueue::Release(Cache::Handle *handle)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
Remove	util/multi_queue.cc	/^            LRUQueueHandle *Remove(const Slice &key, uint32_t hash)$/;"	f	class:leveldb::multiqueue_ns::HandleTable
Resize	util/multi_queue.cc	/^            void Resize()$/;"	f	class:leveldb::multiqueue_ns::HandleTable	file:
SetFreCount	util/multi_queue.cc	/^        void MultiQueue::SetFreCount(const Slice &key, uint64_t freCount)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
ShrinkLRU	util/multi_queue.cc	/^        inline bool MultiQueue::ShrinkLRU(int k, int64_t remove_charge[], bool force)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
SlowShrinking	util/multi_queue.cc	/^        void MultiQueue::SlowShrinking()$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
TotalCharge	util/multi_queue.cc	/^        size_t MultiQueue::TotalCharge() const$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
TurnOffAdjustment	util/multi_queue.cc	/^        void MultiQueue::TurnOffAdjustment() {$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
TurnOnAdjustment	util/multi_queue.cc	/^        void MultiQueue::TurnOnAdjustment() {$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
Unref	util/multi_queue.cc	/^        void MultiQueue::Unref(LRUQueueHandle *e)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
Value	util/multi_queue.cc	/^        void *MultiQueue::Value(Cache::Handle *handle)$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
addCurrentTime	util/multi_queue.cc	/^            void inline addCurrentTime()$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
base_fre_counts	util/multi_queue.cc	/^            static uint64_t base_fre_counts[10];$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
base_fre_counts	util/multi_queue.cc	/^    uint64_t multiqueue_ns::MultiQueue::base_fre_counts[10] = {4, 10, 28, 82, 243, 730};$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
base_num_	util/multi_queue.cc	/^            int base_num_ ;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
bits_per_key_per_filter_	util/multi_queue.cc	/^            std::vector<size_t> bits_per_key_per_filter_, bits_per_key_per_filter_sum;  \/\/begin from 0 bits$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
bits_per_key_per_filter_sum	util/multi_queue.cc	/^            std::vector<size_t> bits_per_key_per_filter_, bits_per_key_per_filter_sum;  \/\/begin from 0 bits$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
capacity_	util/multi_queue.cc	/^            size_t capacity_;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
change_ratio	util/multi_queue.cc	/^            double change_ratio;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
charge	util/multi_queue.cc	/^            size_t charge;      \/\/ TODO(opt): Only allow uint32_t?$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
charges_	util/multi_queue.cc	/^            size_t *charges_;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
current_time_	util/multi_queue.cc	/^            uint64_t current_time_;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
deleter	util/multi_queue.cc	/^            void (*deleter)(const Slice &, void *value);$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
dynamic_merge_counter	util/multi_queue.cc	/^            uint64_t dynamic_merge_counter[2];$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
elems_	util/multi_queue.cc	/^            uint32_t elems_;$/;"	m	class:leveldb::multiqueue_ns::HandleTable	file:
expection_	util/multi_queue.cc	/^            double expection_;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
expire_time	util/multi_queue.cc	/^            uint64_t expire_time; \/\/expire_time = current_time_ + life_time_$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
force_shrink_ratio	util/multi_queue.cc	/^            double force_shrink_ratio;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
fps	util/multi_queue.cc	/^            std::vector<double> fps;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
fre_count	util/multi_queue.cc	/^            uint64_t fre_count;   \/\/frequency count$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
hash	util/multi_queue.cc	/^            uint32_t hash;      \/\/ Hash of key(); used for fast sharding and comparisons$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
in_cache	util/multi_queue.cc	/^            bool in_cache;      \/\/ Whether entry is in the cache.$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
in_use_	util/multi_queue.cc	/^            LRUQueueHandle in_use_;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
insert_count	util/multi_queue.cc	/^            int insert_count;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
is_split	util/multi_queue.cc	/^            bool is_split;$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
key	util/multi_queue.cc	/^            Slice key() const$/;"	f	struct:leveldb::multiqueue_ns::LRUQueueHandle
key_data	util/multi_queue.cc	/^            char key_data[1];   \/\/ Beginning of key$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
key_length	util/multi_queue.cc	/^            size_t key_length;$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
last_id_	util/multi_queue.cc	/^            std::atomic<uint64_t> last_id_;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
length_	util/multi_queue.cc	/^            uint32_t length_;$/;"	m	class:leveldb::multiqueue_ns::HandleTable	file:
leveldb	util/multi_queue.cc	/^namespace leveldb$/;"	n	file:
life_time_	util/multi_queue.cc	/^            uint64_t life_time_;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
list_	util/multi_queue.cc	/^            LRUQueueHandle **list_;$/;"	m	class:leveldb::multiqueue_ns::HandleTable	file:
log_base	util/multi_queue.cc	/^            const double log_base;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
lru_lens_	util/multi_queue.cc	/^            std::vector<size_t> lru_lens_;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
lrus_	util/multi_queue.cc	/^            LRUQueueHandle *lrus_;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
lrus_num_	util/multi_queue.cc	/^            int lrus_num_;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
mq_env	util/multi_queue.cc	/^            static Env *mq_env;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
mq_env	util/multi_queue.cc	/^    Env *multiqueue_ns::MultiQueue::mq_env;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
multiqueue_ns	util/multi_queue.cc	/^    namespace multiqueue_ns$/;"	n	namespace:leveldb	file:
mutex_	util/multi_queue.cc	/^            mutable leveldb::SpinMutex mutex_;  \/\/for hashtable ,usage_ and e$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
need_adjust	util/multi_queue.cc	/^            bool need_adjust;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
next	util/multi_queue.cc	/^            LRUQueueHandle *next;$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
next_hash	util/multi_queue.cc	/^            LRUQueueHandle *next_hash;$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
next_region	util/multi_queue.cc	/^            LRUQueueHandle *table_handle, *prev_region, *next_region;$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
prev	util/multi_queue.cc	/^            LRUQueueHandle *prev;$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
prev_region	util/multi_queue.cc	/^            LRUQueueHandle *table_handle, *prev_region, *next_region;$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
queue_id	util/multi_queue.cc	/^            uint16_t queue_id;   \/\/ queue id  start from 0  and 0 means 0 filter$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
refs	util/multi_queue.cc	/^            uint32_t refs;      \/\/ References, including cache reference, if present.$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
shrinking_	util/multi_queue.cc	/^            std::atomic<bool> shrinking_;  \/\/shrinking usage?$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
shutting_down_	util/multi_queue.cc	/^            std::atomic<bool> shutting_down_;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
slow_ratio	util/multi_queue.cc	/^            double slow_ratio;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
slow_shrink_ratio	util/multi_queue.cc	/^            double slow_shrink_ratio;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
sum_freqs_	util/multi_queue.cc	/^            std::vector<size_t> sum_freqs_;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
sum_lru_len	util/multi_queue.cc	/^            atomic<size_t> sum_lru_len;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
table_	util/multi_queue.cc	/^            HandleTable table_;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
table_handle	util/multi_queue.cc	/^            LRUQueueHandle *table_handle, *prev_region, *next_region;$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
type	util/multi_queue.cc	/^            bool type;      \/\/"true” represents  tableandfile$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
usage_	util/multi_queue.cc	/^            std::atomic<size_t> usage_;$/;"	m	class:leveldb::multiqueue_ns::MultiQueue	file:
value	util/multi_queue.cc	/^            void *value;$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
value_id	util/multi_queue.cc	/^            uint32_t value_id;$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
value_refs	util/multi_queue.cc	/^            uint32_t value_refs;$/;"	m	struct:leveldb::multiqueue_ns::LRUQueueHandle	file:
~HandleTable	util/multi_queue.cc	/^            ~HandleTable()$/;"	f	class:leveldb::multiqueue_ns::HandleTable
~MultiQueue	util/multi_queue.cc	/^        MultiQueue::~MultiQueue()$/;"	f	class:leveldb::multiqueue_ns::MultiQueue
EXCLUSIVE_LOCK_FUNCTION	util/mutexlock.h	/^  explicit MutexLock(port::Mutex *mu) EXCLUSIVE_LOCK_FUNCTION(mu)$/;"	f	class:leveldb::MutexLock
EXCLUSIVE_LOCK_FUNCTION	util/mutexlock.h	/^  explicit SpinMutexLock(SpinMutex *mu) EXCLUSIVE_LOCK_FUNCTION(mu)$/;"	f	class:leveldb::SpinMutexLock
MutexLock	util/mutexlock.h	/^class SCOPED_LOCKABLE MutexLock {$/;"	c	namespace:leveldb
STORAGE_LEVELDB_UTIL_MUTEXLOCK_H_	util/mutexlock.h	6;"	d
SpinMutex	util/mutexlock.h	/^  SpinMutex() : locked_(false) {}$/;"	f	class:leveldb::SpinMutex
SpinMutex	util/mutexlock.h	/^class SpinMutex {$/;"	c	namespace:leveldb
SpinMutexLock	util/mutexlock.h	/^class SCOPED_LOCKABLE SpinMutexLock {$/;"	c	namespace:leveldb
UNLOCK_FUNCTION	util/mutexlock.h	/^  ~MutexLock() UNLOCK_FUNCTION() { this->mu_->Unlock(); }$/;"	f	class:leveldb::MutexLock
UNLOCK_FUNCTION	util/mutexlock.h	/^  ~SpinMutexLock() UNLOCK_FUNCTION() { this->mu_->unlock(); }$/;"	f	class:leveldb::SpinMutexLock
leveldb	util/mutexlock.h	/^namespace leveldb {$/;"	n
lock	util/mutexlock.h	/^  void lock() {$/;"	f	class:leveldb::SpinMutex
locked_	util/mutexlock.h	/^  std::atomic<bool> locked_;$/;"	m	class:leveldb::SpinMutex
mu_	util/mutexlock.h	/^  SpinMutex *const mu_;$/;"	m	class:leveldb::SpinMutexLock
mu_	util/mutexlock.h	/^  port::Mutex *const mu_;$/;"	m	class:leveldb::MutexLock::port
try_lock	util/mutexlock.h	/^  bool try_lock() {$/;"	f	class:leveldb::SpinMutex
unlock	util/mutexlock.h	/^  void unlock() { locked_.store(false, std::memory_order_release); }$/;"	f	class:leveldb::SpinMutex
Options	util/options.cc	/^Options::Options()$/;"	f	class:leveldb::Options
leveldb	util/options.cc	/^namespace leveldb {$/;"	n	file:
Logv	util/posix_logger.h	/^  virtual void Logv(const char* format, va_list ap) {$/;"	f	class:leveldb::PosixLogger
PosixLogger	util/posix_logger.h	/^  PosixLogger(FILE* f, uint64_t (*gettid)()) : file_(f), gettid_(gettid) { }$/;"	f	class:leveldb::PosixLogger
PosixLogger	util/posix_logger.h	/^class PosixLogger : public Logger {$/;"	c	namespace:leveldb
STORAGE_LEVELDB_UTIL_POSIX_LOGGER_H_	util/posix_logger.h	9;"	d
file_	util/posix_logger.h	/^  FILE* file_;$/;"	m	class:leveldb::PosixLogger
gettid_	util/posix_logger.h	/^  uint64_t (*gettid_)();  \/\/ Return the thread id for the current thread$/;"	m	class:leveldb::PosixLogger
leveldb	util/posix_logger.h	/^namespace leveldb {$/;"	n
~PosixLogger	util/posix_logger.h	/^  virtual ~PosixLogger() {$/;"	f	class:leveldb::PosixLogger
Next	util/random.h	/^  uint32_t Next() {$/;"	f	class:leveldb::Random
OneIn	util/random.h	/^  bool OneIn(int n) { return (Next() % n) == 0; }$/;"	f	class:leveldb::Random
Random	util/random.h	/^  explicit Random(uint32_t s) : seed_(s & 0x7fffffffu) {$/;"	f	class:leveldb::Random
Random	util/random.h	/^class Random {$/;"	c	namespace:leveldb
STORAGE_LEVELDB_UTIL_RANDOM_H_	util/random.h	6;"	d
Skewed	util/random.h	/^  uint32_t Skewed(int max_log) {$/;"	f	class:leveldb::Random
Uniform	util/random.h	/^  uint32_t Uniform(int n) { return Next() % n; }$/;"	f	class:leveldb::Random
leveldb	util/random.h	/^namespace leveldb {$/;"	n
seed_	util/random.h	/^  uint32_t seed_;$/;"	m	class:leveldb::Random
CreateDBStatistics	util/statistics.cc	/^std::shared_ptr<Statistics> CreateDBStatistics(){$/;"	f	namespace:leveldb
GetTickerHistogram	util/statistics.cc	/^inline uint64_t Statistics::GetTickerHistogram(uint32_t tickerType) const$/;"	f	class:leveldb::Statistics
MeasureTime	util/statistics.cc	/^void MeasureTime(Statistics * statistics,uint32_t histogram_type,uint64_t value){$/;"	f	namespace:leveldb
RecordTick	util/statistics.cc	/^inline void RecordTick(Statistics *statistics,uint32_t ticker_type,uint64_t count=1){$/;"	f	namespace:leveldb
STAT_COUNTER_CAP	util/statistics.cc	10;"	d	file:
STAT_COUNTER_NUSEC	util/statistics.cc	11;"	d	file:
Statistics	util/statistics.cc	/^Statistics::Statistics(){$/;"	f	class:leveldb::Statistics
ToString	util/statistics.cc	/^std::string Statistics::ToString(uint32_t begin_type, uint32_t end_type)$/;"	f	class:leveldb::Statistics
counters	util/statistics.cc	/^	uint32_t* counters;$/;"	m	class:leveldb::latency_statistics	file:
getTickerCount	util/statistics.cc	/^inline uint64_t Statistics::getTickerCount(uint32_t tickerType) const$/;"	f	class:leveldb::Statistics
init	util/statistics.cc	/^void Statistics::init(){$/;"	f	class:leveldb::Statistics
latency_record	util/statistics.cc	/^void latency_statistics::latency_record(const uint64_t usec) {$/;"	f	class:leveldb::latency_statistics
latency_show	util/statistics.cc	/^void latency_statistics::latency_show(const char * const tag, FILE * const out) {$/;"	f	class:leveldb::latency_statistics
latency_statistics	util/statistics.cc	/^class latency_statistics {$/;"	c	namespace:leveldb	file:
latency_statistics	util/statistics.cc	/^latency_statistics::latency_statistics() {$/;"	f	class:leveldb::latency_statistics
leveldb	util/statistics.cc	/^namespace leveldb{$/;"	n	file:
measureTime	util/statistics.cc	/^inline void Statistics::measureTime(uint32_t tickerType, uint64_t value)$/;"	f	class:leveldb::Statistics
recordTick	util/statistics.cc	/^inline void Statistics::recordTick(uint32_t tickerType, uint64_t count)$/;"	f	class:leveldb::Statistics
reset	util/statistics.cc	/^void Statistics::reset(){$/;"	f	class:leveldb::Statistics
setTickerCount	util/statistics.cc	/^inline void Statistics::setTickerCount(uint32_t tickerType, uint64_t count)$/;"	f	class:leveldb::Statistics
setTickerCount	util/statistics.cc	/^inline void setTickerCount(Statistics *statistics,uint32_t ticker_type,uint64_t count){$/;"	f	namespace:leveldb
statis_	util/statistics.cc	/^std::shared_ptr<Statistics> Statistics::statis_ = nullptr;$/;"	m	class:leveldb::Statistics	file:
~latency_statistics	util/statistics.cc	/^latency_statistics::~latency_statistics() {$/;"	f	class:leveldb::latency_statistics
CopyState	util/status.cc	/^const char* Status::CopyState(const char* state) {$/;"	f	class:leveldb::Status
Status	util/status.cc	/^Status::Status(Code code, const Slice& msg, const Slice& msg2) {$/;"	f	class:leveldb::Status
ToString	util/status.cc	/^std::string Status::ToString() const {$/;"	f	class:leveldb::Status
leveldb	util/status.cc	/^namespace leveldb {$/;"	n	file:
StopWatch	util/stop_watch.h	/^	StopWatch(Env* const env,Statistics *statistics,const uint32_t hist_type):env_(env),start_time_(env->NowMicros()),$/;"	f	class:leveldb::StopWatch
StopWatch	util/stop_watch.h	/^class StopWatch{$/;"	c	namespace:leveldb
env_	util/stop_watch.h	/^	Env *env_;$/;"	m	class:leveldb::StopWatch
hist_type_	util/stop_watch.h	/^	uint32_t hist_type_;$/;"	m	class:leveldb::StopWatch
leveldb	util/stop_watch.h	/^namespace leveldb {$/;"	n
setHistType	util/stop_watch.h	/^	void setHistType(uint32_t hist_type){$/;"	f	class:leveldb::StopWatch
start_time_	util/stop_watch.h	/^	const uint64_t start_time_;$/;"	m	class:leveldb::StopWatch
statistics_	util/stop_watch.h	/^	Statistics *statistics_;$/;"	m	class:leveldb::StopWatch
~StopWatch	util/stop_watch.h	/^	~StopWatch(){$/;"	f	class:leveldb::StopWatch
RandomSeed	util/testharness.cc	/^int RandomSeed() {$/;"	f	namespace:leveldb::test
RegisterTest	util/testharness.cc	/^bool RegisterTest(const char* base, const char* name, void (*func)()) {$/;"	f	namespace:leveldb::test
RunAllTests	util/testharness.cc	/^int RunAllTests() {$/;"	f	namespace:leveldb::test
Test	util/testharness.cc	/^struct Test {$/;"	s	namespace:leveldb::test::__anon33	file:
TmpDir	util/testharness.cc	/^std::string TmpDir() {$/;"	f	namespace:leveldb::test
base	util/testharness.cc	/^  const char* base;$/;"	m	struct:leveldb::test::__anon33::Test	file:
func	util/testharness.cc	/^  void (*func)();$/;"	m	struct:leveldb::test::__anon33::Test	file:
leveldb	util/testharness.cc	/^namespace leveldb {$/;"	n	file:
name	util/testharness.cc	/^  const char* name;$/;"	m	struct:leveldb::test::__anon33::Test	file:
test	util/testharness.cc	/^namespace test {$/;"	n	namespace:leveldb	file:
tests	util/testharness.cc	/^std::vector<Test>* tests;$/;"	m	namespace:leveldb::test::__anon33	file:
ASSERT_EQ	util/testharness.h	107;"	d
ASSERT_GE	util/testharness.h	109;"	d
ASSERT_GT	util/testharness.h	110;"	d
ASSERT_LE	util/testharness.h	111;"	d
ASSERT_LT	util/testharness.h	112;"	d
ASSERT_NE	util/testharness.h	108;"	d
ASSERT_OK	util/testharness.h	106;"	d
ASSERT_TRUE	util/testharness.h	105;"	d
BINARY_OP	util/testharness.h	77;"	d
BINARY_OP	util/testharness.h	93;"	d
Is	util/testharness.h	/^  Tester& Is(bool b, const char* msg) {$/;"	f	class:leveldb::test::Tester
IsOk	util/testharness.h	/^  Tester& IsOk(const Status& s) {$/;"	f	class:leveldb::test::Tester
STORAGE_LEVELDB_UTIL_TESTHARNESS_H_	util/testharness.h	6;"	d
TCONCAT	util/testharness.h	114;"	d
TCONCAT1	util/testharness.h	115;"	d
TEST	util/testharness.h	117;"	d
Tester	util/testharness.h	/^  Tester(const char* f, int l)$/;"	f	class:leveldb::test::Tester
Tester	util/testharness.h	/^class Tester {$/;"	c	namespace:leveldb::test
fname_	util/testharness.h	/^  const char* fname_;$/;"	m	class:leveldb::test::Tester
leveldb	util/testharness.h	/^namespace leveldb {$/;"	n
line_	util/testharness.h	/^  int line_;$/;"	m	class:leveldb::test::Tester
ok_	util/testharness.h	/^  bool ok_;$/;"	m	class:leveldb::test::Tester
operator <<	util/testharness.h	/^  Tester& operator<<(const V& value) {$/;"	f	class:leveldb::test::Tester
ss_	util/testharness.h	/^  std::stringstream ss_;$/;"	m	class:leveldb::test::Tester
test	util/testharness.h	/^namespace test {$/;"	n	namespace:leveldb
~Tester	util/testharness.h	/^  ~Tester() {$/;"	f	class:leveldb::test::Tester
CompressibleString	util/testutil.cc	/^extern Slice CompressibleString(Random* rnd, double compressed_fraction,$/;"	f	namespace:leveldb::test
RandomKey	util/testutil.cc	/^std::string RandomKey(Random* rnd, int len) {$/;"	f	namespace:leveldb::test
RandomString	util/testutil.cc	/^Slice RandomString(Random* rnd, int len, std::string* dst) {$/;"	f	namespace:leveldb::test
leveldb	util/testutil.cc	/^namespace leveldb {$/;"	n	file:
test	util/testutil.cc	/^namespace test {$/;"	n	namespace:leveldb	file:
ErrorEnv	util/testutil.h	/^  ErrorEnv() : EnvWrapper(Env::Default()),$/;"	f	class:leveldb::test::ErrorEnv
ErrorEnv	util/testutil.h	/^class ErrorEnv : public EnvWrapper {$/;"	c	namespace:leveldb::test
NewAppendableFile	util/testutil.h	/^  virtual Status NewAppendableFile(const std::string& fname,$/;"	f	class:leveldb::test::ErrorEnv
NewWritableFile	util/testutil.h	/^  virtual Status NewWritableFile(const std::string& fname,$/;"	f	class:leveldb::test::ErrorEnv
STORAGE_LEVELDB_UTIL_TESTUTIL_H_	util/testutil.h	6;"	d
leveldb	util/testutil.h	/^namespace leveldb {$/;"	n
num_writable_file_errors_	util/testutil.h	/^  int num_writable_file_errors_;$/;"	m	class:leveldb::test::ErrorEnv
test	util/testutil.h	/^namespace test {$/;"	n	namespace:leveldb
writable_file_error_	util/testutil.h	/^  bool writable_file_error_;$/;"	m	class:leveldb::test::ErrorEnv
BGItem	util/threadpool_imp.cc	/^  struct BGItem {$/;"	s	struct:leveldb::ThreadPoolImpl::Impl	file:
BGThread	util/threadpool_imp.cc	/^void ThreadPoolImpl::Impl::BGThread(size_t thread_id) {$/;"	f	class:leveldb::ThreadPoolImpl::Impl
BGThreadMetadata	util/threadpool_imp.cc	/^  BGThreadMetadata(ThreadPoolImpl::Impl* thread_pool, size_t thread_id)$/;"	f	struct:leveldb::BGThreadMetadata
BGThreadMetadata	util/threadpool_imp.cc	/^struct BGThreadMetadata {$/;"	s	namespace:leveldb	file:
BGThreadWrapper	util/threadpool_imp.cc	/^void* ThreadPoolImpl::Impl::BGThreadWrapper(void* arg) {$/;"	f	class:leveldb::ThreadPoolImpl::Impl
GetBackgroundThreads	util/threadpool_imp.cc	/^int ThreadPoolImpl::GetBackgroundThreads() {$/;"	f	class:leveldb::ThreadPoolImpl
GetBackgroundThreads	util/threadpool_imp.cc	/^int ThreadPoolImpl::Impl::GetBackgroundThreads() {$/;"	f	class:leveldb::ThreadPoolImpl::Impl
GetHostEnv	util/threadpool_imp.cc	/^  Env* GetHostEnv() const { return env_; }$/;"	f	struct:leveldb::ThreadPoolImpl::Impl
GetHostEnv	util/threadpool_imp.cc	/^Env* ThreadPoolImpl::GetHostEnv() const { return impl_->GetHostEnv(); }$/;"	f	class:leveldb::ThreadPoolImpl
GetQueueLen	util/threadpool_imp.cc	/^  unsigned int GetQueueLen() const {$/;"	f	struct:leveldb::ThreadPoolImpl::Impl
GetQueueLen	util/threadpool_imp.cc	/^unsigned int ThreadPoolImpl::GetQueueLen() const {$/;"	f	class:leveldb::ThreadPoolImpl
GetThreadPriority	util/threadpool_imp.cc	/^  Env::Priority GetThreadPriority() const { return priority_; }$/;"	f	struct:leveldb::ThreadPoolImpl::Impl
GetThreadPriority	util/threadpool_imp.cc	/^Env::Priority ThreadPoolImpl::GetThreadPriority() const {$/;"	f	class:leveldb::ThreadPoolImpl
HasExcessiveThread	util/threadpool_imp.cc	/^  bool HasExcessiveThread() const {$/;"	f	struct:leveldb::ThreadPoolImpl::Impl
IOPRIO_CLASS_SHIFT	util/threadpool_imp.cc	217;"	d	file:
IOPRIO_PRIO_VALUE	util/threadpool_imp.cc	218;"	d	file:
Impl	util/threadpool_imp.cc	/^ThreadPoolImpl::Impl::Impl()$/;"	f	class:leveldb::ThreadPoolImpl::Impl
Impl	util/threadpool_imp.cc	/^struct ThreadPoolImpl::Impl {$/;"	s	class:leveldb::ThreadPoolImpl	file:
IncBackgroundThreadsIfNeeded	util/threadpool_imp.cc	/^void ThreadPoolImpl::IncBackgroundThreadsIfNeeded(int num) {$/;"	f	class:leveldb::ThreadPoolImpl
IsExcessiveThread	util/threadpool_imp.cc	/^  bool IsExcessiveThread(size_t thread_id) const {$/;"	f	struct:leveldb::ThreadPoolImpl::Impl
IsLastExcessiveThread	util/threadpool_imp.cc	/^  bool IsLastExcessiveThread(size_t thread_id) const {$/;"	f	struct:leveldb::ThreadPoolImpl::Impl
JoinAllThreads	util/threadpool_imp.cc	/^void ThreadPoolImpl::JoinAllThreads() {$/;"	f	class:leveldb::ThreadPoolImpl
JoinThreads	util/threadpool_imp.cc	/^void ThreadPoolImpl::Impl::JoinThreads(bool wait_for_jobs_to_complete) {$/;"	f	class:leveldb::ThreadPoolImpl::Impl
LowerIOPriority	util/threadpool_imp.cc	/^void ThreadPoolImpl::Impl::LowerIOPriority() {$/;"	f	class:leveldb::ThreadPoolImpl::Impl
LowerIOPriority	util/threadpool_imp.cc	/^void ThreadPoolImpl::LowerIOPriority() {$/;"	f	class:leveldb::ThreadPoolImpl
NewThreadPool	util/threadpool_imp.cc	/^ThreadPool* NewThreadPool(int num_threads) {$/;"	f	namespace:leveldb
PthreadCall	util/threadpool_imp.cc	/^void ThreadPoolImpl::PthreadCall(const char* label, int result) {$/;"	f	class:leveldb::ThreadPoolImpl
Schedule	util/threadpool_imp.cc	/^void ThreadPoolImpl::Schedule(void(*function)(void* arg1), void* arg,$/;"	f	class:leveldb::ThreadPoolImpl
SetBackgroundThreads	util/threadpool_imp.cc	/^void ThreadPoolImpl::SetBackgroundThreads(int num) {$/;"	f	class:leveldb::ThreadPoolImpl
SetBackgroundThreadsInternal	util/threadpool_imp.cc	/^void ThreadPoolImpl::Impl::SetBackgroundThreadsInternal(int num,$/;"	f	class:leveldb::ThreadPoolImpl::Impl
SetHostEnv	util/threadpool_imp.cc	/^  void SetHostEnv(Env* env) { env_ = env; }$/;"	f	struct:leveldb::ThreadPoolImpl::Impl
SetHostEnv	util/threadpool_imp.cc	/^void ThreadPoolImpl::SetHostEnv(Env* env) { impl_->SetHostEnv(env); }$/;"	f	class:leveldb::ThreadPoolImpl
SetThreadPriority	util/threadpool_imp.cc	/^  void SetThreadPriority(Env::Priority priority) { priority_ = priority; }$/;"	f	struct:leveldb::ThreadPoolImpl::Impl
SetThreadPriority	util/threadpool_imp.cc	/^void ThreadPoolImpl::SetThreadPriority(Env::Priority priority) {$/;"	f	class:leveldb::ThreadPoolImpl
StartBGThreads	util/threadpool_imp.cc	/^void ThreadPoolImpl::Impl::StartBGThreads() {$/;"	f	class:leveldb::ThreadPoolImpl::Impl
Submit	util/threadpool_imp.cc	/^void ThreadPoolImpl::Impl::Submit(std::function<void()>&& schedule,$/;"	f	class:leveldb::ThreadPoolImpl::Impl
SubmitJob	util/threadpool_imp.cc	/^void ThreadPoolImpl::SubmitJob(const std::function<void()>& job) {$/;"	f	class:leveldb::ThreadPoolImpl
SubmitJob	util/threadpool_imp.cc	/^void ThreadPoolImpl::SubmitJob(std::function<void()>&& job) {$/;"	f	class:leveldb::ThreadPoolImpl
ThreadPoolImpl	util/threadpool_imp.cc	/^ThreadPoolImpl::ThreadPoolImpl() :$/;"	f	class:leveldb::ThreadPoolImpl
UnSchedule	util/threadpool_imp.cc	/^int ThreadPoolImpl::Impl::UnSchedule(void* arg) {$/;"	f	class:leveldb::ThreadPoolImpl::Impl
UnSchedule	util/threadpool_imp.cc	/^int ThreadPoolImpl::UnSchedule(void* arg) {$/;"	f	class:leveldb::ThreadPoolImpl
WaitForJobsAndJoinAllThreads	util/threadpool_imp.cc	/^void ThreadPoolImpl::WaitForJobsAndJoinAllThreads() {$/;"	f	class:leveldb::ThreadPoolImpl
WakeUpAllThreads	util/threadpool_imp.cc	/^  void WakeUpAllThreads() {$/;"	f	struct:leveldb::ThreadPoolImpl::Impl
bgsignal_	util/threadpool_imp.cc	/^  std::condition_variable  bgsignal_;$/;"	m	struct:leveldb::ThreadPoolImpl::Impl	file:
bgthreads_	util/threadpool_imp.cc	/^  std::vector<port::Thread> bgthreads_;$/;"	m	struct:leveldb::ThreadPoolImpl::Impl	file:
env_	util/threadpool_imp.cc	/^  Env*         env_;$/;"	m	struct:leveldb::ThreadPoolImpl::Impl	file:
exit_all_threads_	util/threadpool_imp.cc	/^  bool exit_all_threads_;$/;"	m	struct:leveldb::ThreadPoolImpl::Impl	file:
function	util/threadpool_imp.cc	/^    std::function<void()> function;$/;"	m	struct:leveldb::ThreadPoolImpl::Impl::BGItem	file:
leveldb	util/threadpool_imp.cc	/^namespace leveldb {$/;"	n	file:
low_io_priority_	util/threadpool_imp.cc	/^  bool low_io_priority_;$/;"	m	struct:leveldb::ThreadPoolImpl::Impl	file:
mu_	util/threadpool_imp.cc	/^  std::mutex               mu_;$/;"	m	struct:leveldb::ThreadPoolImpl::Impl	file:
priority_	util/threadpool_imp.cc	/^  Env::Priority priority_;$/;"	m	struct:leveldb::ThreadPoolImpl::Impl	file:
queue_len_	util/threadpool_imp.cc	/^  std::atomic_uint queue_len_;  \/\/ Queue length. Used for stats reporting$/;"	m	struct:leveldb::ThreadPoolImpl::Impl	file:
tag	util/threadpool_imp.cc	/^    void* tag = nullptr;$/;"	m	struct:leveldb::ThreadPoolImpl::Impl::BGItem	file:
thread_id_	util/threadpool_imp.cc	/^  size_t thread_id_;  \/\/ Thread count in the thread.$/;"	m	struct:leveldb::BGThreadMetadata	file:
thread_pool_	util/threadpool_imp.cc	/^  ThreadPoolImpl::Impl* thread_pool_;$/;"	m	struct:leveldb::BGThreadMetadata	file:
total_threads_limit_	util/threadpool_imp.cc	/^  int total_threads_limit_;$/;"	m	struct:leveldb::ThreadPoolImpl::Impl	file:
unschedFunction	util/threadpool_imp.cc	/^    std::function<void()> unschedFunction;$/;"	m	struct:leveldb::ThreadPoolImpl::Impl::BGItem	file:
wait_for_jobs_to_complete_	util/threadpool_imp.cc	/^  bool wait_for_jobs_to_complete_;$/;"	m	struct:leveldb::ThreadPoolImpl::Impl	file:
~Impl	util/threadpool_imp.cc	/^ThreadPoolImpl::Impl::~Impl() { JoinThreads(false); assert(bgthreads_.size() == 0U); }$/;"	f	class:leveldb::ThreadPoolImpl::Impl
~ThreadPoolImpl	util/threadpool_imp.cc	/^ThreadPoolImpl::~ThreadPoolImpl() {$/;"	f	class:leveldb::ThreadPoolImpl
ThreadPoolImpl	util/threadpool_imp.h	/^class ThreadPoolImpl : public ThreadPool {$/;"	c	namespace:leveldb
impl_	util/threadpool_imp.h	/^   std::unique_ptr<Impl>   impl_;$/;"	m	class:leveldb::ThreadPoolImpl
leveldb	util/threadpool_imp.h	/^namespace leveldb {$/;"	n
override	util/threadpool_imp.h	/^  int GetBackgroundThreads() override;$/;"	m	class:leveldb::ThreadPoolImpl
override	util/threadpool_imp.h	/^  unsigned int GetQueueLen() const override;$/;"	m	class:leveldb::ThreadPoolImpl
override	util/threadpool_imp.h	/^  void JoinAllThreads() override;$/;"	m	class:leveldb::ThreadPoolImpl
override	util/threadpool_imp.h	/^  void SetBackgroundThreads(int num) override;$/;"	m	class:leveldb::ThreadPoolImpl
override	util/threadpool_imp.h	/^  void SubmitJob(const std::function<void()>&) override;$/;"	m	class:leveldb::ThreadPoolImpl
override	util/threadpool_imp.h	/^  void SubmitJob(std::function<void()>&&) override;$/;"	m	class:leveldb::ThreadPoolImpl
override	util/threadpool_imp.h	/^  void WaitForJobsAndJoinAllThreads() override;$/;"	m	class:leveldb::ThreadPoolImpl
getopt	util_exp/testcratio.py	/^import getopt$/;"	i
main	util_exp/testcratio.py	/^def main():$/;"	f
process	util_exp/testcratio.py	/^def process(a):$/;"	f
sys	util_exp/testcratio.py	/^import sys$/;"	i
